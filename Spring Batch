Spring Batch:
==================

09/01/2013

Spring Batch which provides batch and bulk processing capabilities. The architecture is extremely robust and it provides 

parallel as well as scheduled batch processing. The API provides template and helper classes for repeatable and retryable 

operations which will be discussed in this article with suitable examples.


Spring Batch is an open source framework for batch processing. It is a lightweight, comprehensive solution designed to 

enable the development of robust batch applications, which are often found in modern enterprise systems. Spring Batch 

builds upon the POJO-based development approach of the Spring Framework.

Spring Batch provides reusable functions that are essential in processing large volumes of records, including 

logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also 

provides more advanced technical services and features that will enable extremely high-volume and high performance batch 

jobs though optimization and partitioning techniques.

"Many applications within the enterprise domain require bulk processing to perform business operations in mission critical 

environments. These business operations include automated, complex processing of large volumes of information that is most 

efficiently processed without user interaction."These operations typically include time based events (e.g. month-end 

calculations, notices or correspondence), periodic application of complex business rules processed repetitively across very 

large data sets (e.g. Insurance benefit determination or rate adjustments), or the integration of information that is 

received from internal and external systems that typically requires formatting, validation and processing in a 

transactional manner into the system of record. Batch processing is used to process billions of transactions every day for 

enterprises.

Spring Batch is a lightweight, comprehensive batch framework designed to enable the development of robust batch 

applications vital for the daily operations of enterprise systems. Spring Batch builds upon the productivity, POJO-based 

development approach, and general ease of use capabilities people have come to know from the Spring Framework, while making 

it easy for developers to access and leverage more advance enterprise services when necessary. Spring Batch is not a 

scheduling framework. There are many good enterprise schedulers available in both the commercial and open source spaces 

such as Quartz, Tivoli, Control-M, etc. It is intended to work in conjunction with a scheduler, not replace a scheduler.

Spring Batch provides reusable functions that are essential in processing large volumes of records, including 

logging/tracing, transaction management, job processing statistics, job restart, skip, and resource management. It also 

provides more advance technical services and features that will enable extremely high-volume and high performance batch 

jobs though optimization and partitioning techniques. Simple as well as complex, high-volume batch jobs can leverage the 

framework in a highly scalable manner to process significant volumes of information.


A typical batch program generally reads a large number of records from a database, file, or queue, processes the data in 

some fashion, and then writes back data in a modified form. Spring Batch automates this basic batch iteration, providing 

the capability to process similar transactions as a set, typically in an offline environment without any user interaction. 

Batch jobs are part of most IT projects and Spring Batch is the only open source framework that provides a robust, 

enterprise-scale solution.


Job:
======
==> A Job is an entity that encapsulates an entire batch process.As is common with other Spring projects, a Job will be 

wired together via an XML configuration file. This file may be referred to as the "job configuration".Job is just the top 

of an overall hierarchy:


==> JobParameters is a set of parameters used to start a batch job. 

==> A Job defines what a job is and how it is to be executed,and JobInstance is a purely organizational object to group 

executions together, primarily to enable correct restart semantics.

==> A JobExecution, however, is the primary storage mechanism for what actually happened during a run, and as such contains 

many more properties that must be controlled and persisted:


Step:
=====
==> A Step is a domain object that encapsulates an independent, sequential phase of a batch job.

==> Therefore, every Job is composed entirely of one or more steps. A Step contains all of the information necessary to 

define and control the actual batch processing.

==> A StepExecution represents a single attempt to execute a Step

==> A new StepExecution will be created each time a Step is run, similar to JobExecution.However, if a step fails to 

execute because the step before it fails, there will be no execution persisted for it.

==> A StepExecution will only be created when its Step is actually started

JobRepository :
===============

==> JobRepository is the persistence mechanism for all of the Stereotypes mentioned above. It provides CRUD operations for 

JobLauncher, Job, and Step implementations. When a Job is first launched, a JobExecution is obtained from the repository, 

and during the course of execution StepExecution and JobExecution implementations are persisted by passing them to the 

repository:

<job-repository id="jobRepository"/>

JobLauncher:
============

JobLauncher represents a simple interface for launching a Job with a given set of JobParameters:

public interface JobLauncher {

    public JobExecution run(Job job, JobParameters jobParameters) 
                throws JobExecutionAlreadyRunningException, JobRestartException;
}


==> ItemReader is an abstraction that represents the retrieval of input for a Step, 

==> ItemWriter is an abstraction that represents the output of a Step, 

==> ItemProcessor is an abstraction that represents the business processing of an item. While the ItemReader reads one 

item, and the ItemWriter writes them, the ItemProcessor provides access to transform or apply other business processing. 

If, while processing the item, it is determined that the item is not valid, returning null indicates that the item should 

not be written out.



====================================================


Configuring a Job:
==========

There are multiple implementations of the Job interface, however, the namespace abstracts away the differences in 

configuration. It has only three required dependencies: a name, JobRepository , and a list of Steps.

<job id="footballJob" job-repository="specialRepository">
    <step id="playerload"          parent="s1" next="gameLoad"/>
    <step id="gameLoad"            parent="s3" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
</job>


Restartability:
===========

One key issue when executing a batch job concerns the behavior of a Job when it is restarted. The launching of a Job is 

considered to be a 'restart' if a JobExecution already exists for the particular JobInstance. Ideally, all jobs should be 

able to start up where they left off, but there are scenarios where this is not possible. It is entirely up to the 

developer to ensure that a new JobInstance is created in this scenario. However, Spring Batch does provide some help. If a 

Job should never be restarted, but should always be run as part of a new JobInstance, then the restartable property may be 

set to 'false'

<job id="footballJob" restartable="false">
    ...
</job>




Configuring a JobRepository:
============================

As described in earlier, the JobRepository is used for basic CRUD operations of the various persisted domain objects within 

Spring Batch, such as JobExecution and StepExecution. It is required by many of the major framework features, such as the 

JobLauncher, Job, and Step. The batch namespace abstracts away many of the implementation details of the JobRepository 

implementations and their collaborators. However, there are still a few configuration options available:

<job-repository id="jobRepository"
    data-source="dataSource"
    transaction-manager="transactionManager"
    isolation-level-for-create="SERIALIZABLE"
    table-prefix="BATCH_"
  max-varchar-length="1000"
/>


Configuring a JobLauncher:
==========================

The most basic implementation of the JobLauncher interface is the SimpleJobLauncher. Its only required dependency is a 

JobRepository, in order to obtain an execution:

<bean id="jobLauncher"
      class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    <property name="jobRepository" ref="jobRepository" />
</bean>

==============================================================

10/01/2013



Job - A job represents your entire batch work. Each night you need to collect all of the 1)credit card transactions, 2)

collect them in a file and then 3)send them over to the settlement provider. Here I defined three logical steps. In Spring 

Batch a job is made of up of Steps. Each Step being a unit of work.

Step – A job is made up of one or more steps.

JobInstance - A running instance of the job that you have defined. Think of the Job as a class and the job instance as your 

, well object. Our credit card processing job runs 7 days a week at 11pm. Each executions is a JobInstance.

JobParameters - Parameters that go into a JobInstance.

JobExecution - Every attempt to run a JobInstance results in a JobExecution. For some reasons Jan 1st, 2008 CC Settlement 

job failed. It is re-run and now it succeeds. So we have one JobInstance but two executions (thus two JobExecutions). There 

also exists the concept of StepExecution. This represents an attempt to run a Step in a Job.

JobRepository - This is the persistent store for all of our job definitions. In this example I setup the repository to use 

an in-memory persistent store. You can back it up with a database if you want.

JobLauncher – As the name suggests, this object lets you launch a job.

TaskLet - Situations where you do not have input and output processing (using readers and writers).  We use a tasklet in 

this blog.

The next three definitions do not apply to this blog since I will not be using them. Part II of this blog will show an 

example on these.

ItemReader - Abstraction used to represent an object that allows you to read in one object of interest that you want to 

process. In my credit card example it could be one card transaction retrieved from the database.

ItemWriter - Abstraction used to write out the final results of a batch. In the credit card example it could be a provider 

specific representation of the transaction which needs to be in a file. Maybe in XML or comma separated flat file.

ItemProcessor - Very important. Here you can initiate business logic on a just read item. Perform computations on the 

object and maybe calculate more fields before passing on to the writer to write out to the output file.



impurls:
========
http://blogs.justenougharchitecture.com/?p=122
http://static.springsource.org/spring-batch/reference/html/configureJob.html
http://alain-cieslik.com/2011/06/02/a-job-with-spring-batch/
http://code.google.com/p/springbatch-tutorial/source/checkout
https://github.com/thomasma/springbatch3part
http://jroller.com/0xcafebabe/entry/spring_batch_hello_world_1
http://www.javabeat.net/2011/04/launching-a-spring-batch-job/

for db schema

https://fisheye.springsource.org/browse/spring-batch/spring-batch-

core/src/main/resources/org/springframework/batch/core/schema-drop-oracle10g.sql?

r=f38c05567a392a925319336eed3cda87a501b065&r=be80d14d09eab51dee9faee507164131164a6e70&r=be80d14d09eab51dee9faee507164131164

a6e70&r=79c86bf13dbb7c19c45c97ce12942257de2995af
