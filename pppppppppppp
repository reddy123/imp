package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;




/**
 * Column Mapping Annotation is used to provide column names of domain
 * class. It will also contain the table name of column.
 * An domain object can be mapped to more than one table and hence their attributes can also 
 * mapped to more than one one columns of different tables. In this case respective domain
 * field will have following declaration at field level
 *  @ColumnMapping(tableName="TABLE_ONE", columnName="A_COLUMN_OF_TABLE_ONE")
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO")
 *  
 *  if it is a primary key 
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO", primaryKey=true)
 *  
 * @author vishwanath.dubey
 *
 */
@Documented
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)

public  @interface  Column {
	String tableName() default "";
	String columnName();
	String fieldName() default "";
	String aliasName() default "";
	boolean primaryKey() default false;
	boolean autoGenerated() default  false;
	GeneratedType generatedType() default GeneratedType.Blank;
	String seq()  default "";
	String lookup()  default ""; //"", Yes, No
}

package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Column Mapping Annotation is used to provide column names of domain
 * class. It will also contain the table name of column.
 * An domain object can be mapped to more than one table and hence their attributes can also 
 * mapped to more than one one columns of different tables. In this case respective domain
 * field will have following declaration at field level
 *  @ColumnMapping(tableName="TABLE_ONE", columnName="A_COLUMN_OF_TABLE_ONE")
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO")
 *  
 *  if it is a primary key 
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO", primaryKey=true)
 *  
 * @author vishwanathdubey
 *
 */
@Documented
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Columns {
	Column[] value();
}

package com.cnk.travelerp.common.persistence.annotation.declaration;

public enum GeneratedType {
	
	Auto,
	Identity,
	Sequence,
	Table,
	Blank

}
package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Joins 
 *  
 *  if it is a primary key 
 *  @Joins({"LTableName=PERSON,LColumnName=ID,RTableName=PERSON,RColumnName=ID",""})
 *  
 * @author vishwanathdubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Join {
	String lTableName();
	String lColumnName();
	String rTableName();
	String rColumnName();

}

package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Joins 
 *  
 *  if it is a primary key 
 *  @Joins({"LTableName=PERSON,LColumnName=ID,RTableName=PERSON,RColumnName=ID",""})
 *  
 * @author vishwanathdubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Joins {
	Join[] value();
}

package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;




/**
 * Column Mapping Annotation is used to provide column names of domain
 * class. It will also contain the table name of column.
 * An domain object can be mapped to more than one table and hence their attributes can also 
 * mapped to more than one one columns of different tables. In this case respective domain
 * field will have following declaration at field level
 *  @ColumnMapping(tableName="TABLE_ONE", columnName="A_COLUMN_OF_TABLE_ONE")
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO")
 *  
 *  if it is a primary key 
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO", primaryKey=true)
 *  
 * @author vishwanath.dubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)

public  @interface  ParentColumn {
	String tableName();
	String columnName();
	String fieldName();
	String aliasName() default "";
	boolean primaryKey() default false;
	boolean autoGenerated() default  false;
	GeneratedType generatedType() default GeneratedType.Blank;
	String seq()  default "";
	boolean lookup() default false;

}

package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Column Mapping Annotation is used to provide column names of domain
 * class. It will also contain the table name of column.
 * An domain object can be mapped to more than one table and hence their attributes can also 
 * mapped to more than one one columns of different tables. In this case respective domain
 * field will have following declaration at field level
 *  @ColumnMapping(tableName="TABLE_ONE", columnName="A_COLUMN_OF_TABLE_ONE")
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO")
 *  
 *  if it is a primary key 
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO", primaryKey=true)
 *  
 * @author vishwanathdubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ParentColumns {
	ParentColumn[] value();
}

package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Table Mapping Annotation is used to provide table names of domain
 * class. 
 * An domain object can be mapped to more than one table. In this case respective domain
 * class will have following declaration at class level
 *  * @TableMapping(tableName="TABLE_ONE,TABLE_TWO")
 *  
 * @author vishwanath.dubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {

	String tableName();
	boolean mainTable() default false;
	boolean autoKey() default false;
	String[] keyColumns() default "";
	String aliasName() default "";
}
package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


/**
 * Table Mapping Annotation is used to provide table names of domain
 * class. 
 * An domain object can be mapped to more than one table. In this case respective domain
 * class will have following declaration at class level
 *  * @TableMapping(tableName="TABLE_ONE,TABLE_TWO")
 *  
 * @author vishwanath.dubey
 *
 */
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Tables {
	/**
	 * tables={"tableName=TABLE1,mainTable=true,autoKey=true,keyColumns=ID","tableName=TABLE2"}
	 * 
	 * @return String[]
	 */
	Table[] value();
	/**
	 * join="TABLE1.ID=TABLE2.ID"
	 * 
	 * @return String
	 */
//	String join() default ""; 
}

package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import com.cnk.travelerp.common.persistence.sql.CompositeStatement;
import com.cnk.travelerp.common.persistence.sql.Statement;

/**
 * 
 * @author vishwanath.dubey
 * 
 */
public abstract class AbstractSQLGenerator implements SQLGenerator {

    protected static final String INSERT_LITTERAL = "Insert INTO ";
    protected static final String UPDATE_LITTERAL = "Update ";
    protected static final String SET_LITTERAL = " Set ";
    protected static final String SELECT_LITTERAL = "Select ";
    protected static final String DELETE_LITTERAL = "Delete ";
    protected static final String FROM_LITTERAL = " From ";
    public static final String WHERE_LITTERAL = " Where ";
    protected static final String VALUES_LITTERAL = " Values ";
    protected static final String EQUAL_LITTERAL = " = ";
    protected static final String PLACE_HOLDER_LITTERAL = "? ";
    protected static final String COMMA_CHAR = ", ";
    protected static final String LEFT_BRACKET_LITERAL = "(";
    protected static final String RIGHT_BRACKET_LITTERAL = ")";
    protected static final String SPACE_CHAR = " ";
    protected static final String AND_LITTERAL = " AND ";

    protected Statement.StatementType statmentType = Statement.StatementType.Insert;

    @Override
    public void generateStatement(DomainMapping domainMapping) {
        Map<TableMapping, List<ColumnMapping>> tableAndColumns = domainMapping.tableMapping;
        TableMapping mainTabMapping = null;
        Statement statement = null;

        if (tableAndColumns.size() == 1) { // when only one table is mapped.
            mainTabMapping = tableAndColumns.keySet().iterator().next();
            statement = new Statement(statmentType);
            statement.isAutoKey = mainTabMapping.autoKey;
            statement.targetName = mainTabMapping.tableName;
            statement.addAllDefaultValues(mainTabMapping.defaultValues);
            List<ColumnMapping> columnMappings = tableAndColumns
                    .get(mainTabMapping);
            if (columnMappings == null || columnMappings.size() == 0) {
                return; // it should throw an exception
            }
            generate(columnMappings, statement);
            addIfNotNul(domainMapping.statements, statement);
            return;
        }

        // from here it is for defining more than one table
        for (TableMapping tabMapping : tableAndColumns.keySet()) {
            if (tabMapping.mainTable) {
                mainTabMapping = tabMapping;
                break;
            }
        }
        if (mainTabMapping == null) {
            return;// need to throw an exception or return a blank statement
        }
        CompositeStatement mainstatement = new CompositeStatement(statmentType);
        mainstatement.isAutoKey = mainTabMapping.autoKey;
        mainstatement.targetName = mainTabMapping.tableName;
        mainstatement.addAllDefaultValues(mainTabMapping.defaultValues);
        List<ColumnMapping> columnMappings = tableAndColumns
                .get(mainTabMapping);
        generate(columnMappings, mainstatement);
        statement = mainstatement;
        for (TableMapping tabMap : tableAndColumns.keySet()) {
            if (tabMap == mainTabMapping) { // making sure not processing for
                                            // main table.
                continue;
            }
            Statement statementSub = new Statement(statmentType);
            // statement.isAutoKey = tabMap.autoKey;
            statementSub.isAutoKey = false; // autokey should only for main
                                            // table.
            statementSub.targetName = tabMap.tableName;
            statementSub.addAllDefaultValues(tabMap.defaultValues);
            columnMappings = tableAndColumns.get(tabMap);
            if (columnMappings == null || columnMappings.size() == 0) {
                continue;
            }
            generate(columnMappings, statementSub);
            mainstatement.subStatements.add(statementSub);
        }
        addIfNotNul(domainMapping.statements, statement);
        System.out.println("generate statement :" + statement.sqlStatement);
    }

    protected abstract void generate(List<ColumnMapping> columnMappings,
            Statement statement);

    // /**
    // * in case of auto key generation, it will retreive the auto key columns.
    // it will only implemented for insert generate statement.
    // * @param domainMapping
    // */
    // protected void retiriveAutoKey(DomainMapping
    // domainMapping,List<ColumnMapping> columnMappings){
    //
    // }

    protected static void appendCondition(StringBuilder sb, List<String> keys,
            List<String> pkeys, Statement statement) {
        if (pkeys.size() != keys.size()) {
            return;
        }

        if (keys.size() > 0 && sb.indexOf(WHERE_LITTERAL) < 0) {
            sb.append(WHERE_LITTERAL);
        }
        int i = 0;
        for (String column : keys) {
            if (i > 0) {
                sb.append(AND_LITTERAL);
            }
            sb.append(column).append(EQUAL_LITTERAL)
                    .append(PLACE_HOLDER_LITTERAL);
            i++;
        }
        statement.sqlStatement = sb.toString();
        statement.placeHolderAttributes = pkeys
                .toArray(new String[pkeys.size()]);

    }

    protected static TableMapping getTableMapping(
            Collection<TableMapping> tables, String tableName) {
        for (TableMapping table : tables) {
            if (table.tableName.equals(tableName)) {
                return table;
            }
        }
        return null;
    }

    private static <T> void addIfNotNul(List<T> list, T t) {
        if (t != null) {
            list.add(t);
        }

    }

}

package com.cnk.travelerp.common.persistence.annotation.processor;

import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;




/**
 * Column Mapping Annotation is used to provide column names of domain
 * class. It will also contain the table name of column.
 * An domain object can be mapped to more than one table and hence their attributes can also 
 * mapped to more than one one columns of different tables. In this case respective domain
 * field will have following declaration at field level
 *  @ColumnMapping(tableName="TABLE_ONE", columnName="A_COLUMN_OF_TABLE_ONE")
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO")
 *  
 *  if it is a primary key 
 *  @ColumnMapping(tableName="TABLE_TWO", columnName="A_COLUMN_OF_TABLE_TWO", primaryKey=true)
 *  
 * @author vishwanath.dubey
 *
 */
public class ColumnMapping {
	
	enum FIELDS{fieldName,tableName,columnName,aliasName,primaryKey,autoGenerated}
	
	String fieldName;
	String tableName;
	String columnName;
	String aliasName;
	boolean primaryKey =  false;
	boolean autoGenerated =  false;
	boolean lookup =  false;
	
	GeneratedType generatedType;
	String seq;
	
	
	public ColumnMapping(String fieldName, String tableName, String columnName,
			String aliasName, boolean primaryKey, boolean autoGenerated,
			GeneratedType generatedType,
			String seq,boolean lookup) {
		super();
		this.fieldName = fieldName;
		this.tableName = tableName;
		this.columnName = columnName;
		this.aliasName = aliasName;
		this.primaryKey = primaryKey;
		this.autoGenerated = autoGenerated;
		this.generatedType = generatedType;
		this.seq = seq;
		this.lookup = lookup;
	}


	/**
	 * @return the fieldName
	 */
	public String getFieldName() {
		return fieldName;
	}


	/**
	 * @return the columnName
	 */
	public String getColumnName() {
		return columnName;
	}


	public String getTableName() {
		return tableName;
	}


	public String getAliasName() {
		return aliasName;
	}


	public boolean isPrimaryKey() {
		return primaryKey;
	}


	public boolean isAutoGenerated() {
		return autoGenerated;
	}


	public GeneratedType getGeneratedType() {
		return generatedType;
	}


	public String getSeq() {
		return seq;
	}

	
	
	
//	public final static ColumnMapping process(Column column){
//		ColumnMapping colMap = new ColumnMapping();
//		colMap.aliasName = column.aliasName();
//		colMap.columnName = column.columnName();
//		colMap.fieldName = column.fieldName();
//		colMap.autoGenerated = column.autoGenerated();
//		colMap.primaryKey = column.primaryKey();
//		return colMap;
//		
//	}

//	public final static ColumnMapping process(String fieldName,String fields){
//		String[] attributes = fields.split(",");
//		ColumnMapping colMapping = new ColumnMapping();
//		colMapping.fieldName = fieldName;
//
//		for(int i=0;i<attributes.length;i++){
//			String field = attributes[i];
//			String[] keyVal = field.split("=");
//
//			FIELDS f = FIELDS.valueOf(keyVal[0]);
//			String val = keyVal[1];
//			switch( f ){
//			case tableName:
//				colMapping.tableName = val;
//				break;
//			case columnName:
//				colMapping.columnName = val;
//				break;
//			case aliasName:
//				colMapping.aliasName = val;
//				break;
//			case primaryKey:
//				colMapping.primaryKey = Boolean.parseBoolean( val );
//				break;
//			case autoGenerated:
//				colMapping.autoGenerated = Boolean.parseBoolean( val );
//				break;
//			default:
//
//			}
//
//		}
//		//make alisName as column name if it is not defined.
//		if (colMapping.aliasName == null || colMapping.aliasName.isEmpty() ){
//			colMapping.aliasName = colMapping.columnName;
//		}
//
//		return colMapping;
//	}

}

package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.List;

import com.cnk.travelerp.common.persistence.sql.Statement;

public class DeleteSQLGenerator extends AbstractSQLGenerator{
	
	private static SQLGenerator generator = new DeleteSQLGenerator();
	
	public static SQLGenerator getSQLGenerator(){
		return generator;
	}

	private DeleteSQLGenerator(){
		statmentType =  Statement.StatementType.Delete;
	}

	
	@Override
	protected void generate(List<ColumnMapping> columnMappings, Statement statement) {
		StringBuilder sb = new StringBuilder();
		sb.append(DELETE_LITTERAL).append( statement.targetName).append(SPACE_CHAR);;
		List<String> keys = new ArrayList<>(5);
		List<String> pkeys = new ArrayList<>(5);
		for(ColumnMapping column:columnMappings){
			if (column.primaryKey){
				keys.add( column.columnName);
    			pkeys.add(column.aliasName);

			}
		}
		
		appendCondition(sb,keys,pkeys,statement);
	}
	
	

}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.springframework.util.Assert;

import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.model.EntityDBMappingModel;

public class DomainMapping {
	
	String domainClassName; //in case of masters, it will be simple name of master.
	Map<TableMapping, List<ColumnMapping>> tableMapping;
	List<JoinMapping> joinMapping;
	

	EntityDBMappingModel em; //for master this should be 'not null'.

	

	List<Statement> statements = new ArrayList<>(7);
	String attributeMapping;
	
	List<Reference> downreferences;
	List<Reference> upreferences;
	
	
	List<ColumnMapping> autoKeyFields = new ArrayList<>(5);
	List<Field> keyFields = new ArrayList<>(5);

	List<Field> downRefFields = new ArrayList<>();
	List<Field> upRefFields = new ArrayList<>();

	List<Field> referenceKeyFields = new ArrayList<>();
	
	
	
	/**
	 * @return the domainClassName
	 */
	public String getDomainName() {
		return domainClassName;
	}



	/**
	 * @return the attributeMapping
	 */
	public String getAttributeMapping() {
		return attributeMapping;
	}

	

	/**
	 * @return the statements
	 */
	public List<Statement> getStatements() {
		return statements;
	}



	public Statement getStatement(Statement.StatementType stmtType){
		for(Statement stmt:statements){
			if (stmt.getStatementType() == stmtType){
				return stmt;
			}
		}
		return null;
	}


	/**
	 * return true or false if domain is mapped to more than one tables.
	 * @return
	 */
	public boolean isComposite(){
		if (tableMapping != null){
			return tableMapping.size()>1;
		}
		return false;
	}
	
	
	/**
	 * in case of auto key generation, it will retreive the auto key columns. it will only implemented for insert generate statement.
	 * @param domainMapping
	 */
	protected void updateAutoKey(){
		List<String> columns = new ArrayList<>();
		for(Entry<TableMapping, List<ColumnMapping>> keyValue:tableMapping.entrySet()){
			for(ColumnMapping col:keyValue.getValue()){
				if (columns.contains(col.fieldName)){
					continue;
				}
				if (col.autoGenerated && col.primaryKey){
					autoKeyFields.add(col);	
					columns.add(col.fieldName);
				}
			}
		}
	}
	
	/**
	 * 
	 */
	
	public List<ColumnMapping> getAutoKeys(){
		return  Collections.unmodifiableList(autoKeyFields);
	}
	
	
	/**
	 * 
	 * @param dbFieldName
	 * @return
	 */
	public List<String> retreiveAutoKeyAlias(){
		List<String> retList = new ArrayList<>();
		ColumnMapping columnM = null;
		if (autoKeyFields.size()==1){
			columnM = autoKeyFields.get(0);
		}
		
		Assert.isTrue(columnM != null);
		for(Entry<TableMapping, List<ColumnMapping>> keyValue:tableMapping.entrySet()){
			for(ColumnMapping col:keyValue.getValue()){
				if (col.fieldName.equals(columnM.fieldName)){
					retList.add(col.aliasName);
				}
			}
		}
		return retList;
			
	}

	
	
	
	/**
	 * 
	 * @param dbFieldName
	 * @return
	 */
	public List<String> retreiveAutoKeyAliasByDBFieldName(String dbFieldName){
		List<String> retList = new ArrayList<>();

		ColumnMapping columnM = null;
		for(ColumnMapping column:autoKeyFields){
			if (column.columnName.equals(dbFieldName)){
				columnM = column;
				break;
			}
		}
			
		if (columnM == null){
			return null;
		}
		
		
		for(Entry<TableMapping, List<ColumnMapping>> keyValue:tableMapping.entrySet()){
			for(ColumnMapping col:keyValue.getValue()){
				if (col.fieldName.equals(columnM.fieldName)){
					retList.add(col.aliasName);
				}
			}
		}
		return retList;
	}
	
	public TableMapping getMainTable(){
		for(TableMapping tabMap:tableMapping.keySet()){
			if (tabMap.mainTable){
				return tabMap;
			}
		}
		return tableMapping.keySet().iterator().next();
	}
	
	/**
	 * 
	 * @param dbFieldName
	 * @return
	 */
	public List<String> getDBFields(String fieldName){
		List<String> retList = new ArrayList<>();
		boolean moreThanOneTable = tableMapping.size() >1;
		String tabAlias = "";
//		TableMapping mainTabMapping = null;
		for(Entry<TableMapping, List<ColumnMapping>> keyValue:tableMapping.entrySet()){
//			if (keyValue.getKey().mainTable){
//				mainTabMapping = keyValue.getKey();
//			}
			tabAlias =""; 
			if (moreThanOneTable){
				tabAlias =keyValue.getKey().aliasName+".";
			}
			
			
			for(ColumnMapping col:keyValue.getValue()){
				if (col.fieldName.equals(fieldName)){
					retList.add(tabAlias+col.columnName);
				}
			}
			
		}
		
//		for(Reference ref:upreferences){
//			tabAlias ="";
//			//TODO: need to think of join table
////			ref.getJoinTable();
//			
//			if (ref.joinColumns == null){
//				continue;
//			}
//			tabAlias =""; 
//			if (moreThanOneTable){
//				tabAlias = mainTabMapping.aliasName+".";
//			}
//
//			for(JoinColumnMapping joinColumn:ref.joinColumns){
//				if (joinColumn.referenceField.equals(fieldName)){
//					retList.add(tabAlias+joinColumn.getName());
//				}
//			}
//		}
		return retList;
		
	}
	
	
	public List<ColumnMapping> getColumnMappingByFieldName(String fieldName){
		List<ColumnMapping> retList = new ArrayList<>();
		
		for(Entry<TableMapping, List<ColumnMapping>> entry:tableMapping.entrySet()){
			List<ColumnMapping> values = entry.getValue();
			for(ColumnMapping colMap:values){
				if (fieldName.equals(colMap.fieldName)){
					retList.add(colMap);
				}
			}
		}
		return retList;
	}
	
	public void updateFields(Class<?> clazz){
		autoKeyFields(clazz);
		downReferences(clazz);
		upReferences(clazz);
	}

	private void autoKeyFields(Class<?> clazz){
		for(ColumnMapping key:autoKeyFields){
			try{
				Field f =clazz.getDeclaredField( key.fieldName);
				f.setAccessible(true);
				keyFields.add(f);
			}
			catch(NoSuchFieldException ne){
				
			}
			
		}
	}
	
	
	private void downReferences(Class<?> clazz){
		for(Reference ref:downreferences){
			try{
				Field f =clazz.getDeclaredField( ref.fieldName);
				f.setAccessible(true);
				downRefFields.add(f);
			}
			catch(NoSuchFieldException ne){
				
			}
			
		}
	}
	
	private void upReferences(Class<?> clazz){
		for(Reference ref:upreferences){
			try{
				Field f =clazz.getDeclaredField( ref.fieldName);
				f.setAccessible(true);
				upRefFields.add(f);
			}
			catch(NoSuchFieldException ne){
				
			}
			
		}
	}

	public <T> void  setValue(T t, Object val){
//		Assert.isTrue(keyFields.size() == 1);
		Field f = keyFields.get(0);
		try{
			f.set(t, val);
		}
		catch(IllegalAccessException ie){
			
		}
		
	}
	
	
	public <T> Object  getValue(T t,String fieldName){
//		Assert.isTrue(keyFields.size() == 1);
		Field f = null;
		for(Field f1:keyFields){
			if (f1.getName().equals(fieldName)){
				f=f1;
				break;
			}
		}
		if (f == null){
			return null;
		}
		try{
			return f.get(t);
		}
		catch(IllegalAccessException ie){
			
		}
		return null;
		
	}
	
	public List<Reference> getDownReferences(){
		Assert.isTrue(downreferences  != null);
		return Collections.unmodifiableList(downreferences);
	}
	
	public List<Field> getFieldDownReferences(){
		Assert.isTrue(downRefFields  != null);
		return Collections.unmodifiableList(downRefFields);
	}

	public Field getFieldDownReferences(String fieldName){
		Assert.isTrue(downRefFields  != null);
		for(Field f:downRefFields){
			if (f.getName().equals(fieldName)){
				return f;
			}
		}
		return null;
	}

	public List<Reference> getUpReferences(){
		Assert.isTrue(upreferences  != null);
		return Collections.unmodifiableList(upreferences);
	}
	
	public Reference getParentReference(String fieldName){
		for(Reference ref:upreferences){
			if (ref.fieldName.equals(fieldName)){
				return ref;
			}
		}
		return null;
	}
	
	public List<Field> getFieldUpReferences(){
		Assert.isTrue(upRefFields  != null);
		return Collections.unmodifiableList(upRefFields);
	}
	
	
	public <T> List<Object> retrieveDependants(T t){
		List<Object> objects = new ArrayList<>();
		for(Field f:downRefFields){
			try{
				objects.add( f.get(t) );
			}
			catch(IllegalAccessException e){
				
			}
		}
		return objects;
	}

	
	/**
	 * 
	 */
	private <T> Field updateReferenceKey(Class<T> clazz,String fieldName) {
		try{
			Field field = clazz.getDeclaredField(fieldName);
			field.setAccessible(true);
			referenceKeyFields.add(field);
			return field;
		}
		catch(NoSuchFieldException NSE){

		}
		return null;
	}
	
	/**
	 * 
	 */
	private <T> void updateReferenceKeyValue(T t,String fieldName,Object val) {
		Field field = null;
		for(Field f:referenceKeyFields){
			if (f.getName().equals(fieldName)){
				field = f;
				break;
			}
		}
		if (field == null){
			field = updateReferenceKey(t.getClass(), fieldName);
		}
		if (field != null){
			try{
				field.set(t, val);
			}
			catch(IllegalAccessException ie){
				
			}
		}

	}

	
	
	/**
	 * 
	 * @param s: Source object
	 * @param t: target Object
	 * @param targetDM target domainObject
	 */
	public <S,T> void updateValue(S s,T t, DomainMapping targetDM){
		List<Reference> downReferences = this.getDownReferences();
		List<Reference> upReferences = targetDM.getUpReferences();
		Reference upReference = null;
		boolean found = false;
		for(Reference downref:downReferences){
			String mappedField = downref.getMappedBy();
			for(Reference upRef:upReferences){
				if (upRef.getFieldName().equals(mappedField)){
					upReference = upRef;
					found = true;
					break;
				}
			}
			if (found){
				break;
			}
		}
		for(JoinColumnMapping joinColumnMap :upReference.getJoinColumns()){
			String refFieldName = joinColumnMap.referenceField;
			String currentFieldName = joinColumnMap.name;
			Object val = getValue(s,refFieldName);
			updateReferenceKeyValue(t,currentFieldName,val);
			
			
		}
	}

}
package com.cnk.travelerp.common.persistence.annotation.processor;


import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.Columns;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Join;
import com.cnk.travelerp.common.persistence.annotation.declaration.Joins;
import com.cnk.travelerp.common.persistence.annotation.declaration.ParentColumn;
import com.cnk.travelerp.common.persistence.annotation.declaration.ParentColumns;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;
import com.cnk.travelerp.common.persistence.annotation.declaration.Tables;
import com.cnk.travelerp.common.persistence.model.AttributeDBMappingModel;
import com.cnk.travelerp.common.persistence.model.ColumnMappingModel;
import com.cnk.travelerp.common.persistence.model.EntityDBMappingModel;
import com.cnk.travelerp.common.persistence.model.EntityIdentifier;
import com.cnk.travelerp.common.persistence.model.JoinMappingModel;
import com.cnk.travelerp.common.persistence.model.ReferenceDBMappingModel;
import com.cnk.travelerp.common.persistence.model.TableMappingModel;


/**
 * this class to actually carry out the process of Tabel Mapping annotatioan where it will read
 * all the table and column mapping annotation informations and based on it it will 
 * generate SQL DML statement.
 * @author vishwanathdubey
 *
 */
public class DomainMappingProcessor{


	public static DomainMapping processAnnotations(Object obj) {
		return processAnnotations(obj.getClass());
	}

	public static DomainMapping processAnnotations(Class<?> clazz) {

		Map<TableMapping, List<ColumnMapping>> tableColumnMapping =	new LinkedHashMap<>();
		List<Reference> references =	new ArrayList<>();

		List<JoinMapping> joins =new ArrayList<>(5);
		getTableNames(clazz,tableColumnMapping, joins);

		for(Field f : clazz.getDeclaredFields()) {
			getFieldMapping(f,tableColumnMapping,references);
		}
		

		DomainMapping domainMapping = new DomainMapping();
		domainMapping.tableMapping = tableColumnMapping;
		domainMapping.joinMapping = joins;
		domainMapping.domainClassName = clazz.getSimpleName();
		domainMapping.updateAutoKey();
		
		List<Reference> downReference = new ArrayList<>();
		List<Reference> upReference = new ArrayList<>();
		for(Reference ref:references){
			switch(ref.direction){
				case DOWN:
					downReference.add(ref);
					break;
				case UP:
					upReference.add(ref);
					break;
					
			}
		}
		
		domainMapping.downreferences = downReference;
		domainMapping.upreferences = upReference;
		
		processForAlias(domainMapping);
		
		
//		domainMapping.joinMapping = tableColumnMapping;
		
		return domainMapping;

	}
	
	 private static char[] alphas = new char[]{'A','B','C','D','E','F','G'};
	 
	 
	 private static void getTableNames(Class<?> clazz,Map<TableMapping, List<ColumnMapping>> tableColumnMapping,List<JoinMapping> joins){
			List<TableMapping> tables =new ArrayList<>(5);

		 List<ColumnMapping> parentColumnMap = new ArrayList<>();
		 for(Annotation a : clazz.getAnnotations()) {
	    	 if(a.annotationType() == Tables.class) {
	    		 Table[] tabs = ((Tables)a).value();
	    		 for(Table t:tabs){
	    			 TableMapping tabMap = new TableMapping(
	    					 t.tableName(),t.mainTable(),t.autoKey(),t.keyColumns(),t.aliasName());
	    			 tables.add(tabMap);
	    		 }
//	    		 TableMapping tMapping[] = TableMapping.process(mapping.tables());
//	    		 tables.addAll( Arrays.asList(tMapping));
	    	 }
	    	 else if(a.annotationType() == Table.class) {
	    		 Table t = ((Table)a);
    			 TableMapping tabMap = new TableMapping(
    					 t.tableName(),t.mainTable(),t.autoKey(),t.keyColumns(),t.aliasName());
    			 tables.add(tabMap);
	    	 }
	    	 else if(a.annotationType() == Joins.class) {
	    		 Join[] ajoins = ((Joins)a).value();
	    		 for(Join j:ajoins){
	    			 JoinMapping jMap = new JoinMapping(
	    					 j.lTableName(),j.lColumnName(),
	    					 j.rTableName(),j.rColumnName());
	    			 joins.add(jMap);
	    			 
	    		 }
//	    		 JoinMapping tMapping[] = JoinMapping.process(mapping.joins());
//	    		 joins.addAll( Arrays.asList(tMapping));
	    	 }
	    	 else if(a.annotationType() == Join.class) {
	    		 Join j = (Join)a;
    			 JoinMapping jMap = new JoinMapping(
    					 j.lTableName(),j.lColumnName(),
    					 j.rTableName(),j.rColumnName());
    			 joins.add(jMap);
	    		 
	    	 }
	    	 else if(a.annotationType() == ParentColumns.class) {
	    		 ParentColumn[] columns = ((ParentColumns)a).value();
	    		 if (columns == null || columns.length == 0){
	    			 continue;
	    		 }
	    		 for(ParentColumn column:columns){
	    			ColumnMapping colMap = new ColumnMapping(
	    					column.fieldName(),column.tableName(),column.columnName(),
	    					column.aliasName(),column.primaryKey(),column.autoGenerated()
	    					,column.generatedType(),column.seq(),column.lookup());
    				if (colMap.aliasName.isEmpty()  ){
    					colMap.aliasName = colMap.columnName;
	    			}
    				parentColumnMap.add(colMap);
	    		 }
	    	 }
	    	 
	 		for(TableMapping map:tables){
				tableColumnMapping.put(map, new ArrayList<ColumnMapping>());
			}

	    	 if (parentColumnMap.size()>0){

	    		 
	    		 for(ColumnMapping colMap:parentColumnMap){
	    			 TableMapping tabMapping = null;
	    			 for(TableMapping map:tableColumnMapping.keySet()){
	    				 if (colMap.tableName.equals(map.tableName)){
	    					 tabMapping = map;
	    					 break;
	    				 }
	    			 }
	    			 if (tabMapping==null){
	    				 continue;
	    			 }
	    			 tableColumnMapping.get(tabMapping).add(colMap);
	    		 }
	    	 }
	    	 
	     }
		 //Allocate a alias name
		 int i=0;
		 for(TableMapping table:tables){
			 table.aliasName = String.valueOf(alphas[i] );
			 i++;
		 }
	 }




	 
	 
	 private static void getFieldMapping(Field field,
			 Map<TableMapping, List<ColumnMapping>> tableColumnMapping,
			 List<Reference> references){
		
		 TableMapping mainTable = retrievMainTable(tableColumnMapping);
		 
		 Annotation[] annotations = field.getAnnotations();
		 for(Annotation a : annotations) {
	    	 if(a.annotationType() == Columns.class) {
	    		 Column[] columns = ((Columns)a).value();
	    		 if (columns == null || columns.length == 0){
	    			 continue;
	    		 }
	    		 for(Column column:columns){
	    			 buildColumnMapping(field,tableColumnMapping,mainTable,column);
//	    			ColumnMapping colMap = new ColumnMapping(
//	    					field.getName(),column.tableName(),column.columnName(),
//	    					column.aliasName(),column.primaryKey(),column.autoGenerated());
//    				if (colMap.aliasName.isEmpty()  ){
//    					colMap.aliasName = colMap.columnName;
//	    			}
//
//	    			 TableMapping tabMapping = null;
//	    			 for(TableMapping map:tableColumnMapping.keySet()){
//	    				 if (colMap.tableName.equals(map.tableName)){
//	    					 tabMapping = map;
//	    					 break;
//	    				 }
//	    			 }
//	    			 if (tabMapping==null){
//	    				 continue;
//	    			 }
//	    			 tableColumnMapping.get(tabMapping).add(colMap);
	    		 }
	    	 }
	    	 else if(a.annotationType() == Column.class) {
	    		 Column column = (Column)a;
	    		 buildColumnMapping(field,tableColumnMapping,mainTable,column);
	    	 }
	    	 else if (a.annotationType() == OneToOne.class  ) {
	    		 OneToOne oneToOne = (OneToOne)a;
	    		 String mappedBy = oneToOne.mappedBy();
	    		 boolean isParent = false;
	    		 if (mappedBy != null){
	    			 isParent = mappedBy.isEmpty();
	    		 }
	    		 Reference ref = getReferences(annotations,field,
	    				 isParent,Reference.RelationshipType.OneToOne,
	    				 oneToOne.targetEntity(),oneToOne.mappedBy());
	    		 references.add(ref);
	    	 }
	    	 else if (a.annotationType() == OneToMany.class) {
	    		 OneToMany oneToMany = (OneToMany)a;
	    		 String mappedBy = oneToMany.mappedBy();
	    		 boolean isParent = false;
	    		 if (mappedBy != null){
	    			 isParent = mappedBy.isEmpty();
	    		 }
	    		 Reference ref = getReferences(annotations,field,
	    				 isParent,Reference.RelationshipType.OneToMany,
	    				 oneToMany.targetEntity(),oneToMany.mappedBy());
	    		 
	    		 references.add(ref);
	    	 }
	    	 else if (a.annotationType() == ManyToOne.class) {
//	    		 ManyToOne manyToOne = (ManyToOne)a;
	    		 Reference ref = getReferences(annotations,field,
	    				 Reference.RelationshipType.ManyToOne,
	    				 Reference.Direction.UP);

	    		 references.add(ref);
	    	 }
	    	 else if (a.annotationType() == ManyToMany.class) {
	    		 ManyToMany manToMany = (ManyToMany)a;
	    		 String mappedBy = manToMany.mappedBy();
	    		 boolean isParent = false;
	    		 if (mappedBy != null){
	    			 isParent = mappedBy.isEmpty();
	    		 }
	    		 Reference ref = getReferences(annotations,field,
	    				 isParent,Reference.RelationshipType.OneToMany,
	    				 manToMany.targetEntity(),manToMany.mappedBy());
	    		 
	    		 references.add(ref);
	    	 }	    	 

	     }
		 
		 
	 }
	 
	 private static void buildColumnMapping(Field field,Map<TableMapping, List<ColumnMapping>> tableColumnMapping, TableMapping mainTable,Column column){

		 String tableName = column.tableName();
		 if (tableName.isEmpty()){
			 tableName = mainTable.tableName;
		 }
		 boolean lookup = false;
		 if (column.primaryKey() && column.lookup().isEmpty() 
				 || column.lookup().equalsIgnoreCase("Yes")  )
		 {
			 lookup = true;
		 }
		 
		 ColumnMapping colMap = new ColumnMapping(
				 field.getName(),tableName,column.columnName(),
				 column.aliasName(),column.primaryKey(),column.autoGenerated(),
				 column.generatedType(),column.seq(),lookup);
		 if (colMap.aliasName.isEmpty()  ){
			 colMap.aliasName = colMap.columnName;
		 }

		 TableMapping tabMapping = null;
		 for(TableMapping map:tableColumnMapping.keySet()){
			 if (colMap.tableName.equals(map.tableName)){
				 tabMapping = map;
				 break;
			 }
		 }
		 if (tabMapping != null && !tabMapping.autoKey){
			 tabMapping.autoKey = column.primaryKey() && column.autoGenerated();
		 }
		 
		 if (tabMapping==null){
			 return;
		 }
		 tableColumnMapping.get(tabMapping).add(colMap);
	 }
	 
	 
	 private static TableMapping retrievMainTable(Map<TableMapping, List<ColumnMapping>> tableColumnMapping){
		 for(TableMapping tabMapping:tableColumnMapping.keySet()){
			 if (tabMapping.mainTable){
				 return tabMapping;
			 }
		 }
		 return tableColumnMapping.keySet().iterator().next();
	 }
	 
	 private static Reference getReferences(Annotation[] annotations,
											Field field,boolean isParent,
											Reference.RelationshipType refType,
											@SuppressWarnings("rawtypes") Class targetClazz,
											String  mappedBy){
		 Reference refs = null;
		 if (isParent ){ // parent entity
			 refs = getReferences(annotations,field,Reference.RelationshipType.OneToOne,Reference.Direction.UP);
//    		 Annotation joinTable = getAnnotationType(annotations, JoinTable.class);
		 }
		 else {

			 refs = new Reference(field.getName(),
					 		mappedBy,
					 		targetClazz,
					 		Reference.RelationshipType.OneToOne,
					 		Reference.Direction.DOWN);
					 
		 }
		 return refs;

	 }

	 private static Reference getReferences(Annotation[] annotations,
								Field field,
								Reference.RelationshipType refType,
								Reference.Direction direction){
							
		 Reference refs = null;
		 
		 Annotation ajoinTable = getAnnotationType(annotations, JoinTable.class);
		 Annotation ajoinColumns = getAnnotationType(annotations, JoinColumns.class);
		 Annotation ajoinColumn = getAnnotationType(annotations, JoinColumn.class);
		 
		 if (ajoinTable != null){
			 JoinTable joinTable = (JoinTable)ajoinTable;
			 String tableName = joinTable.name();
    		 JoinColumnMapping[] map = getJoinColumnMapping( joinTable.joinColumns() );
    		 JoinTableMapping tabMapping = new JoinTableMapping(tableName, map);
    		 
    		 refs = new Reference(field.getName(), 
    				 						tabMapping, 
    				 						refType,
    				 						direction);
			 
		 }
		 else if (ajoinColumns != null){
    		 JoinColumn[] joinCols = ((JoinColumns)ajoinColumns).value();
    		 JoinColumnMapping[] map = getJoinColumnMapping( joinCols ); 
			 refs = new Reference(field.getName(),
					 	map,
 						refType,
 						direction);
			 
		 }
		 else if (ajoinColumn != null){
			 JoinColumn joinColumn = (JoinColumn)ajoinColumn;
			 refs = new Reference(field.getName(),
					    new JoinColumnMapping[]{ new JoinColumnMapping(joinColumn.name(),joinColumn.referencedColumnName())},
 						refType,
 						direction);
		 }

		 return refs;
	 }
	 
	 private static JoinColumnMapping[] getJoinColumnMapping(JoinColumn[] joinCols){
		 JoinColumnMapping[] map = new JoinColumnMapping[joinCols.length];
		 for(int i=0;i<joinCols.length;i++){
			 map[i] = new JoinColumnMapping(joinCols[i].name(),joinCols[i].referencedColumnName());
		 }
		 return map;
	 }
	 private static Annotation getAnnotationType(Annotation[] anos, Class<? extends Annotation> clazz){
		 for(Annotation a : anos) {
 			 if(a.annotationType() == clazz) {
 				 return a;
			 }
		 }
		 return null;
	 }
	 private static void processForAlias( DomainMapping domainMapping){
//			List<String> fieldNames = new ArrayList<>();
		   Map<TableMapping, List<ColumnMapping>> tableColumnMapping = domainMapping.tableMapping;
		   
		   if (tableColumnMapping.size() > 1){
//			   List<String> aliasDefined = new ArrayList<>();
			   for(TableMapping tableMapping:tableColumnMapping.keySet()){
				   for(ColumnMapping column:tableColumnMapping.get(tableMapping)){
					   column.aliasName = tableMapping.aliasName +"_"+column.aliasName;
//					   if (aliasDefined.contains(column.fieldName)){
//						   column.aliasName = tableMapping.aliasName +"_"+column.aliasName;
//					   }
//					   else {
//						   column.aliasName = column.fieldName;
//					   }
//					   aliasDefined.add(column.aliasName);
				   }
			   }
		   }
		   
		   
			Map<String,List<String>> fieldMap = new LinkedHashMap<>();
			for(TableMapping tableMapping:tableColumnMapping.keySet()){
				for(ColumnMapping column:tableColumnMapping.get(tableMapping)){
					if (fieldMap.get(column.fieldName) == null){
						List<String> fs = new ArrayList<>();
						fieldMap.put(column.fieldName, fs);
						fs.add(column.aliasName); //set alias name
					}
					else{
						fieldMap.get(column.fieldName).add(column.aliasName); //set the aliase Name
					}
				}
			}
			StringBuilder sb = new StringBuilder();
			int i=0;
			for(String attribute:fieldMap.keySet()){
				for(String v:fieldMap.get(attribute)){
					if (i>0){
						sb.append(",");
					}
					sb.append( attribute ).append("=").append(v);
					i++;
				}
			}
			domainMapping.attributeMapping=sb.toString();
	 }
	 
	
	 private static void processForAliasMaster( DomainMapping domainMapping){
//			List<String> fieldNames = new ArrayList<>();
		   Map<TableMapping, List<ColumnMapping>> tableColumnMapping = domainMapping.tableMapping;
		   
		   if (tableColumnMapping.size() > 1){
			   List<String> aliasDefined = new ArrayList<>();
			   for(TableMapping tableMapping:tableColumnMapping.keySet()){
				   for(ColumnMapping column:tableColumnMapping.get(tableMapping)){
					   column.aliasName = tableMapping.aliasName +"_"+column.aliasName;
					   if (aliasDefined.contains(column.fieldName)){
						   column.aliasName = tableMapping.aliasName +"_"+column.aliasName;
					   }
					   else {
						   column.aliasName = column.fieldName;
					   }
					   aliasDefined.add(column.aliasName);
				   }
			   }
		   }
		   
		   
			Map<String,List<String>> fieldMap = new LinkedHashMap<>();
			for(TableMapping tableMapping:tableColumnMapping.keySet()){
				for(ColumnMapping column:tableColumnMapping.get(tableMapping)){
					if (fieldMap.get(column.fieldName) == null){
						List<String> fs = new ArrayList<>();
						fieldMap.put(column.fieldName, fs);
						fs.add(column.aliasName); //set alias name
					}
					else{
						fieldMap.get(column.fieldName).add(column.aliasName); //set the aliase Name
					}
				}
			}
			StringBuilder sb = new StringBuilder();
			int i=0;
			for(String attribute:fieldMap.keySet()){
				for(String v:fieldMap.get(attribute)){
					if (i>0){
						sb.append(",");
					}
					sb.append( attribute ).append("=").append(v);
					i++;
				}
			}
			domainMapping.attributeMapping=sb.toString();
	 }
	 
	 
	 
	 
		public static DomainMapping processEM(EntityDBMappingModel eDBModel) {
			DomainMapping domainMapping = new DomainMapping();
			domainMapping.tableMapping = new LinkedHashMap<>();
			domainMapping.joinMapping = new ArrayList<>(5);
			domainMapping.domainClassName = eDBModel.getName();
			
			domainMapping.em = eDBModel;
			processEMColumns(eDBModel,domainMapping);
			domainMapping.updateAutoKey();
			
			return domainMapping;
		}
 

		private static void processEMColumns(EntityDBMappingModel eDBModel,DomainMapping domainMapping){
			List<TableMappingModel> tables = eDBModel.getTables();
			
			TableMapping mainTabMapping = null;
			for(TableMappingModel t:tables){
				TableMapping tabMap = new TableMapping(
   					 t.getTableName(),t.isMainTable(),t.isAutoKey(),t.getKeyColumns(),
   					 	t.getAliasName());
				domainMapping.tableMapping.put(tabMap, new ArrayList<ColumnMapping>());
				
				if (t.isMainTable()){
					mainTabMapping = tabMap;
				}
				
				for(EntityIdentifier i:eDBModel.getIdentifiers()){
					if (i.getTableName().equals(tabMap.tableName)){
						tabMap.addDefaultValues(i.getColumnName(), i.getValue());
					}
				}
			}
			if (mainTabMapping == null){
				if (domainMapping.tableMapping.size() == 1){
					mainTabMapping = domainMapping.tableMapping.keySet().iterator().next();
				}
				else {
					//TODO throw exception
				}
			}
			
			for(JoinMappingModel j:eDBModel.getJoins()){

				JoinMapping jMap = new JoinMapping(
						j.getlTableName(),j.getlColumnName(),
						j.getrTableName(),j.getrColumnName());
				domainMapping.joinMapping.add(jMap);
			}
	
			for(AttributeDBMappingModel a:eDBModel.getAttributes()	){
				for(ColumnMappingModel colMapModel  :a.getColumns()){
					
					String tableName = mainTabMapping.tableName;
					if (colMapModel.getTableName() != null && !colMapModel.getTableName().isEmpty()){
						tableName = colMapModel.getTableName();
					}
					
					boolean isAutoGenerated = colMapModel.isAutoGenerated();
					String seq = colMapModel.getSeq();
					
					GeneratedType genKey = GeneratedType.Blank;
					if (colMapModel.getGeneratedKey() != null && !colMapModel.getGeneratedKey().isEmpty()){
						try{
							genKey = GeneratedType.valueOf(colMapModel.getGeneratedKey());
						}
						catch(Exception e){
							genKey = GeneratedType.Blank;
							isAutoGenerated = false;
							seq = "";
						}
					}
					 boolean lookup = false;
					 if (colMapModel.isPrimaryKey() && colMapModel.getLookup().isEmpty() 
							 || colMapModel.getLookup().equalsIgnoreCase("Yes")  )
					 {
						 lookup = true;
					 }
					 
					
					ColumnMapping colMap = new ColumnMapping(
							a.getName(), tableName,colMapModel.getColumnName(),colMapModel.getAliasName(),
							colMapModel.isPrimaryKey(),isAutoGenerated,genKey,seq,lookup ); //LOOKUP
					
					if (colMap.aliasName == null || colMap.aliasName.isEmpty() ){
						colMap.aliasName = colMap.columnName;
					}

					TableMapping tabMapping = null;
					for(TableMapping map:domainMapping.tableMapping.keySet()){
						if (colMap.tableName.equals(map.tableName)){
							tabMapping = map;
							break;
						}
					}
					
					 if (tabMapping != null && !tabMapping.autoKey){
						 tabMapping.autoKey = colMap.isAutoGenerated() && colMap.isPrimaryKey();
					 }
					if (tabMapping==null){
						continue;
					}
					domainMapping.tableMapping.get(tabMapping).add(colMap);
				}
			}
			
			processForAliasMaster(domainMapping);
			processForAliasReferences( eDBModel,domainMapping );
		}
		
		 private static void processForAliasReferences( EntityDBMappingModel eDBModel,DomainMapping domainMapping ){
			 
			 StringBuilder sb = new StringBuilder();
			 List<ReferenceDBMappingModel> references = eDBModel.getReferences();
			 int i=0;
			 for(ReferenceDBMappingModel rdb:references){
				 if (i>0){
					 sb.append(",");
				 }
//				 sb.append(rdb.getDisplayName()).append("=").append( rdb.getAliasName());
				 sb.append(rdb.getDisplayName()).append("=").append( rdb.getDisplayName());
				 i++;
			 }
			 if (!domainMapping.attributeMapping.isEmpty()){
				 domainMapping.attributeMapping = domainMapping.attributeMapping+","+sb.toString(); 
			 }
			 else {
				 domainMapping.attributeMapping = sb.toString(); 
				 
			 }
			 
		 }


}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import com.cnk.travelerp.common.persistence.sql.Statement;

public class InsertSQLGenerator extends AbstractSQLGenerator {

    private static SQLGenerator generator = new InsertSQLGenerator();

    public static SQLGenerator getSQLGenerator() {
        return generator;
    }

    private InsertSQLGenerator() {
        statmentType = Statement.StatementType.Insert;
    }

    @Override
    protected void generate(List<ColumnMapping> columnMappings,
            Statement statement) {
        StringBuilder sb = new StringBuilder();
        sb.append(INSERT_LITTERAL).append(statement.targetName)
                .append(SPACE_CHAR);
        int index = 0;
        sb.append(LEFT_BRACKET_LITERAL);
        Set<ColumnMapping> columns = SQLStatementGenerator
                .filteredColumns(columnMappings);
        List<String> colList = new ArrayList<>(columns.size());
        for (ColumnMapping column : columns) {
            sb.append(column.columnName).append(COMMA_CHAR);
            colList.add(column.aliasName);
            index++;
        }
        for (String columnName : statement.getDefaultValues().keySet()) {
            sb.append(columnName).append(COMMA_CHAR);
            colList.add(columnName);
            index++;
        }

        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
        }
        sb.append(RIGHT_BRACKET_LITTERAL).append(VALUES_LITTERAL)
                .append(LEFT_BRACKET_LITERAL);

        for (index = 0; index < columns.size(); index++) {
            sb.append("?").append(COMMA_CHAR);
        }
        for (int j = 0; j < statement.getDefaultValues().keySet().size(); j++, index++) {
            sb.append("?").append(COMMA_CHAR);

        }
        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
        }
        sb.append(RIGHT_BRACKET_LITTERAL);

        statement.sqlStatement = sb.toString();
        statement.placeHolderAttributes = colList.toArray(new String[colList
                .size()]);

    }

    // /**
    // * in case of auto key generation, it will retreive the auto key columns.
    // it will only implemented for insert generate statement.
    // * @param domainMapping
    // */
    // @Override
    // protected void retiriveAutoKey(DomainMapping
    // domainMapping,List<ColumnMapping> columnMappings){
    // for(ColumnMapping columnMapping:columnMappings){
    // if (columnMapping.autoGenerated){
    // domainMapping.autoKeyFields.add(columnMapping);
    // }
    // }
    // }

}
package com.cnk.travelerp.common.persistence.annotation.processor;

public class JoinColumnMapping {
    String name;
    String referenceField;
	/**
	 * @param name
	 * @param referenceField
	 */
	public JoinColumnMapping(String name, String referenceField) {
		super();
		this.name = name;
		this.referenceField = referenceField;
	}
	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}
	/**
	 * @return the referenceField
	 */
	public String getReferenceField() {
		return referenceField;
	}

	
    
    
}
package com.cnk.travelerp.common.persistence.annotation.processor;




/**
 * Join Mapping Annotation is used to provide table and column names 
 * for joining more than two tables.
 *  
 * @author vishwanath.dubey
 *
 */
public class JoinMapping {
	
	enum FIELDS{LTableName,LColumnName,RTableName,RColumnName}
	
	String lTableName;
	String lColumnName;
	String rTableName;
	String rColumnName;
	
	
	
	
	public JoinMapping(String lTableName, String lColumnName,
			String rTableName, String rColumnName) {
		super();
		this.lTableName = lTableName;
		this.lColumnName = lColumnName;
		this.rTableName = rTableName;
		this.rColumnName = rColumnName;
	}




//	public final static JoinMapping[] process(String[] fields){
//		JoinMapping[] joins = new JoinMapping[fields.length];
//		for(int j=0;j<fields.length;j++ ){
//			String[] attributes = fields[j].split(",");
//			JoinMapping joinMapping = new JoinMapping();
//			joins[j] = joinMapping;
//
//			for(int i=0;i<attributes.length;i++){
//				String field = attributes[i];
//				String[] keyVal = field.split("=");
//
//				FIELDS f = FIELDS.valueOf(keyVal[0]);
//				String val = keyVal[1];
//				switch( f ){
//				case LTableName:
//					joinMapping.lTableName = val;
//					break;
//				case LColumnName:
//					joinMapping.lColumnName = val;
//					break;
//				case RTableName:
//					joinMapping.rTableName = val;
//					break;
//				case RColumnName:
//					joinMapping.lColumnName = val;
//					break;
//				default:
//
//				}
//
//			}
//		}
//
//		return joins;
//	}

}

package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import com.cnk.travelerp.common.persistence.sql.Statement;

public class JoinSelectByKeySQLGenerator extends AbstractSQLGenerator {

    private static SQLGenerator generator = new JoinSelectByKeySQLGenerator();

    public static SQLGenerator getSQLGenerator() {
        return generator;
    }

    private JoinSelectByKeySQLGenerator() {
        statmentType = Statement.StatementType.Join_Select_By_Key;
    }

    @Override
    public void generateStatement(DomainMapping domainMapping) {
        Statement joinSelStmt = domainMapping
                .getStatement(Statement.StatementType.Join_Select);
        if (joinSelStmt == null) {
            JoinSelectSQLGenerator.getSQLGenerator().generateStatement(
                    domainMapping);
            joinSelStmt = domainMapping
                    .getStatement(Statement.StatementType.Join_Select);
            if (joinSelStmt == null) {
                return; // still if join statement is not getting generated.
            }
        }
        boolean moreThanOneTable = domainMapping.tableMapping.size() > 1;
        List<String> keys = new ArrayList<>();
        List<String> pkeys = new ArrayList<>();
        for (Entry<TableMapping, List<ColumnMapping>> entry : domainMapping.tableMapping
                .entrySet()) {
            for (ColumnMapping column : entry.getValue()) {
                if (column.lookup) { // lookup column
                    if (moreThanOneTable) {
                        keys.add(entry.getKey().aliasName + "."
                                + column.columnName);
                    }
                    else {
                        keys.add(column.columnName);
                    }
                    pkeys.add(column.aliasName);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        sb.append(joinSelStmt.sqlStatement);
        System.out.println(sb);
        Statement statement = new Statement(
                Statement.StatementType.Join_Select_By_Key);
        appendCondition(sb, keys, pkeys, statement);
        System.out.println(statement.sqlStatement);
        domainMapping.statements.add(statement);
    }

    @Override
    protected void generate(List<ColumnMapping> columnMappings,
            Statement statement) {

    }

}
/**
 * 
 */
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import com.cnk.travelerp.common.persistence.sql.Statement;

/**
 * @author sivaiah.polamreddy
 * 
 */
public class JoinSelectQueryByParentKey extends AbstractSQLGenerator {

    private static SQLGenerator generator = new JoinSelectQueryByParentKey();

    public static SQLGenerator getSQLGenerator() {
        return generator;
    }

    private JoinSelectQueryByParentKey() {
        statmentType = Statement.StatementType.Join_Select_By_Parent_Key;
    }

    @Override
    public void generateStatement(DomainMapping domainMapping) {
        Statement joinSelStmt = domainMapping
                .getStatement(Statement.StatementType.Join_Select);
        if (joinSelStmt == null) {
            JoinSelectSQLGenerator.getSQLGenerator().generateStatement(
                    domainMapping);
            joinSelStmt = domainMapping
                    .getStatement(Statement.StatementType.Join_Select);
            if (joinSelStmt == null) {
                return; // still if join statement is not getting generated.
            }
        }
        boolean moreThanOneTable = domainMapping.tableMapping.size() > 1;
        List<String> keys = new ArrayList<>();
        List<String> pkeys = new ArrayList<>();
        for (Entry<TableMapping, List<ColumnMapping>> entry : domainMapping.tableMapping
                .entrySet()) {
            for (ColumnMapping column : entry.getValue()) {
                if (!column.lookup) { // lookup column
                    if (moreThanOneTable) {

                        keys.add(entry.getKey().aliasName + "."
                                + column.columnName);
                    }
                    else {
                        keys.add(column.columnName);
                    }
                    pkeys.add(column.aliasName);
                }
            }
            break;

        }
        StringBuilder sb = new StringBuilder();
        sb.append(joinSelStmt.sqlStatement);

        Statement statement = new Statement(
                Statement.StatementType.Join_Select_By_Parent_Key);
        appendCondition(sb, keys, pkeys, statement);
        System.out.println(statement.sqlStatement);
        domainMapping.statements.add(statement);
    }

    @Override
    protected void generate(List<ColumnMapping> columnMappings,
            Statement statement) {

    }

}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.model.RefJoinMapping;
import com.cnk.travelerp.common.persistence.model.ReferenceDBMappingModel;

public class JoinSelectSQLGenerator extends AbstractSQLGenerator{
	
	private static SQLGenerator generator = new JoinSelectSQLGenerator();
	
	public static SQLGenerator getSQLGenerator(){
		return generator;
	}

	
	private JoinSelectSQLGenerator(){
		statmentType =  Statement.StatementType.Join_Select;
	}

	
	@Override
	public void generateStatement(DomainMapping domainMapping) {
		Map<TableMapping,List<ColumnMapping>> tableAndColumns = domainMapping.tableMapping;
		StringBuilder sb = new StringBuilder();
		sb.append(SELECT_LITTERAL);
		
		int i=0;
		List<String> tabS = new ArrayList<>();
		boolean joins = tableAndColumns.size()>1;//when more than one table is present

		String sComma = "";
		TableMapping mainTableMapping = null;
		for(Entry<TableMapping, List<ColumnMapping>> entry:tableAndColumns.entrySet()){
			TableMapping table = entry.getKey();
			if (table.mainTable){
				mainTableMapping = table;
			}
			String a="";
			String tabAlias="";
			if (joins){
				a = table.tableName + " " + table.aliasName;
				tabAlias = table.aliasName+".";
			}
			else {
				a = table.tableName;
			}
			
			tabS.add(a);
			for(ColumnMapping column:entry.getValue()){
//				String s="";
				if (i>0){
					sComma=",";
				}
//				s = tabAlias+"."+column.columnName+" "+column.aliasName;
//				if (!joins){
//					s = column.columnName;
//				}
//				else {
//					s = column.columnName+" "+column.aliasName;
//				}
				sb.append(sComma).append(tabAlias)
					.append(column.columnName).append(" ").append(column.aliasName);
				i++;
			}
		}
		
		if (domainMapping.em != null){
			List<ReferenceDBMappingModel> refs = domainMapping.em.getReferences();
			String sAlias = "";
			for(ReferenceDBMappingModel r:refs){
				sAlias = "";
				if (r.getTargetAliasName() != null && !r.getTargetAliasName().isEmpty()){
					sAlias = r.getTargetAliasName()+".";
				}
				sb.append(sComma).append(sAlias)
					.append(r.getTargetDispAttribute()).append(" ").append(r.getDisplayName());
			}
		}
		
		sb.append(FROM_LITTERAL);
		i=0;
		
		
		if (mainTableMapping == null && tableAndColumns.size() == 1 ){
			mainTableMapping = tableAndColumns.keySet().iterator().next();
		}
		
		if (joins){
			sb.append(mainTableMapping.tableName).append(SPACE_CHAR).append(mainTableMapping.aliasName).append(SPACE_CHAR);

			Map<TableMapping,List<JoinMapping>> temp = new LinkedHashMap<>();
			for(JoinMapping joinMapping:domainMapping.joinMapping){
				TableMapping ltable = getTableMapping(tableAndColumns.keySet(), joinMapping.lTableName);
				TableMapping rtable = getTableMapping(tableAndColumns.keySet(), joinMapping.rTableName);
				
				TableMapping joinTable = null;
				if (ltable == mainTableMapping){
					joinTable = rtable;
				}
				else if (rtable == mainTableMapping){
					joinTable = ltable;
				}
				else{
					continue; //in join, main table join  is required.
				}
				if (temp.get(joinTable) == null){
					temp.put(joinTable, new ArrayList<JoinMapping>(3));
				}
				temp.get(joinTable).add(joinMapping);
			}
			for(TableMapping tMap:temp.keySet()){
				List<JoinMapping> joinColumns = temp.get(tMap);
				sb.append(" INNER JOIN ").append(tMap.tableName).append(SPACE_CHAR).append( tMap.aliasName);
				sb.append(SPACE_CHAR).append("ON").append(SPACE_CHAR);
				
				TableMapping lTable = null;
				String lColumnName = "";
				TableMapping rTable = null;
				String rColumnName = "";
				i=0;
				sb.append(LEFT_BRACKET_LITERAL);
				for(JoinMapping jMap:joinColumns){
					lTable = tMap;
					rTable = mainTableMapping;
					if (jMap.lTableName.equals(mainTableMapping.tableName)){
						lColumnName = jMap.rColumnName;
						rColumnName = jMap.lColumnName;
					}
					else if (jMap.rTableName.equals(mainTableMapping.tableName)){
						lColumnName = jMap.lColumnName;
						rColumnName = jMap.rColumnName;
						
					}
					if (i>0){
						sb.append(AND_LITTERAL);
					}
					sb.append(lTable.aliasName).append(".").append(lColumnName).append(EQUAL_LITTERAL)
						.append(rTable.aliasName).append(".").append(rColumnName).append(SPACE_CHAR);
					i++;

				}
				sb.append(RIGHT_BRACKET_LITTERAL);
			}

		
			if (domainMapping.em != null){
				List<ReferenceDBMappingModel> refs = domainMapping.em.getReferences();
				for(ReferenceDBMappingModel r:refs){
					sb.append(" INNER JOIN ").append(r.getTargetObject()).append(SPACE_CHAR).append( r.getTargetAliasName() );
					sb.append(SPACE_CHAR).append("ON").append(SPACE_CHAR);
					i=0;
					sb.append(LEFT_BRACKET_LITERAL);
					for(RefJoinMapping  refMap: r.getJoincolumns()){
						TableMapping rtable = getTableMapping(tableAndColumns.keySet(), refMap.getRefTableName());	
						
						
						if (i>0){
							sb.append(AND_LITTERAL);
						}

						sb.append(  r.getTargetAliasName()).append(".").append(refMap.getColumnName())
							.append(EQUAL_LITTERAL).append(rtable.aliasName).append(".").append(refMap.getRefColumnName());
						i++;
					}
					sb.append(RIGHT_BRACKET_LITTERAL);

				}
			}

		
		}
		else {
			sb.append(mainTableMapping.tableName);

		}
		
		
//		for(String s:tabS){
//			if (i>0){
//				sb.append(",");
//			}
//			sb.append(s);
//			i++;
//		}
		
//		if (domainMapping.joinMapping != null && domainMapping.joinMapping.size()>0){
//			List<String> joinS = new ArrayList<>();
//			StringBuilder predicate = new StringBuilder();
//			for(JoinMapping joinMapping:domainMapping.joinMapping){
//				TableMapping ltable = getTableMapping(tableAndColumns.keySet(), joinMapping.lTableName);
//				TableMapping rtable = getTableMapping(tableAndColumns.keySet(), joinMapping.lTableName);
//				predicate.append(ltable.aliasName).append(".").append(joinMapping.lColumnName)
//				.append(" = ")
//				.append(rtable.aliasName).append(".").append(joinMapping.rColumnName);
//				joinS.add(predicate.toString());
//				predicate.setLength(0);
//			}
//			i=0;
//			if (joinS.size()>0){
//				sb.append(WHERE_LITTERAL);
//				for(String s:joinS){
//					if(i>0){
//						sb.append(AND_LITTERAL);
//					}
//					sb.append(s);
//					i++;
//				}
//			}
//		}
		Statement statement = new Statement(Statement.StatementType.Join_Select);
		statement.sqlStatement = sb.toString();
		domainMapping.statements.add(statement);
	}


	@Override
	protected void generate(List<ColumnMapping> columnMappings, Statement statement) {
		
	}
	
	
	

}
package com.cnk.travelerp.common.persistence.annotation.processor;

public class JoinTableMapping {
    String tableName;
    JoinColumnMapping[] joinColumns;
	
    
    /**
	 * @param tableName
	 * @param joinColumns
	 */
	public JoinTableMapping(String tableName, JoinColumnMapping[] joinColumns) {
		super();
		this.tableName = tableName;
		this.joinColumns = joinColumns;
	}
    
    
    
}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.List;

import com.cnk.travelerp.common.persistence.sql.Statement;

public class KeySeqSQLGenerator extends AbstractSQLGenerator{
	
	private static SQLGenerator generator = new KeySeqSQLGenerator();
	
	public static SQLGenerator getSQLGenerator(){
		return generator;
	}

	
	private KeySeqSQLGenerator(){
		statmentType =  Statement.StatementType.Key_Seq;
	}

	
	@Override
	public void generateStatement(DomainMapping domainMapping) {
//		TableMapping mainTable = domainMapping.getMainTable();
//		if (mainTable.seqName == null || mainTable.seqName.isEmpty()){
//			return;
//		}
//		
//
//		StringBuilder sb = new StringBuilder();
//		sb.append(SELECT_LITTERAL);
//		sb.append(mainTable.seqName).append(".nextval from dual");		
//		Statement statement = new Statement(statmentType);
//		statement.sqlStatement = sb.toString();
//		domainMapping.statements.add(statement);
	}


	@Override
	protected void generate(List<ColumnMapping> columnMappings, Statement statement) {
		
	}
	
}
package com.cnk.travelerp.common.persistence.annotation.processor;

public class Reference {

	enum RelationshipType{OneToOne,OneToMany,ManyToOne,ManyToMany};
	
	enum Direction{UP,DOWN};
	
	
	String fieldName;
	String mappedBy;
	
	@SuppressWarnings("rawtypes")
	Class targetClass ;
	RelationshipType relationshipType;
	Direction direction;
	
	@SuppressWarnings("rawtypes")
	Class containerClass ;
	
	/**
	 * 
	 * Join Column shall be used for joining the filed name
	 */
	JoinColumnMapping[] joinColumns;


	/**
	 * in case of Many to Many, when there is a third table e.g. Product and Order association, 
	 * this join table will hold the table name definition.
	 */
	JoinTableMapping joinTable;

	/**
	 * 
	 * @param fieldName
	 * @param mappedBy
	 * @param targetClass
	 * @param relationshipType
	 * @param direction
	 */
	public Reference(String fieldName, String mappedBy, @SuppressWarnings("rawtypes") Class targetClass,
			RelationshipType relationshipType, Direction direction) {
		super();
		this.fieldName = fieldName;
		this.mappedBy = mappedBy;
		this.targetClass = targetClass;
		this.relationshipType = relationshipType;
		this.direction = direction;
	}

	/**
	 * @param fieldName
	 * @param joinColumns
	 * @param relationshipType
	 * @param direction
	 */
	public Reference(String fieldName, JoinColumnMapping[] joinColumns,RelationshipType relationshipType,
			Direction direction) {
		super();
		this.fieldName = fieldName;
		this.relationshipType = relationshipType;
		this.direction = direction;
		this.joinColumns = joinColumns;
	}

	/**
	 * @param fieldName
	 * @param relationshipType
	 * @param direction
	 * @param joinTable
	 */
	public Reference(String fieldName, JoinTableMapping joinTable, RelationshipType relationshipType,
			Direction direction) {
		super();
		this.fieldName = fieldName;
		this.relationshipType = relationshipType;
		this.direction = direction;
		this.joinTable = joinTable;
	}

	/**
	 * @return the fieldName
	 */
	public String getFieldName() {
		return fieldName;
	}

	/**
	 * @return the mappedBy
	 */
	public String getMappedBy() {
		return mappedBy;
	}

	/**
	 * @return the targetClass
	 */
	@SuppressWarnings("rawtypes")
	public Class getTargetClass() {
		return targetClass;
	}

	/**
	 * @return the relationshipType
	 */
	public RelationshipType getRelationshipType() {
		return relationshipType;
	}

	/**
	 * @return the direction
	 */
	public Direction getDirection() {
		return direction;
	}

	/**
	 * @return the joinColumns
	 */
	public JoinColumnMapping[] getJoinColumns() {
		return joinColumns;
	}

	/**
	 * @return the joinTable
	 */
	public JoinTableMapping getJoinTable() {
		return joinTable;
	}
	

	
	
	
	
}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.List;

import com.cnk.travelerp.common.persistence.sql.Statement;

public class SelectSQLGenerator extends AbstractSQLGenerator{
	
	private static SQLGenerator generator = new SelectSQLGenerator();
	
	public static SQLGenerator getSQLGenerator(){
		return generator;
	}
	
	private SelectSQLGenerator(){
		statmentType =  Statement.StatementType.Select;
	}


	@Override
	protected void generate(List<ColumnMapping> columnMappings, Statement statement) {
		StringBuilder sb = new StringBuilder();
		sb.append(SELECT_LITTERAL);
		//.append(statement.targetName).append(SPACE_CHAR);
		int index=0;
		List<String> keys = new ArrayList<>(5);
		List<String> pkeys = new ArrayList<>(5);
		for(ColumnMapping column:columnMappings){
			sb.append(column.columnName+" "+column.aliasName).append(COMMA_CHAR);
//			sb.append(column.columnName).append(COMMA_CHAR);
			if (column.primaryKey){
				keys.add(column.columnName);
				pkeys.add(column.aliasName);
			}
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append(FROM_LITTERAL).append(statement.targetName);
		appendCondition(sb,keys,pkeys,statement);
	}
	
	
	

}
package com.cnk.travelerp.common.persistence.annotation.processor;



public interface SQLGenerator {
	public void generateStatement(DomainMapping domainMapping);
}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;



public class SQLGeneratorC {

	enum SQLStatements{FIELD_MAPPING,INSERT,UPDATE,DELETE,SELECT,SELECT_WITH_KEY}
	
	/**
	 * this will generate the SQL statements based on table and their column mappings.
	 * 
	 * @param tableAndColums
	 * @return
	 */
	public static Map<String,Map<String,String>> generate(DomainMapping domainMapping){
		Map<TableMapping,List<ColumnMapping>> tableAndColums = domainMapping.tableMapping;
		Map<String,Map<String,String>> retMap = new HashMap<String,Map<String,String>>();
		
		for(TableMapping tabMapping:tableAndColums.keySet()){
			String tableName = tabMapping.tableName;
			List<ColumnMapping> columnMappings = tableAndColums.get(tabMapping);
			if (columnMappings == null || columnMappings.size() == 0){
				continue;
			}
			
			Map<String,String> statements = new HashMap<>();
			retMap.put(tableName, statements);

			String insertStmt = generateInsert(tableName,columnMappings);
			String updateStmt = generateUpdate(tableName,columnMappings);
			String deleteStmt = generateDelete(tableName,columnMappings);
			String selectStmt = generateSelect(tableName,columnMappings);
			String selectAllStmt = generateSelectAll(tableName,columnMappings);

			String fieldmapping = generateMapping(  columnMappings);
			statements.put(SQLStatements.FIELD_MAPPING.name(),fieldmapping);
			statements.put(SQLStatements.INSERT.name(),insertStmt);
			statements.put(SQLStatements.INSERT.name(),insertStmt);
			statements.put(SQLStatements.UPDATE.name(),updateStmt);
			statements.put(SQLStatements.DELETE.name(),deleteStmt);
			statements.put(SQLStatements.SELECT.name(),selectAllStmt);
			statements.put(SQLStatements.SELECT_WITH_KEY.name(),selectStmt);
		}
			
		return retMap;
	}

	
	private static final String INSERT_LITTERAL = "Insert ";
	private static final String UPDATE_LITTERAL = "Update ";
	private static final String SELECT_LITTERAL = "Select ";
	private static final String DELETE_LITTERAL = "Delete ";
	private static final String FROM_LITTERAL = " From ";
	private static final String WHERE_LITTERAL = " Where ";
	private static final String VALUES_LITTERAL = " Values ";
	private static final String EQUAL_LITTERAL = " = ";
	private static final String PLACE_HOLDER_LITTERAL = "? ";
	private static final String COMMA_CHAR = ", ";
	private static final String LEFT_BRACKET_LITERAL = "(";
	private static final String RIGHT_BRACKET_LITTERAL = ")";
	private static final String SPACE_CHAR = " ";

//	private static final String MAPPING_LITTERAL = "mapping";
//	private static final String PRIVATE_LITTERAL = "private";
	
	private static String generateMapping( List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
//		sb.append("TABLE_NAME").append("=").append(tableName);
		int i=0;
		for(ColumnMapping column:columnMappings){
			if (i>0){
				sb.append(",");
			}
			sb.append(column.fieldName).append("=").append(column.columnName);
			i++;
		}
		
		return sb.toString();
	}
	
	private static String generateInsert(String tableName, List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
		sb.append(INSERT_LITTERAL).append(tableName).append(SPACE_CHAR);
		int index=0;
		sb.append( LEFT_BRACKET_LITERAL);
		Set<ColumnMapping> columns = filteredColumns(columnMappings);
		for(ColumnMapping column:columns){
			sb.append(column.columnName).append(COMMA_CHAR);
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append( RIGHT_BRACKET_LITTERAL).append(VALUES_LITTERAL).append(LEFT_BRACKET_LITERAL);
		
		for(index =0; index <columns.size();index++){
			sb.append("?").append(COMMA_CHAR);
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append( RIGHT_BRACKET_LITTERAL);
		return sb.toString();
	}
	
	private static Set<ColumnMapping> filteredColumns(List<ColumnMapping> columnMappings){
		Set<ColumnMapping> retSet = new LinkedHashSet<>();
		for(ColumnMapping column:columnMappings){
			if (!column.autoGenerated){
				retSet.add(column);
			}
		}
		return retSet;
	}
	
	private static String generateUpdate(String tableName, List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
		sb.append(UPDATE_LITTERAL).append(tableName).append(SPACE_CHAR);
		int index=0;
		Set<String> keys = new LinkedHashSet<>(5);
		Set<String> procColumns = new LinkedHashSet<>();
		for(ColumnMapping column:columnMappings){
			if (procColumns.contains(column.columnName) ){
				continue;
			}
			if (column.primaryKey){
				keys.add( column.columnName);
			}
			else {
				sb.append(column.columnName).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL).append(COMMA_CHAR);
			}
			procColumns.add(column.columnName);
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
			index =0;
		}
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}
		return sb.toString();
	}
	
	/**
	 * Generte Select statement with key predicate as defined in the domain classes 
	 * @param tableName
	 * @param columnMapping
	 * @return
	 */
	private static String generateSelect(String tableName, List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
		List<String>  columns = new ArrayList<>(columnMappings.size());
		List<String>  keys = new ArrayList<>(columnMappings.size());
		for(ColumnMapping colMap:columnMappings){
			columns.add(colMap.columnName);
			if (colMap.primaryKey){
				keys.add(colMap.columnName);
			}
		}
		int index =0;
		sb.append(SELECT_LITTERAL);
		for(String col:columns){
			sb.append(col).append(COMMA_CHAR);
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append(FROM_LITTERAL).append(tableName).append(SPACE_CHAR);
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}

		return sb.toString();
	}
	
	/**
	 * Generte Select statement with key predicate as defined in the domain classes 
	 * @param tableName
	 * @param columnMapping
	 * @return
	 */
	private static String generateSelectAll(String tableName, List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
		List<String>  columns = new ArrayList<>(columnMappings.size());
		List<String>  keys = new ArrayList<>(columnMappings.size());
		for(ColumnMapping colMap:columnMappings){
			columns.add(colMap.columnName);
			if (colMap.primaryKey){
				keys.add(colMap.columnName);
			}
		}
		int index =0;
		sb.append(SELECT_LITTERAL);
		for(String col:columns){
			sb.append(col).append(COMMA_CHAR);
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append(FROM_LITTERAL).append(tableName).append(SPACE_CHAR);

		return sb.toString();
	}
	
	
	/**
	 * Generate Delete statement as per key defined in the Domain object
	 * @param tableName
	 * @param columnDetail
	 * @return
	 */
	private static String generateDelete(String tableName, List<ColumnMapping> columnMappings){
		StringBuilder sb = new StringBuilder();
		sb.append(DELETE_LITTERAL).append(tableName).append(SPACE_CHAR);;
		List<String> keys = new ArrayList<>(5);
		for(ColumnMapping column:columnMappings){
			if (column.primaryKey){
				keys.add( column.columnName);
			}
		}
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}
		
		return sb.toString();
	}
	
	
	
}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.sql.CompositeStatement;
import com.cnk.travelerp.common.persistence.sql.Statement;

public class SQLStatementGenerator {

    enum SQLStatements {
        FIELD_MAPPING, INSERT, UPDATE, DELETE, SELECT, SELECT_WITH_KEY
    }

    /**
     * this will generate the SQL statements based on table and their column
     * mappings.
     * 
     * @param tableAndColums
     * @return
     */
    public static void generateStatment(DomainMapping domainMapping) {
        Map<TableMapping, List<ColumnMapping>> tableAndColumns = domainMapping.tableMapping;
        if (tableAndColumns.size() == 0) {
            return;
        }

        InsertSQLGenerator.getSQLGenerator().generateStatement(domainMapping);
        UpdateSQLGenerator.getSQLGenerator().generateStatement(domainMapping);
        DeleteSQLGenerator.getSQLGenerator().generateStatement(domainMapping);
        SelectSQLGenerator.getSQLGenerator().generateStatement(domainMapping);
        JoinSelectByKeySQLGenerator.getSQLGenerator().generateStatement(
                domainMapping);
        KeySeqSQLGenerator.getSQLGenerator().generateStatement(domainMapping);

        JoinSelectQueryByParentKey.getSQLGenerator().generateStatement(
                domainMapping);

        // for select query for based on parent id and
        // locale id

    }

    /**
     * this will generate the SQL statements based on table and their column
     * mappings.
     * 
     * @param tableAndColums
     * @return
     */
    public static List<Statement> generate(DomainMapping domainMapping) {
        Map<TableMapping, List<ColumnMapping>> tableAndColumns = domainMapping.tableMapping;
        List<Statement> retStatements = new ArrayList<>();
        if (tableAndColumns.size() == 0) {
            return retStatements;
        }
        Statement insertStmt = generateInsertStatement(tableAndColumns);
        Statement updateStmt = generateUpdateStatement(tableAndColumns);
        Statement deleteStmt = generateDeleteStatement(tableAndColumns);
        Statement selectStmt = generateSelectStatement(tableAndColumns);
        // Statement selectAllStmt = generateDeleteStatement(tableAndColumns);
        addIfNotNul(retStatements, insertStmt);
        addIfNotNul(retStatements, updateStmt);
        addIfNotNul(retStatements, deleteStmt);
        addIfNotNul(retStatements, selectStmt);
        domainMapping.statements = retStatements;

        generateJoinSelectStatementByKey(domainMapping);

        return retStatements;

    }

    private static <T> void addIfNotNul(List<T> list, T t) {
        if (t != null) {
            list.add(t);
        }

    }

    private static final String INSERT_LITTERAL = "Insert ";
    private static final String UPDATE_LITTERAL = "Update ";
    private static final String SELECT_LITTERAL = "Select ";
    private static final String DELETE_LITTERAL = "Delete ";
    private static final String FROM_LITTERAL = " From ";
    private static final String WHERE_LITTERAL = " Where ";
    private static final String VALUES_LITTERAL = " Values ";
    private static final String EQUAL_LITTERAL = " = ";
    private static final String PLACE_HOLDER_LITTERAL = "? ";
    private static final String COMMA_CHAR = ", ";
    private static final String LEFT_BRACKET_LITERAL = "(";
    private static final String RIGHT_BRACKET_LITTERAL = ")";
    private static final String SPACE_CHAR = " ";
    private static final String AND_LITTERAL = " AND ";

    // private static final String MAPPING_LITTERAL = "mapping";
    // private static final String PRIVATE_LITTERAL = "private";

    /**
     * this function generate Insert statements
     * 
     * @param tableAndColumns
     * @return
     */

    private static Statement generateInsertStatement(
            Map<TableMapping, List<ColumnMapping>> tableAndColumns) {

        TableMapping mainTabMapping = null;
        Statement statement = null;

        if (tableAndColumns.size() == 1) { // when only one table is mapped.
            mainTabMapping = tableAndColumns.keySet().iterator().next();
            statement = new Statement(Statement.StatementType.Insert);
            statement.isAutoKey = mainTabMapping.autoKey;
            String tableName = mainTabMapping.tableName;
            List<ColumnMapping> columnMappings = tableAndColumns
                    .get(mainTabMapping);
            if (columnMappings == null || columnMappings.size() == 0) {
                return null; // it should throw an exception
            }
            generateInsert(tableName, columnMappings, statement);
            return statement;
        }

        // from here it is for defining more than one table
        for (TableMapping tabMapping : tableAndColumns.keySet()) {
            if (tabMapping.mainTable) {
                mainTabMapping = tabMapping;
                break;
            }
        }
        if (mainTabMapping == null) {
            return null;// need to throw an exception or return a blank
                        // statement
        }
        CompositeStatement mainstatement = new CompositeStatement(
                Statement.StatementType.Insert);
        mainstatement.isAutoKey = mainTabMapping.autoKey;
        // mainstatement.statementType = Statement.StatementType.Insert;
        String tableName = mainTabMapping.tableName;
        List<ColumnMapping> columnMappings = tableAndColumns
                .get(mainTabMapping);
        generateInsert(tableName, columnMappings, mainstatement);
        statement = mainstatement;
        for (TableMapping tabMap : tableAndColumns.keySet()) {
            if (tabMap == mainTabMapping) { // making sure not processing for
                                            // main table.
                continue;
            }
            Statement statementSub = new Statement(
                    Statement.StatementType.Insert);
            // statement.isAutoKey = tabMap.autoKey;
            statementSub.isAutoKey = false; // autokey should only for main
                                            // table.
            statementSub.targetName = tabMap.tableName;
            columnMappings = tableAndColumns.get(tabMap);
            if (columnMappings == null || columnMappings.size() == 0) {
                continue;
            }
            generateInsert(tableName, columnMappings, statementSub);
            mainstatement.subStatements.add(statementSub);
        }

        return statement;
    }

    private static void generateInsert(String tableName,
            List<ColumnMapping> columnMappings, Statement statement) {
        StringBuilder sb = new StringBuilder();
        sb.append(INSERT_LITTERAL).append(tableName).append(SPACE_CHAR);
        int index = 0;
        sb.append(LEFT_BRACKET_LITERAL);
        Set<ColumnMapping> columns = filteredColumns(columnMappings);
        List<String> colList = new ArrayList<>(columns.size());
        for (ColumnMapping column : columns) {
            sb.append(column.columnName).append(COMMA_CHAR);
            colList.add(column.aliasName);
            index++;
        }
        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
        }
        sb.append(RIGHT_BRACKET_LITTERAL).append(VALUES_LITTERAL)
                .append(LEFT_BRACKET_LITERAL);

        for (index = 0; index < columns.size(); index++) {
            sb.append("?").append(COMMA_CHAR);
        }
        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
        }
        sb.append(RIGHT_BRACKET_LITTERAL);

        statement.sqlStatement = sb.toString();
        statement.placeHolderAttributes = colList.toArray(new String[colList
                .size()]);
    }

    static Set<ColumnMapping>
            filteredColumns(List<ColumnMapping> columnMappings) {
        Set<ColumnMapping> retSet = new LinkedHashSet<>();
        List<String> columnNames = new ArrayList<>(columnMappings.size());
        for (ColumnMapping column : columnMappings) {

            if (column.generatedType != GeneratedType.Identity
                    && !columnNames.contains(column.columnName)) {
                retSet.add(column);
                columnNames.add(column.columnName);
            }
        }
        return retSet;
    }

    private static Statement generateUpdateStatement(
            Map<TableMapping, List<ColumnMapping>> tableAndColumns) {

        TableMapping mainTabMapping = null;

        if (tableAndColumns.size() == 1) { // when only one table is mapped.
            mainTabMapping = tableAndColumns.keySet().iterator().next();
            Statement statement = new Statement(Statement.StatementType.Update);
            statement.isAutoKey = mainTabMapping.autoKey;
            String tableName = mainTabMapping.tableName;
            List<ColumnMapping> columnMappings = tableAndColumns
                    .get(mainTabMapping);
            if (columnMappings == null || columnMappings.size() == 0) {
                return null; // it should throw an exception
            }
            generateUpdate(tableName, columnMappings, statement);
            return statement;
        }

        // from here it is for defining more than one table
        for (TableMapping tabMapping : tableAndColumns.keySet()) {
            if (tabMapping.mainTable) {
                mainTabMapping = tabMapping;
                break;
            }
        }
        if (mainTabMapping == null) {
            return null;// need to throw an exception or return a blank
                        // statement
        }
        CompositeStatement statement = new CompositeStatement(
                Statement.StatementType.Update);
        statement.isAutoKey = mainTabMapping.autoKey;
        // statement.statementType = Statement.StatementType.Update;
        String tableName = mainTabMapping.tableName;
        List<ColumnMapping> columnMappings = tableAndColumns
                .get(mainTabMapping);
        generateUpdate(tableName, columnMappings, statement);

        for (TableMapping tabMap : tableAndColumns.keySet()) {
            if (tabMap == mainTabMapping) { // making sure not processing for
                                            // main table.
                continue;
            }
            Statement statementSub = new Statement(
                    Statement.StatementType.Update);
            // statement.isAutoKey = tabMap.autoKey;
            statementSub.isAutoKey = false; // autokey should only for main
                                            // table.
            statementSub.targetName = tabMap.tableName;
            columnMappings = tableAndColumns.get(tabMap);
            if (columnMappings == null || columnMappings.size() == 0) {
                continue;
            }
            generateUpdate(tableName, columnMappings, statementSub);
            statement.subStatements.add(statementSub);
        }

        return statement;
    }

    private static void generateUpdate(String tableName,
            List<ColumnMapping> columnMappings, Statement statement) {
        StringBuilder sb = new StringBuilder();
        sb.append(UPDATE_LITTERAL).append(tableName).append(SPACE_CHAR);
        int index = 0;
        Set<String> keys = new LinkedHashSet<>(5);
        Set<String> procColumns = new LinkedHashSet<>();
        for (ColumnMapping column : columnMappings) {
            if (procColumns.contains(column.aliasName)) {
                continue;
            }
            if (column.primaryKey) {
                keys.add(column.aliasName);
            }
            else {
                sb.append(column.columnName).append(EQUAL_LITTERAL)
                        .append(PLACE_HOLDER_LITTERAL).append(COMMA_CHAR);
            }
            procColumns.add(column.aliasName);
            index++;
        }
        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
            index = 0;
        }
        if (keys.size() > 0) {
            sb.append(WHERE_LITTERAL);
        }
        for (String column : keys) {
            sb.append(column).append(EQUAL_LITTERAL)
                    .append(PLACE_HOLDER_LITTERAL);
            procColumns.add(column);
        }

        statement.sqlStatement = sb.toString();
        statement.placeHolderAttributes = procColumns
                .toArray(new String[procColumns.size()]);
    }

    private static void generateJoinSelectStatementByKey(
            DomainMapping domainMapping) {
        generateJoinSelectStatement(domainMapping);
        Statement joinSelStmt = domainMapping
                .getStatement(Statement.StatementType.Join_Select);
        if (joinSelStmt == null) {
            return;
        }
        List<String> keys = new ArrayList<>();
        List<String> pkeys = new ArrayList<>();
        for (Entry<TableMapping, List<ColumnMapping>> entry : domainMapping.tableMapping
                .entrySet()) {
            for (ColumnMapping column : entry.getValue()) {
                if (column.primaryKey) {
                    keys.add(column.columnName);
                    pkeys.add(column.aliasName);
                }
            }
        }
        StringBuilder sb = new StringBuilder();
        sb.append(joinSelStmt.sqlStatement);

        Statement statement = new Statement(
                Statement.StatementType.Join_Select_By_Key);
        appendCondition(sb, keys, pkeys, statement);

        domainMapping.statements.add(statement);

    }

    private static void
            generateJoinSelectStatement(DomainMapping domainMapping) {
        Map<TableMapping, List<ColumnMapping>> tableAndColumns = domainMapping.tableMapping;
        StringBuilder sb = new StringBuilder();
        sb.append(SELECT_LITTERAL);

        int i = 0;
        List<String> tabS = new ArrayList<>();
        boolean joins = tableAndColumns.size() > 1;// when more than one table
                                                   // is present

        for (Entry<TableMapping, List<ColumnMapping>> entry : tableAndColumns
                .entrySet()) {
            TableMapping table = entry.getKey();
            String a = "";
            if (joins) {
                a = table.tableName + " " + table.aliasName;
            }
            else {
                a = table.tableName;
            }

            tabS.add(a);
            for (ColumnMapping column : entry.getValue()) {
                String s = "";
                if (i > 0) {
                    sb.append(" ,");
                }
                if (!joins) {
                    s = column.columnName;
                }
                else {
                    s = column.columnName + " " + column.aliasName;
                }
                sb.append(s);
                i++;
            }
        }
        sb.append(FROM_LITTERAL);
        i = 0;
        for (String s : tabS) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append(s);
            i++;
        }
        if (domainMapping.joinMapping != null
                && domainMapping.joinMapping.size() > 0) {
            List<String> joinS = new ArrayList<>();
            StringBuilder predicate = new StringBuilder();
            for (JoinMapping joinMapping : domainMapping.joinMapping) {
                TableMapping ltable = getTableMapping(tableAndColumns.keySet(),
                        joinMapping.lTableName);
                TableMapping rtable = getTableMapping(tableAndColumns.keySet(),
                        joinMapping.lTableName);
                predicate.append(ltable.aliasName).append(".")
                        .append(joinMapping.lColumnName).append(" = ")
                        .append(rtable.aliasName).append(".")
                        .append(joinMapping.rColumnName);
                joinS.add(predicate.toString());
                predicate.setLength(0);
            }
            i = 0;
            if (joinS.size() > 0) {
                sb.append(WHERE_LITTERAL);
                for (String s : joinS) {
                    if (i > 0) {
                        sb.append(AND_LITTERAL);
                    }
                    sb.append(s);
                    i++;
                }
            }
        }
        Statement statement = new Statement(Statement.StatementType.Join_Select);
        statement.sqlStatement = sb.toString();
        domainMapping.statements.add(statement);
    }

    private static TableMapping getTableMapping(
            Collection<TableMapping> tables, String tableName) {
        for (TableMapping table : tables) {
            if (table.tableName.equals(tableName)) {
                return table;
            }
        }
        return null;
    }

    // private static <T> T getRecord(Collection<T> collections, String v){
    // for(T t:collections){
    //
    // if (table.tableName.equals(tableName)){
    // return table;
    // }
    // }
    // return null;
    // }

    private static Statement generateDeleteStatement(
            Map<TableMapping, List<ColumnMapping>> tableAndColumns) {

        TableMapping mainTabMapping = null;
        if (tableAndColumns.size() == 1) { // when only one table is mapped.
            mainTabMapping = tableAndColumns.keySet().iterator().next();
            Statement statement = new Statement(Statement.StatementType.Delete);
            statement.isAutoKey = mainTabMapping.autoKey;
            statement.targetName = mainTabMapping.tableName;
            List<ColumnMapping> columnMappings = tableAndColumns
                    .get(mainTabMapping);
            if (columnMappings == null || columnMappings.size() == 0) {
                return null; // it should throw an exception
            }
            generateDelete(columnMappings, statement);
            return statement;
        }

        // from here it is for defining more than one table
        for (TableMapping tabMapping : tableAndColumns.keySet()) {
            if (tabMapping.mainTable) {
                mainTabMapping = tabMapping;
                break;
            }
        }
        if (mainTabMapping == null) {
            return null;// need to throw an exception or return a blank
                        // statement
        }
        CompositeStatement statement = new CompositeStatement(
                Statement.StatementType.Delete);
        statement.isAutoKey = mainTabMapping.autoKey;
        statement.targetName = mainTabMapping.tableName;
        List<ColumnMapping> columnMappings = tableAndColumns
                .get(mainTabMapping);
        generateDelete(columnMappings, statement);

        for (TableMapping tabMap : tableAndColumns.keySet()) {
            if (tabMap == mainTabMapping) { // making sure not processing for
                                            // main table.
                continue;
            }
            Statement statementSub = new Statement(
                    Statement.StatementType.Delete);
            // statement.isAutoKey = tabMap.autoKey;
            statementSub.isAutoKey = false; // autokey should only for main
                                            // table.
            statementSub.targetName = tabMap.tableName;
            columnMappings = tableAndColumns.get(tabMap);
            if (columnMappings == null || columnMappings.size() == 0) {
                continue;
            }
            generateDelete(columnMappings, statementSub);
            statement.subStatements.add(statementSub);
        }

        return statement;
    }

    /**
     * Generate Delete statement as per key defined in the Domain object
     * 
     * @param tableName
     * @param columnDetail
     * @return
     */
    private static void generateDelete(List<ColumnMapping> columnMappings,
            Statement statement) {
        StringBuilder sb = new StringBuilder();
        sb.append(DELETE_LITTERAL).append(statement.targetName)
                .append(SPACE_CHAR);;
        List<String> keys = new ArrayList<>(5);
        List<String> pkeys = new ArrayList<>(5);
        for (ColumnMapping column : columnMappings) {
            if (column.primaryKey) {
                keys.add(column.columnName);
                pkeys.add(column.aliasName);

            }
        }

        appendCondition(sb, keys, pkeys, statement);
        // if (keys.size() >0 ){
        // sb.append(WHERE_LITTERAL);
        // }
        // for(String column:keys){
        // sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
        // }

        // statement.sqlStatement = sb.toString();
        // statement.placeHolderAttributes = keys.toArray( new
        // String[keys.size()]);

    }

    /**
     * this function generate Select statements
     * 
     * @param tableAndColumns
     * @return
     */

    private static Statement generateSelectStatement(
            Map<TableMapping, List<ColumnMapping>> tableAndColumns) {
        TableMapping mainTabMapping = null;
        Statement statement = null;

        if (tableAndColumns.size() == 1) { // when only one table is mapped.
            mainTabMapping = tableAndColumns.keySet().iterator().next();
            statement = new Statement(Statement.StatementType.Select);
            statement.isAutoKey = mainTabMapping.autoKey;
            statement.targetName = mainTabMapping.tableName;
            List<ColumnMapping> columnMappings = tableAndColumns
                    .get(mainTabMapping);
            if (columnMappings == null || columnMappings.size() == 0) {
                return null; // it should throw an exception
            }
            generateSelect(columnMappings, statement);
            return statement;
        }

        // from here it is for defining more than one table
        for (TableMapping tabMapping : tableAndColumns.keySet()) {
            if (tabMapping.mainTable) {
                mainTabMapping = tabMapping;
                break;
            }
        }
        if (mainTabMapping == null) {
            return null;// need to throw an exception or return a blank
                        // statement
        }
        CompositeStatement mainstatement = new CompositeStatement(
                Statement.StatementType.Select);
        mainstatement.isAutoKey = mainTabMapping.autoKey;
        mainstatement.targetName = mainTabMapping.tableName;
        List<ColumnMapping> columnMappings = tableAndColumns
                .get(mainTabMapping);
        generateSelect(columnMappings, mainstatement);
        statement = mainstatement;
        for (TableMapping tabMap : tableAndColumns.keySet()) {
            if (tabMap == mainTabMapping) { // making sure not processing for
                                            // main table.
                continue;
            }
            Statement statementSub = new Statement(
                    Statement.StatementType.Select);
            // statement.isAutoKey = tabMap.autoKey;
            statementSub.isAutoKey = false; // autokey should only for main
                                            // table.
            statement.targetName = mainTabMapping.tableName;
            columnMappings = tableAndColumns.get(tabMap);
            if (columnMappings == null || columnMappings.size() == 0) {
                continue;
            }
            generateSelect(columnMappings, statementSub);
            mainstatement.subStatements.add(statementSub);
        }

        return statement;
    }

    private static void generateSelect(List<ColumnMapping> columnMappings,
            Statement statement) {
        StringBuilder sb = new StringBuilder();
        sb.append(SELECT_LITTERAL);
        // .append(statement.targetName).append(SPACE_CHAR);
        int index = 0;
        List<String> keys = new ArrayList<>(5);
        List<String> pkeys = new ArrayList<>(5);
        for (ColumnMapping column : columnMappings) {
            sb.append(column.columnName).append(COMMA_CHAR);
            if (column.primaryKey) {
                keys.add(column.columnName);
                pkeys.add(column.aliasName);
            }
            index++;
        }
        if (index > 0) {
            sb.replace(sb.length() - COMMA_CHAR.length(), sb.length(), "");
        }
        sb.append(FROM_LITTERAL).append(statement.targetName);
        appendCondition(sb, keys, pkeys, statement);

    }

    private static void appendCondition(StringBuilder sb, List<String> keys,
            List<String> pkeys, Statement statement) {
        if (pkeys.size() != keys.size()) {
            return;
        }

        if (keys.size() > 0 && sb.indexOf(WHERE_LITTERAL) < 0) {
            sb.append(WHERE_LITTERAL);
        }
        for (String column : keys) {
            sb.append(column).append(EQUAL_LITTERAL)
                    .append(PLACE_HOLDER_LITTERAL);
        }
        statement.sqlStatement = sb.toString();
        statement.placeHolderAttributes = pkeys
                .toArray(new String[pkeys.size()]);

    }

    public static String seqGenerator(String seqName) {

        return SELECT_LITTERAL + seqName + ".nextval from dual";

    }

}

package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Table Mapping Annotation is used to provide table names of domain
 * class. 
 * An domain object can be mapped to more than one table. In this case respective domain
 * class will have following declaration at class level
 *  * @TableMapping(tableName="TABLE_ONE,mainTable=true,autoKey=true,keyColumns=ID")
 *  
 * @author vishwanath.dubey
 *
 */
public class TableMapping {
	enum FIELDS{tableName,mainTable,autoKey,keyColumns}
	


	String tableName;
	boolean mainTable = false;
	boolean autoKey = false;
	String[] keyColumns ;
	String aliasName;
	
	Map<String,String> defaultValues = new LinkedHashMap<>();
	

	public TableMapping(String tableName, boolean mainTable, boolean autoKey,
			String[] keyColumns, String aliasName) {
		super();
		this.tableName = tableName;
		this.mainTable = mainTable;
		this.autoKey = autoKey;
		this.keyColumns = keyColumns;
		this.aliasName = aliasName;
	}


	/**
	 * @return the defaultValues
	 */
	public Map<String, String> getDefaultValues() {
		return defaultValues;
	}


	/**
	 * @param defaultValues the defaultValues to set
	 */
	public void addDefaultValues(String columnName, String defaultValue) {
		defaultValues.put(columnName, defaultValue);
		
	}

	
	
	
//	public final static TableMapping[] process(String[] fields){
//		TableMapping[] tableMapping = new TableMapping[fields.length];
//		 for(int k=0;k<fields.length;k++){
//			 String[] attributes = fields[k].split(",");
//			 TableMapping tMapping = new TableMapping();
//			 tableMapping[k] = tMapping;
//			 
//			 for(int i=0;i<attributes.length;i++){
//				String field = attributes[i];
//				String[] keyVal = field.split("=");
//				if (keyVal.length<2){
//					continue;
//				}
//				String key = keyVal[0];
//				String val = keyVal[1];
//				
//				switch(FIELDS.valueOf(key)){
//					case tableName:
//						tMapping.tableName = val;
//						break;
//
//					case mainTable:
//						tMapping.mainTable = Boolean.parseBoolean(val);
//						break;
//					case autoKey:
//						tMapping.autoKey = Boolean.parseBoolean(val);
//						break;
//					case keyColumns:
//						tMapping.keyColumns = val.split(",");
//						break;
//					
//					default:
//				}
//				
//			 }
//		 }
//		 return tableMapping;
//	}

}
package com.cnk.travelerp.common.persistence.annotation.processor;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import com.cnk.travelerp.common.persistence.sql.Statement;

public class UpdateSQLGenerator extends AbstractSQLGenerator{
	
	private static SQLGenerator generator = new UpdateSQLGenerator();
	
	public static SQLGenerator getSQLGenerator(){
		return generator;
	}

	private UpdateSQLGenerator(){
		statmentType =  Statement.StatementType.Update;
	}
	
	@Override
	protected void generate(List<ColumnMapping> columnMappings, Statement statement) {
		StringBuilder sb = new StringBuilder();
		sb.append(UPDATE_LITTERAL).append(statement.targetName).append(SET_LITTERAL);
		int index=0;
		List<String> keys = new ArrayList<>(5);
		List<String> pkeys = new ArrayList<>(5);
		Set<String> procColumns = new LinkedHashSet<>();
		for(ColumnMapping column:columnMappings){
			if (procColumns.contains(column.aliasName) ){
				continue;
			}
			if (column.primaryKey){
				pkeys.add( column.columnName);
				keys.add( column.aliasName);
			}
			else {
				sb.append(column.columnName).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL).append(COMMA_CHAR);
				procColumns.add(column.aliasName);
			}
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
			index =0;
		}
		
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		
		for(int j=0;j<keys.size();j++){
			sb.append( pkeys.get(j) ).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
			procColumns.add( keys.get(j) );
		}
		
		
		
		statement.sqlStatement = sb.toString();
		statement.placeHolderAttributes = procColumns.toArray( new String[procColumns.size()] );

	}
	
	
	

}
package com.cnk.travelerp.common.persistence.dao;

import java.util.List;
import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.NewArgPreparedStatementSetter;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.KeyHolder;
import com.cnk.travelerp.common.persistence.springframework.GenericPreparedStatementCreator;

public class GenericDao implements IDao {

    protected DataSource dataSource;

    @Override
    public void setDataSource(DataSource ds) {
        dataSource = ds;
    }

    @Override
    public void
            create(String sqlStatement, Object[] params, KeyHolder keyholder) {

        NewArgPreparedStatementSetter pss = new NewArgPreparedStatementSetter(
                params);
        GenericPreparedStatementCreator psc = new GenericPreparedStatementCreator(
                pss, sqlStatement);

        JdbcTemplate template = new JdbcTemplate(dataSource);
        template.update(psc, keyholder);

    }

    @Override
    public void create(String sqlStatement, Object[] params) {
        JdbcTemplate template = new JdbcTemplate(dataSource);

        template.update(sqlStatement, params);

    }

    @Override
    public <T> List<T> select(String sqlStament, Object[] parameters,
            RowMapper<T> rowMapper) {
        JdbcTemplate select = new JdbcTemplate(dataSource);
        return select.query(sqlStament, parameters, rowMapper);

    }

    @Override
    public <T> List<T> selectAll(String sqlStament, RowMapper<T> rowMapper) {
        JdbcTemplate select = new JdbcTemplate(dataSource);
        return select.query(sqlStament, rowMapper);

    }

    @Override
    public <T> T queryForObject(String sqlStament, Class<T> clazz) {
        JdbcTemplate select = new JdbcTemplate(dataSource);
        return select.queryForObject(sqlStament, clazz);

    }

}
package com.cnk.travelerp.common.persistence.dao;

import java.util.List;

import javax.sql.DataSource;

import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.KeyHolder;


public interface IDao {

  void setDataSource(DataSource ds);

  void create(String sqlStament,Object[] parameters);
  
  void create(String sqlStatement,Object[] params, KeyHolder keyholder);
  
  <T> List<T> selectAll(String sqlStament, RowMapper<T> rowMapper);

  <T> List<T> select(String sqlStament,Object[] parameters, RowMapper<T> rowMapper);
  
  <T> T queryForObject(String sqlStament, Class<T> clazz);

//
//  List<T> selectAll();
//
//  void deleteAll();
//
//  void delete(S[] parameters);

} 


package com.cnk.travelerp.common.persistence.filter;

public class AndSQLFilter implements SQLFilter {
	
	SQLFilter filterLeft;
	SQLFilter filterRight;
	public AndSQLFilter(SQLFilter filterLeft, SQLFilter filterRight){
		this.filterLeft = filterLeft;
		this.filterRight = filterRight;
	}
	

	/* (non-Javadoc)
	 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#sqlCriteria()
	 */
	@Override
	public String sqlCriteria() {
		StringBuilder sb = new StringBuilder();
		sb.append(filterLeft.sqlCriteria())
			.append(" AND ")
			.append(filterRight.sqlCriteria());
		return sb.toString();
	}

	/* (non-Javadoc)
	 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#getValue()
	 */
	@Override
	public Object[] getValues() {
		Object[] leftobjs = filterLeft.getValues();
		Object[] rightobjs = filterLeft.getValues();
		Object[] objs = new Object[leftobjs.length+rightobjs.length];
		
		int i=0;
		for(;i<leftobjs.length;i++){
			objs[i] = leftobjs[i];
		}
		int j=i;i=0;
		for(;i<leftobjs.length;i++){
			objs[j+i] = rightobjs[i];
		}
		return objs;
	}

	
	
}

package com.cnk.travelerp.common.persistence.filter;

public class EqualSqlFilter implements SQLFilter{
	
	String key;
	Object val;
	/**
	 * 
	 * @param key
	 * @param value
	 */
	public EqualSqlFilter(String key, Object value){
		this.key = key;
		this.val = value;
	}
	/* (non-Javadoc)
	 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#sqlCriteria()
	 */
	@Override
	public String sqlCriteria() {
		StringBuilder sb = new StringBuilder();
		sb.append(key).append(" = ").append("?");
		return sb.toString();
	}
	/* (non-Javadoc)
	 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#getValue()
	 */
	@Override
	public Object[] getValues() {
		return new Object[]{val};
	}
	
	

}
package com.cnk.travelerp.common.persistence.filter;

public interface Filter {
	
	/**
	 * 
	 */
	String sqlCriteria();

}
package com.cnk.travelerp.common.persistence.filter;

public interface SQLFilter {

	
	/**
	 * 
	 */
	String sqlCriteria();
	
	Object[] getValues();
	
	
	BlankFilter BLANK_FILTER = new BlankFilter();
	
	class BlankFilter implements SQLFilter{

		/* (non-Javadoc)
		 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#sqlCriteria()
		 */
		@Override
		public String sqlCriteria() {
			return "";
		}

		/* (non-Javadoc)
		 * @see com.cnk.travelerp.common.persistence.filter.SQLFilter#getValues()
		 */
		@Override
		public Object[] getValues() {
			return new Object[0];
		}
		
	}
	
}
package com.cnk.travelerp.common.persistence.io;

import java.io.Externalizable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;

import com.cnk.travelerp.common.persistence.util.StringUtils;

/**
 * Borrowed gratuitously from Spring under ASL2.0.
 *
 *+
 */ 

public class ClassPathResource implements Resource,Externalizable  {
    private String      path;
    private ClassLoader classLoader;
    private Class<?>       clazz;
    private long        lastRead;
    
    public ClassPathResource() {
        
    }

    public ClassPathResource(String path) {
        this( path,
              null,
              null );
    }

    public ClassPathResource(String path,
                             Class<?> clazz) {
        this( path,
              clazz,
              null );
    }

    public ClassPathResource(String path,
                             ClassLoader classLoader) {
        this( path,
              null,
              classLoader );
    }

    public ClassPathResource(String path,
                             Class<?> clazz,
                             ClassLoader classLoader) {
        if ( path == null ) {
            throw new IllegalArgumentException( "path cannot be null" );
        }
        this.path = path;
        this.clazz = clazz;
        this.classLoader = classLoader;
    }
    
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject( this.path );
    }

    public void readExternal(ObjectInput in) throws IOException,
                                            ClassNotFoundException {
        this.path = (String) in.readObject();
    }    

    /**
     * This implementation opens an InputStream for the given class path resource.
     * @see java.lang.ClassLoader#getResourceAsStream(String)
     * @see java.lang.Class#getResourceAsStream(String)
     */
    public InputStream getInputStream() throws IOException {
        InputStream is = null;
        if ( this.clazz != null ) {
            is = this.clazz.getResourceAsStream( this.path );
        } else if ( this.classLoader != null ) {
            is = this.classLoader.getResourceAsStream( this.path );
        }

        if ( is == null ) {
            is = Thread.currentThread().getContextClassLoader().getResourceAsStream( this.path );
        }

        if ( is == null ) {
//            is = Class.class.getClassLoader().getSystemClassLoader().getResourceAsStream( this.path );
            is = ClassLoader.getSystemClassLoader().getResourceAsStream( this.path );
        }

        if ( is == null ) {
            throw new FileNotFoundException( "'" + this.path + "' cannot be opened because it does not exist" );
        }
        this.lastRead = getLastModified();
        return is;
    }

    /**
     * This implementation returns a URL for the underlying class path resource.
     * @see java.lang.ClassLoader#getResource(String)
     * @see java.lang.Class#getResource(String)
     */
    public URL getURL() throws IOException {
        URL url = null;
        if ( this.clazz != null ) {
            url = this.clazz.getResource( this.path );
        } else if ( this.classLoader != null ) {
            url = this.classLoader.getResource( this.path );
        }

        if ( url == null ) {
            url = Thread.currentThread().getContextClassLoader().getResource( this.path );
        }

        if ( url == null ) {
//            url = Class.class.getClassLoader().getSystemClassLoader().getResource( this.path );
            url = ClassLoader.getSystemClassLoader().getResource( this.path );
        }

        if ( url == null ) {
            throw new FileNotFoundException( "'" + this.path + "' cannot be opened because it does not exist" );
        }
        return url;
    }

    public boolean hasURL() {
        return true;
    }

    public long getLastModified() {
        try {
            URLConnection conn = getURL().openConnection();
            long date = conn.getLastModified();
            return date;
        } catch ( IOException e ) {
            throw new RuntimeException( "Unable to get LastMofified for ClasspathResource",
                                        e );
        }
    }

    public long getLastRead() {
        return this.lastRead;
    }

    public Reader getReader() throws IOException {
        return new InputStreamReader( getInputStream() );
    }
    
    public boolean isDirectory() {
        try {
            URL url = getURL();

            if ( !"file".equals( url.getProtocol() ) ) {
                return false;
            }

            File file = new File( StringUtils.toURI( url.toString() ).getSchemeSpecificPart() );
            
            return file.isDirectory();
        } catch ( Exception e ) {
            return false;
        }
    }


    public ClassLoader getClassLoader() {
        return this.classLoader;
    }
    
    public boolean equals(Object object) {
        if ( object == null || !(object instanceof ClassPathResource) ) {
            return false;
        }

        ClassPathResource other = (ClassPathResource) object;
        if ( !this.path.equals( other.path ) ) {
            return false;
        }

        return this.clazz == other.clazz && this.classLoader == other.classLoader;
    }

    public int hashCode() {
        return this.path.hashCode();
    }

    public String toString() {
        return "[ClassPathResource path='" + this.path + "']";
    }


}
package com.cnk.travelerp.common.persistence.io;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;

/**
 * <p>
 * Generic interface to provide a Reader or InputStream for the underlying IO resource.
 * </p>
 */
public interface Resource extends Serializable {
    /**
     * Open an InputStream to the resource, the user must close this when finished.
     * 
     * @return
     * @throws IOException
     */
    InputStream getInputStream() throws IOException;

    /**
     * Opens a Reader to the resource, the user most close this when finished.
     * @return
     * @throws IOException
     */
    public Reader getReader() throws IOException;

}
package com.cnk.travelerp.common.persistence.model;

import java.util.ArrayList;
import java.util.List;

/**
 * Generic class to bind attributes values with their respective keys
 * 
 * @author vishwanath.dubey
 * 
 */
public class AttributeDBMappingModel {

    private String name; // Name of attribute: it should be unique in an
                         // entity's attributes list. REQUIRED
    private boolean isRequired; // to qualify if this attribute is mandatory :
                                // REQUIRED
    private String targetName; // target column name : REQUIRED
    private String dataType; // Data Type: need to refer to mapping DB data
                             // type: REQUIRED
    private boolean isKey; // to qualify if this attribute is part of key for
                           // updating the required.:
    private boolean isKeySeq; // to qualify if attribuet is a key and need a
                              // auto sequence generation e.g. in Oracle, while
                              // inserting records, the key would be generated
                              // by Oracle Sequence.:
    private short KeyColSeq; // if it is part of key, then specify key sequence
                             // number.
    private boolean isUpdateable = true; // whether this field is updateable
    private short orderNo; // specify order No
    private String defaultValue = ""; // default value if any
    private String headerName; // jqgrid column header name
    
  
    private List<ColumnMappingModel> columns = new ArrayList<>(4);
    
    

    // private int length;
    // private int decimalPrecision;

    public AttributeDBMappingModel() {

    }

    public String getHeaderName() {
        return headerName;
    }

    public void setHeaderName(String headerName) {
        this.headerName = headerName;
    }

    public AttributeDBMappingModel(String name, String targetName,
            String dataType) {
        this(name, targetName, dataType, false);
    }

    public AttributeDBMappingModel(String name, String targetName,
            String dataType, boolean isRequired) {
        this(name, targetName, dataType, isRequired, false);
    }

    public AttributeDBMappingModel(String name, String targetName,
            String dataType, boolean isRequired, boolean isKey) {
        this.name = name;
        this.targetName = targetName;
        this.dataType = dataType;
        this.isRequired = isRequired;
        this.isKey = isKey;
        if (isKey) { // the key column can not be updateable
            isUpdateable = false;
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isRequired() {
        return isRequired;
    }

    public void setRequired(boolean isRequired) {
        this.isRequired = isRequired;
    }

    public String getTargetName() {
        return targetName;
    }

    public void setTargetName(String targetName) {
        this.targetName = targetName;
    }

    public String getDataType() {
        return dataType;
    }

    public void setDataType(String dataType) {
        this.dataType = dataType;
    }

    public boolean isKey() {
        return isKey;
    }

    public void setKey(boolean isKey) {
        this.isKey = isKey;
    }

    public boolean isKeySeq() {
        return isKeySeq;
    }

    public void setKeySeq(boolean isKeySeq) {
        this.isKeySeq = isKeySeq;
    }

    public short getKeyColSeq() {
        return KeyColSeq;
    }

    public void setKeyColSeq(short keyColSeq) {
        KeyColSeq = keyColSeq;
    }

    public boolean isUpdateable() {
        return isUpdateable;
    }

    public void setUpdateable(boolean isUpdateable) {
        this.isUpdateable = isUpdateable;
    }

    public short getOrderNo() {
        return orderNo;
    }

    public void setOrderNo(short orderNo) {
        this.orderNo = orderNo;
    }

    public String getDefaultValue() {
        return defaultValue;
    }

    public void setDefaultValue(String defaultValue) {
        this.defaultValue = defaultValue;
    }

	/**
	 * @return the columns
	 */
	public List<ColumnMappingModel> getColumns() {
		return columns;
	}

	/**
	 * @param columns the columns to set
	 */
	public void setColumns(List<ColumnMappingModel> columns) {
		this.columns = columns;
	}
    
    

}
package com.cnk.travelerp.common.persistence.model;

public class ColumnMappingModel {
	
	String tableName;
	String columnName;
	String aliasName;
	boolean primaryKey =  false;
	boolean autoGenerated =  false;
	
	String generatedKey;
	String seq;
	
	String lookup = "";
	/**
	 * 
	 */
	
	public ColumnMappingModel(){
		
	}
	
	
	
	/**
	 * @param tableName
	 * @param columnName
	 * @param aliasName
	 */
	public ColumnMappingModel( String tableName,
			String columnName, String aliasName) {
		super();
		this.tableName = tableName;
		this.columnName = columnName;
		this.aliasName = aliasName;
	}


	/**
	 * @param columnName
	 * @param aliasName
	 */
	public ColumnMappingModel(String columnName, String aliasName) {
		super();
		this.columnName = columnName;
		this.aliasName = aliasName;
	}

	/**
	 * @param tableName
	 * @param columnName
	 * @param primaryKey
	 */
	public ColumnMappingModel(String tableName,
			String columnName, boolean primaryKey) {
		super();
		this.tableName = tableName;
		this.columnName = columnName;
		this.primaryKey = primaryKey;
	}

	/**
	 * @param tableName
	 * @param columnName
	 * @param aliasName
	 * @param primaryKey
	 * @param autoGenerated
	 */
	public ColumnMappingModel(String tableName,
			String columnName, String aliasName, boolean primaryKey,
			boolean autoGenerated) {
		super();
		this.tableName = tableName;
		this.columnName = columnName;
		this.aliasName = aliasName;
		this.primaryKey = primaryKey;
		this.autoGenerated = autoGenerated;
	}
	


	/**
	 * @return the tableName
	 */
	public String getTableName() {
		return tableName;
	}



	/**
	 * @param tableName the tableName to set
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}



	/**
	 * @return the columnName
	 */
	public String getColumnName() {
		return columnName;
	}



	/**
	 * @param columnName the columnName to set
	 */
	public void setColumnName(String columnName) {
		this.columnName = columnName;
	}



	/**
	 * @return the aliasName
	 */
	public String getAliasName() {
		return aliasName;
	}



	/**
	 * @param aliasName the aliasName to set
	 */
	public void setAliasName(String aliasName) {
		this.aliasName = aliasName;
	}



	/**
	 * @return the primaryKey
	 */
	public boolean isPrimaryKey() {
		return primaryKey;
	}



	/**
	 * @param primaryKey the primaryKey to set
	 */
	public void setPrimaryKey(boolean primaryKey) {
		this.primaryKey = primaryKey;
	}



	/**
	 * @return the autoGenerated
	 */
	public boolean isAutoGenerated() {
		return autoGenerated;
	}



	/**
	 * @param autoGenerated the autoGenerated to set
	 */
	public void setAutoGenerated(boolean autoGenerated) {
		this.autoGenerated = autoGenerated;
	}



	/**
	 * @return the generatedKey
	 */
	public String getGeneratedKey() {
		return generatedKey;
	}



	/**
	 * @param generatedKey the generatedKey to set
	 */
	public void setGeneratedKey(String generatedKey) {
		this.generatedKey = generatedKey;
	}




	/**
	 * @return the seq
	 */
	public String getSeq() {
		return seq;
	}



	/**
	 * @param seq the seq to set
	 */
	public void setSeq(String seq) {
		this.seq = seq;
	}



	/**
	 * @return the lookup
	 */
	public String getLookup() {
		return lookup;
	}



	/**
	 * @param lookup the lookup to set
	 */
	public void setLookup(String lookup) {
		this.lookup = lookup;
	}




	

	
	
}
package com.cnk.travelerp.common.persistence.model;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * A generic entity model to be used to bind the entity value records
 * 
 * @author vishwanath.dubey
 * 
 */

public class EntityDBMappingModel {

    private String name;

    private String targetObect; // E.g. Table Name

    private String targetType; // E.G. DB name

    private String path; // E.g. Schema name of Database

    List<AttributeDBMappingModel> attributes = new ArrayList<>(1);
    List<ReferenceDBMappingModel> references = new ArrayList<>(5);
    List<JqGridMappingModel> jqGridModelProperties = new ArrayList<>(1); // for
                                                                         // JqGrid
                                                                         // model
    List<EntityIdentifier> identifiers = new ArrayList<>(5);
                                                                         // attributes
                                                                         // mapping
    
    
    
    List<TableMappingModel> tables = new ArrayList<>(2);

    List<JoinMappingModel> joins = new ArrayList<>();

    public EntityDBMappingModel() {

    }

    public EntityDBMappingModel(String name, String targetObject, String path,
            String targetType) {
        this.name = name;
        this.path = path;
        this.targetObect = targetObject;
        this.targetType = targetType;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTargetObect() {
        return targetObect;
    }

    public void setTargetObect(String targetObect) {
        this.targetObect = targetObect;
    }

    public String getTargetType() {
        return targetType;
    }

    public void setTargetType(String targetType) {
        this.targetType = targetType;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public List<AttributeDBMappingModel> getAttributes() {
        return attributes;
    }

    public void setAttributes(List<AttributeDBMappingModel> attributes) {
        this.attributes = attributes;
    }

    public void addAttribute(AttributeDBMappingModel am) {
        attributes.add(am);
    }

    public List<ReferenceDBMappingModel> getReferences() {
        return references;
    }

    public void setReferences(List<ReferenceDBMappingModel> references) {
        this.references = references;
    }

    public void addAttribute(ReferenceDBMappingModel am) {
        references.add(am);
    }

    // jqGrid start
    public List<JqGridMappingModel> getJqGridModelProperties() {
        return jqGridModelProperties;
    }

    public void setJqGridModelProperties(
            List<JqGridMappingModel> jqGridModelProperties) {
        this.jqGridModelProperties = jqGridModelProperties;
    }

    public void addAttribute(JqGridMappingModel am) {
        jqGridModelProperties.add(am);
    }

    
    
    
    // jqGrid end

    /**
	 * @return the tables
	 */
	public List<TableMappingModel> getTables() {
		return tables;
	}

	/**
	 * @param tables the tables to set
	 */
	public void setTables(List<TableMappingModel> tables) {
		this.tables = tables;
	}

	/**
	 * @return the joins
	 */
	public List<JoinMappingModel> getJoins() {
		return joins;
	}

	
	
	/**
	 * @return the identifiers
	 */
	public List<EntityIdentifier> getIdentifiers() {
		return identifiers;
	}

	/**
	 * @param identifiers the identifiers to set
	 */
	public void setIdentifiers(List<EntityIdentifier> identifiers) {
		this.identifiers = identifiers;
	}

	/**
	 * @param joins the joins to set
	 */
	public void setJoins(List<JoinMappingModel> joins) {
		this.joins = joins;
	}

	public List<DBColumn> allColumns() {
        List<DBColumn> columnList = new ArrayList<>();
        Set<String> colNames = new HashSet<>();
        for (AttributeDBMappingModel attrDBModel : attributes) {
            DBColumn dbColumn = new DBColumn();
            dbColumn.name = attrDBModel.getName();
            dbColumn.DBObject = this.targetObect;
            dbColumn.columnName = attrDBModel.getTargetName();
            dbColumn.aliasName = dbColumn.columnName;
            columnList.add(dbColumn);
            colNames.add(attrDBModel.getName());
        }

        for (ReferenceDBMappingModel refDBModel : references) {
            if (!colNames.contains(refDBModel.getName())) { // this provides
                                                            // check for if
                                                            // reference column
                                                            // is defined in
                                                            // attribute list or
                                                            // not.
                continue;//
            }
            if (refDBModel.getTargetDispAttribute() == null
                    || refDBModel.getTargetDispAttribute().isEmpty()) {
                continue;
            }

            DBColumn dbColumn = new DBColumn();
            dbColumn.name = refDBModel.getName();
            dbColumn.DBObject = refDBModel.getTargetObject();
            dbColumn.columnName = refDBModel.getTargetDispAttribute();
            if (refDBModel.getAliasName() != null
                    && !refDBModel.getAliasName().isEmpty()) {
                dbColumn.aliasName = refDBModel.getAliasName();
            }
            else {
                dbColumn.aliasName = refDBModel.getTargetObject() + "_"
                        + dbColumn.columnName;
            }

            dbColumn.isReference = true;
            columnList.add(dbColumn);
        }
        return columnList;
    }

    public AttributeDBMappingModel findByColumnName(String dbColumnName) {
        for (AttributeDBMappingModel attribDBModel : attributes) {
            if (attribDBModel.getTargetName().equals(dbColumnName)) {
                return attribDBModel;
            }
        }
        return null;
    }
    
    public List<String> getAutoKeyColumns(){
    	List<String> autoKeys = new ArrayList<>();
        for (AttributeDBMappingModel attribDBModel : attributes) {
        	if (autoKeys.contains(attribDBModel.getName())){
        		continue;
        	}
        	for(ColumnMappingModel columnMap:attribDBModel.getColumns()){
        		if (columnMap.autoGenerated && columnMap.primaryKey){
        			autoKeys.add(attribDBModel.getName());
        			break;
        		}
        	}
        }
    	return autoKeys;
    }

    public class DBColumn {

        public String name;
        public String DBObject;
        public String columnName;
        public String aliasName;
        public boolean isReference = false;

        // @Override
        // public boolean equals(Object obj) {
        // if (this == obj){
        // return true;
        // }
        // if (obj == null){
        // return false;
        // }
        // if ( getClass() != obj.getClass()){
        // return false;
        // }
        // DBColumn dbCol = (DBColumn)obj;
        // return dbCol.columnName != null &&
        // dbCol.columnName.equals(this.columnName);
        //
        // }
        //
        // @Override
        // public int hashCode() {
        // final int prime = 31;
        // int result = 1;
        // result = prime * result
        // + ((columnName == null) ? 0 : columnName.hashCode());
        // return result;
        //
        // }

    }
}
package com.cnk.travelerp.common.persistence.model;

public class EntityIdentifier {

	String tableName;
	String columnName;
	String value;
	
	/**
	 * default constructor
	 */
	public EntityIdentifier(){
		
	}
	
	
	/**
	 * @param tableName
	 * @param columnName
	 * @param value
	 */
	public EntityIdentifier(String tableName, String columnName, String value) {
		super();
		this.tableName = tableName;
		this.columnName = columnName;
		this.value = value;
	}
	/**
	 * @return the tableName
	 */
	public String getTableName() {
		return tableName;
	}
	/**
	 * @param tableName the tableName to set
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}
	/**
	 * @return the columnName
	 */
	public String getColumnName() {
		return columnName;
	}
	/**
	 * @param columnName the columnName to set
	 */
	public void setColumnName(String columnName) {
		this.columnName = columnName;
	}
	/**
	 * @return the value
	 */
	public String getValue() {
		return value;
	}
	/**
	 * @param value the value to set
	 */
	public void setValue(String value) {
		this.value = value;
	}
	
	
	
	
}
package com.cnk.travelerp.common.persistence.model;


/**
 * Join Mapping Annotation is used to provide table and column names 
 * for joining more than two tables.
 *  
 * @author vishwanath.dubey
 *
 */
public class JoinMappingModel {
	
	String lTableName;
	String lColumnName;
	String rTableName;
	String rColumnName;
	
	
	


/**
 * 
 */

	public JoinMappingModel(){
		
	}
	
	public JoinMappingModel(String lTableName, String lColumnName,
			String rTableName, String rColumnName) {
		super();
		this.lTableName = lTableName;
		this.lColumnName = lColumnName;
		this.rTableName = rTableName;
		this.rColumnName = rColumnName;
	}




	/**
	 * @return the lTableName
	 */
	public String getlTableName() {
		return lTableName;
	}




	/**
	 * @param lTableName the lTableName to set
	 */
	public void setlTableName(String lTableName) {
		this.lTableName = lTableName;
	}




	/**
	 * @return the lColumnName
	 */
	public String getlColumnName() {
		return lColumnName;
	}




	/**
	 * @param lColumnName the lColumnName to set
	 */
	public void setlColumnName(String lColumnName) {
		this.lColumnName = lColumnName;
	}




	/**
	 * @return the rTableName
	 */
	public String getrTableName() {
		return rTableName;
	}




	/**
	 * @param rTableName the rTableName to set
	 */
	public void setrTableName(String rTableName) {
		this.rTableName = rTableName;
	}




	/**
	 * @return the rColumnName
	 */
	public String getrColumnName() {
		return rColumnName;
	}




	/**
	 * @param rColumnName the rColumnName to set
	 */
	public void setrColumnName(String rColumnName) {
		this.rColumnName = rColumnName;
	}





}

/**
 * 
 */
package com.cnk.travelerp.common.persistence.model;

/**
 * @author sivaiah.polamreddy
 * 
 *         In this class we define attributes for JqGrid model mapping in UI
 *         side. this attributes are standard in jqGrid, attribute names must
 *         match with jqGrid attributes
 */
public class JqGridMappingModel {

    private String name; // JqGrid model attribute : REQUIRED
    private String index; // JqGrid model attribute : REQUIRED
    private String editrules; // JqGrid model attribute : REQUIRED
    private boolean editable; // JqGrid model attribute : REQUIRED
    private String align; // JqGrid model attribute
    private String edittype; // JqGrid model attribute
    private boolean hidden; // JqGrid model attribute : REQUIRED

    public JqGridMappingModel() {

    }

    public JqGridMappingModel(String name, String index, String editrules,
            boolean editable, String align, String edittype, boolean hidden) {

        this.name = name;
        this.index = index;
        this.editrules = editrules;
        this.editable = editable;
        this.align = align;
        this.edittype = edittype;
        this.hidden = hidden;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIndex() {
        return index;
    }

    public void setIndex(String index) {
        this.index = index;
    }

    public String getEditrules() {
        return editrules;
    }

    public void setEditrules(String editrules) {
        this.editrules = editrules;
    }

    public boolean isEditable() {
        return editable;
    }

    public void setEditable(boolean editable) {
        this.editable = editable;
    }

    public String getAlign() {
        return align;
    }

    public void setAlign(String align) {
        this.align = align;
    }

    public String getEdittype() {
        return edittype;
    }

    public void setEdittype(String edittype) {
        this.edittype = edittype;
    }

    public boolean isHidden() {
        return hidden;
    }

    public void setHidden(boolean hidden) {
        this.hidden = hidden;
    }

}
package com.cnk.travelerp.common.persistence.model;

import java.util.ArrayList;
import java.util.List;

/**
 * All references defined for an entity's attribute to be captured.
 * 
 * @author vishwanath.dubey
 * 
 */
public class ReferenceDBMappingModel {

    private String name; // Name of attribute: it should match with a name of
                         // attribute specified for entity model
    private String targetObject; // target column name : REQUIRED
    private String targetAttribute; // target column name : REQUIRED
    private String targetDispAttribute; // target display column name : REQUIRED
    private String targetAliasName; // target alias name in the sql join :
                                    // REQUIRED
    private String aliasName; // target alias as display name
    private String displayName; // jqGrid display column name

    private List<RefJoinMapping> joincolumns = new ArrayList<>(4);

    public ReferenceDBMappingModel() {

    }

    public ReferenceDBMappingModel(String name, String targetObject,
            String targetAttribute, String targetDispAttribute,
            String targetAliasName) {
        this();
        this.name = name;
        this.targetObject = targetObject;
        this.targetAttribute = targetAttribute;
        this.targetDispAttribute = targetDispAttribute;
        this.targetAliasName = targetAliasName;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getTargetObject() {
        return targetObject;
    }

    public void setTargetObject(String targetObject) {
        this.targetObject = targetObject;
    }

    public String getTargetAttribute() {
        return targetAttribute;
    }

    /**
     * @return the taregtAliasName
     */
    public String getTargetAliasName() {
        return targetAliasName;
    }

    /**
     * @param taregtAliasName
     *            the taregtAliasName to set
     */
    public void setTargetAliasName(String targetAliasName) {
        this.targetAliasName = targetAliasName;
    }

    /**
     * @return the joincolumns
     */
    public List<RefJoinMapping> getJoincolumns() {
        return joincolumns;
    }

    /**
     * @param joincolumns
     *            the joincolumns to set
     */
    public void setJoincolumns(List<RefJoinMapping> joincolumns) {
        this.joincolumns = joincolumns;
    }

    /**
     * @return the displayName
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * @param displayName
     *            the displayName to set
     */
    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public void setTargetAttribute(String targetAttribute) {
        this.targetAttribute = targetAttribute;
    }

    public String getTargetDispAttribute() {
        return targetDispAttribute;
    }

    public void setTargetDispAttribute(String targetDispAttribute) {
        this.targetDispAttribute = targetDispAttribute;
    }

    /**
     * @return the aliasName
     */
    public String getAliasName() {
        return aliasName;
    }

    /**
     * @param aliasName
     *            the aliasName to set
     */
    public void setAliasName(String aliasName) {
        this.aliasName = aliasName;
    }

}
package com.cnk.travelerp.common.persistence.model;

import java.util.ArrayList;
import java.util.List;

public class RefJoinMapping {

	
	String columnName;
	String refColumnName;
	String refTableName;
	
	
	List<RefJoinMapping> joincolumns = new ArrayList<>();
	
	/**
	 * 
	 */
	public RefJoinMapping(){
		
	}
	
	/**
	 * @param columnName
	 * @param refColumnName
	 * @param refTableName
	 */
	public RefJoinMapping(String columnName, String refColumnName,
			String refTableName) {
		super();
		this.columnName = columnName;
		this.refColumnName = refColumnName;
		this.refTableName = refTableName;
	}


	/**
	 * @return the columnName
	 */
	public String getColumnName() {
		return columnName;
	}


	/**
	 * @param columnName the columnName to set
	 */
	public void setColumnName(String columnName) {
		this.columnName = columnName;
	}


	/**
	 * @return the refColumnName
	 */
	public String getRefColumnName() {
		return refColumnName;
	}


	/**
	 * @param refColumnName the refColumnName to set
	 */
	public void setRefColumnName(String refColumnName) {
		this.refColumnName = refColumnName;
	}


	/**
	 * @return the refTableName
	 */
	public String getRefTableName() {
		return refTableName;
	}


	/**
	 * @param refTableName the refTableName to set
	 */
	public void setRefTableName(String refTableName) {
		this.refTableName = refTableName;
	}
	
	
	
	
}
package com.cnk.travelerp.common.persistence.model;

public class TableMappingModel {

	String tableName;
	boolean mainTable = false;
	boolean autoKey = false;
	String[] keyColumns ;
	String aliasName;
	
	public TableMappingModel(){
		
	}

	
	
	
	
	/**
	 * @param tableName
	 * @param keyColumns
	 */
	public TableMappingModel(String tableName, String[] keyColumns) {
		super();
		this.tableName = tableName;
		this.keyColumns = keyColumns;
	}

	/**
	 * @param tableName
	 * @param keyColumns
	 */
	public TableMappingModel(String tableName, String[] keyColumns,String aliasName) {
		super();
		this.tableName = tableName;
		this.keyColumns = keyColumns;
		this.aliasName = aliasName;
	}




	/**
	 * @param tableName
	 * @param mainTable
	 * @param autoKey
	 * @param keyColumns
	 * @param aliasName
	 */
	public TableMappingModel(String tableName, boolean mainTable,
			boolean autoKey, String[] keyColumns, String aliasName) {
		super();
		this.tableName = tableName;
		this.mainTable = mainTable;
		this.autoKey = autoKey;
		this.keyColumns = keyColumns;
		this.aliasName = aliasName;
	}

	/**
	 * @return the tableName
	 */
	public String getTableName() {
		return tableName;
	}

	/**
	 * @param tableName the tableName to set
	 */
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}

	/**
	 * @return the mainTable
	 */
	public boolean isMainTable() {
		return mainTable;
	}

	/**
	 * @param mainTable the mainTable to set
	 */
	public void setMainTable(boolean mainTable) {
		this.mainTable = mainTable;
	}

	/**
	 * @return the autoKey
	 */
	public boolean isAutoKey() {
		return autoKey;
	}

	/**
	 * @param autoKey the autoKey to set
	 */
	public void setAutoKey(boolean autoKey) {
		this.autoKey = autoKey;
	}

	/**
	 * @return the keyColumns
	 */
	public String[] getKeyColumns() {
		return keyColumns;
	}

	/**
	 * @param keyColumns the keyColumns to set
	 */
	public void setKeyColumns(String[] keyColumns) {
		this.keyColumns = keyColumns;
	}
	
	


	/**
	 * @return the aliasName
	 */
	public String getAliasName() {
		return aliasName;
	}

	/**
	 * @param aliasName the aliasName to set
	 */
	public void setAliasName(String aliasName) {
		this.aliasName = aliasName;
	}
	
	
	
	
}
package com.cnk.travelerp.common.persistence.service;

import java.util.Properties;

import com.cnk.travelerp.common.persistence.dao.IDao;
import com.cnk.travelerp.common.persistence.io.ClassPathResource;
import com.cnk.travelerp.common.persistence.io.Resource;

/**
 * Abstraction persistence service to be used by persistence service of respective persistence layer
 *  
 * 
 * @author vishwanath.dubey
 *
 */

public abstract class AbstractPersistService {


	protected Properties properties = new Properties();
	protected IDao dao ;

	
	protected void init() throws Exception{
		String resourceFileName = this.getClass().getName();
		resourceFileName =  resourceFileName.substring(resourceFileName.lastIndexOf(".")+1)
				+".properties";
		Resource resource = new ClassPathResource(resourceFileName,this.getClass());
		properties.load(resource.getInputStream());
		
	}


	public void setDao( IDao dao){
		this.dao = dao;
	}
	
	protected String valueOf(String key){
		return properties.getProperty(key);
	}
	
	


}
package com.cnk.travelerp.common.persistence.service;


import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

import com.cnk.travelerp.common.persistence.springmapper.DomainRowMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapBeanMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapResultSetExtractor;
import com.cnk.travelerp.common.persistence.springmapper.MapperResultSetExtractor;
import com.cnk.travelerp.common.persistence.util.Utils;



public class DomainPersistenceService<T> extends AbstractPersistService{

	private static final String attibute_mapping = "mapper";
	private static final String insert_statement = "statement.insert";
	private static final String insert_params = "statement.insert.params";
	private static final String select_All_statement = "statement.selectAll";
	private static final String select_A_person_record = "statement.select";
	private static final String select_A_person_param = "statement.select.params";
	private static final String select_Row_map = "statement.rowMap";
	


	
	protected final HashMapBeanMapper<T> mapper ; //mapper would be part of it.
	private RowMapper<T> personRowMapper;

	public DomainPersistenceService(Properties properties,Class<T> clazz) throws Exception{
		this.properties = properties;
		
		mapper = new HashMapBeanMapper<T>( valueOf( attibute_mapping ),clazz);
		
		ResultSetExtractor<T> extractor = new MapperResultSetExtractor<T>(
				new HashMapResultSetExtractor(valueOf( select_Row_map ) ),
				mapper, clazz	);
		personRowMapper = new DomainRowMapper<T>(extractor);
		
	}
	

	
	public boolean persist(T t){
		@SuppressWarnings("unchecked")
		HashMap<String,?> map = mapper.map(t, HashMap.class);

		dao.create( valueOf( insert_statement ),
				Utils.toObjects(map, valueOf( insert_params).split(",")) );
		
		return true;
	}

	public List<T> select(T t){
		@SuppressWarnings("unchecked")
		HashMap<String,?> map = mapper.map(t, HashMap.class);
		return  dao.select(  valueOf( select_A_person_record ) , 
				Utils.toObjects(map, valueOf( select_A_person_param ).split(",")),
				personRowMapper);
	}

	
	public List<T> selectAll(){
		return  dao.selectAll( valueOf(select_All_statement), personRowMapper);
	}
	
}
package com.cnk.travelerp.common.persistence.service;


import java.util.HashMap;
import java.util.List;
import java.util.Map;

//import org.springframework.jdbc.support.GeneratedKeyHolder;


import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.sql.CompositeStatement;
import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.sql.Statement.StatementType;
import com.cnk.travelerp.common.persistence.util.Utils;



public class EntityCompositePersistenceService<T> extends EntityPersistenceService<T>{

	public EntityCompositePersistenceService(
			DomainMapping domainMapping,
			Class<T> clazz, EntityPersistenceContainerService containerService) throws Exception{
		
		super( domainMapping,clazz,containerService);
	}
	

	public boolean persist(T t) throws Exception{
		@SuppressWarnings("unchecked")
		HashMap<String,Object> map = mapper.map(t, HashMap.class);
		CompositeStatement selStatement =(CompositeStatement)domainMapping.getStatement(Statement.StatementType.Select);
		
		List<T> list =  dao.select(  selStatement.sqlStatement  , 
									Utils.toObjects(map, selStatement.placeHolderAttributes ),
										domainRowMapper);
		boolean retVal = true;
		
		
		
		if (list.size()==0){
			//insert
			retVal = insertOrUpdate(t, Statement.StatementType.Insert,map);

		}
		else {
			//update
			retVal = insertOrUpdate(t, Statement.StatementType.Update,map);

		}
		
		updateDependants(t);
		return retVal;
	}

	protected boolean insertOrUpdate(T t, Statement.StatementType stType,HashMap<String,Object> map){
		CompositeStatement statement =(CompositeStatement)domainMapping.getStatement(stType);
		
		for(Map.Entry<String,String> e:statement.getDefaultValues().entrySet() ){
//			if (Arrays.binarySearch(statement.placeHolderAttributes,e.getKey()) >= 0){}
			map.put(e.getKey(),e.getValue());
		}
		
		if (stType == StatementType.Insert && statement.isAutoKey){
//			Statement keySeqStatement = domainMapping.getStatement(Statement.StatementType.Key_Seq);
//			long id = dao.queryForObject(keySeqStatement.sqlStatement, Long.class);
			updateAutoKeyValues(t,map); //this line is when in specific to Oracle.
			
//			GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
//
//			dao.create( statement.sqlStatement ,
//					Utils.toObjects(map, statement.placeHolderAttributes), keyHolder);
			
//			updateValues(t,map,keyHolder);
		}
//		else {
//			dao.create( statement.sqlStatement ,
//					Utils.toObjects(map, statement.placeHolderAttributes) );
//		}
		dao.create( statement.sqlStatement ,
				Utils.toObjects(map, statement.placeHolderAttributes) );

		//perform for sub statements
		for(Statement suStatement:statement.subStatements){
			dao.create( suStatement.sqlStatement ,
					Utils.toObjects(map, suStatement.placeHolderAttributes) );
		}
		
		return true;
	}
	
}
package com.cnk.travelerp.common.persistence.service;


import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;
//import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.processor.AbstractSQLGenerator;
import com.cnk.travelerp.common.persistence.annotation.processor.ColumnMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.JoinColumnMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.SQLStatementGenerator;
//import com.cnk.travelerp.common.persistence.annotation.processor.JoinTableMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.Reference;
import com.cnk.travelerp.common.persistence.filter.SQLFilter;
import com.cnk.travelerp.common.persistence.springmapper.DomainRowMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapBeanMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapResultSetExtractor;
import com.cnk.travelerp.common.persistence.springmapper.MapperResultSetExtractor;
import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.util.Utils;


/**
 * 
 * @author vishwanath.dubey
 *
 * @param <T>
 */
public class EntityPersistenceService<T> extends AbstractPersistService{

	protected final HashMapBeanMapper<T> mapper ; //mapper would be part of it.
	protected RowMapper<T> domainRowMapper;

	protected final DomainMapping domainMapping ;
	
	private final String domainClassName ;
	
	protected final EntityPersistenceContainerService containerService;
	
	public EntityPersistenceService(
			DomainMapping domainMapping,
			Class<T> clazz, EntityPersistenceContainerService containerService) throws Exception{
		this.domainMapping = domainMapping;
		
		domainClassName = clazz.getName();

		mapper = new HashMapBeanMapper<T>( domainMapping.getAttributeMapping() ,clazz);

		ResultSetExtractor<T> extractor = new MapperResultSetExtractor<T>(
				new HashMapResultSetExtractor( domainMapping.getAttributeMapping()  ),
				mapper, clazz	);
		domainRowMapper = new DomainRowMapper<T>(extractor);
		
		this.containerService = containerService;
		this.dao = containerService.dao;
		
	}
	

	public boolean persist(T t)  throws Exception{
		@SuppressWarnings("unchecked")
		HashMap<String,Object> map = mapper.map(t, HashMap.class);
		Statement selStatement = domainMapping.getStatement(Statement.StatementType.Select);
		
		List<T> list =  dao.select(  selStatement.sqlStatement  , 
									Utils.toObjects(map, selStatement.placeHolderAttributes ),
										domainRowMapper);
		
		boolean retVal = true;
		boolean isInsAutoKey = false;
		Statement statement = null;

		if (list.size()==0){
			//insert
			statement = domainMapping.getStatement(Statement.StatementType.Insert);
			isInsAutoKey = statement.isAutoKey;
		}
		else {
			//update
			statement = domainMapping.getStatement(Statement.StatementType.Update);
		}

		for(Map.Entry<String,String> e:statement.getDefaultValues().entrySet() ){
//			if (Arrays.binarySearch(statement.placeHolderAttributes,e.getKey()) >= 0){}
			map.put(e.getKey(),e.getValue());
		}
		
		if (isInsAutoKey){
			//putting default column values 
//			GeneratedKeyHolder keyHolder = new GeneratedKeyHolder(); //in case of MySql.
//			Statement keySeqStatement = domainMapping.getStatement(Statement.StatementType.Key_Seq);
//			long id = dao.queryForObject(keySeqStatement.sqlStatement, Long.class);
			updateAutoKeyValues(t,map); //this line is when in specific to Oracle.
			
//			dao.create( statement.sqlStatement ,
//					Utils.toObjects(map, statement.placeHolderAttributes));
//			Utils.toObjects(map, statement.placeHolderAttributes), keyHolder);
			
//			updateValues(t,map,keyHolder); //this line will comes when key holder is used.
			
			
		}
//		else {
//			dao.create( statement.sqlStatement ,
//					Utils.toObjects(map, statement.placeHolderAttributes) );
//		}
		dao.create( statement.sqlStatement ,
				Utils.toObjects(map, statement.placeHolderAttributes) );
		
		
		updateDependants(t);

		return retVal;
	}

	
	
	public List<T> select(T t) throws Exception{
		@SuppressWarnings("unchecked")
		HashMap<String,?> map = mapper.map(t, HashMap.class);
		
		Statement selStatement = domainMapping.getStatement(Statement.StatementType.Join_Select_By_Key);

		
		List<T> f =  dao.select(  selStatement.sqlStatement , 
				Utils.toObjects(map, selStatement.placeHolderAttributes),	domainRowMapper);
		for(T r:f){		
			retrieveDependants(r);
		}
		return f;
	}
	

	public List<T> selectAll(){
		Statement selStatement = domainMapping.getStatement(Statement.StatementType.Join_Select);
		return  dao.selectAll( selStatement.sqlStatement, domainRowMapper);
	}
	
	public String getDomainClassName(){
		return domainClassName;
	}
	

	public List<T> queryBy(SQLQuery<T> query){
		
		SQLFilter sqlFilter = query.retrieveQueryFilter(domainMapping);
		
		Statement selStatement = domainMapping.getStatement( Statement.StatementType.Join_Select );
		
		String statement = null;
		if (selStatement.sqlStatement.indexOf(AbstractSQLGenerator.WHERE_LITTERAL)>1){
			statement = selStatement.sqlStatement + " "+sqlFilter.sqlCriteria();
		}
		else {
			statement = selStatement.sqlStatement + AbstractSQLGenerator.WHERE_LITTERAL+sqlFilter.sqlCriteria();
		}
		return dao.select( statement,sqlFilter.getValues(), domainRowMapper);
	}


	
	protected void updateValues(T t,HashMap<String,Object> map, KeyHolder keyHolder){
			//below code assumes there will be single key.
			List<String> keyAliases = domainMapping.retreiveAutoKeyAlias();
			for(String keyAlias: keyAliases){
				map.put(keyAlias, keyHolder.getKey()); //set
			}
			domainMapping.setValue(t, keyHolder.getKey()); //set the value of object
	}
	
	protected void updateAutoKeyValues(T t,HashMap<String,Object> map){
		//below code assumes there will be single key.
		for(ColumnMapping colMap: domainMapping.getAutoKeys()){
			if (colMap.getGeneratedType() == GeneratedType.Sequence){
				String seq = colMap.getSeq();
				String nextIdStmt = SQLStatementGenerator.seqGenerator(seq);
				long id = dao.queryForObject(nextIdStmt, Long.class);
				List<ColumnMapping> tcolMaps = domainMapping.getColumnMappingByFieldName(colMap.getFieldName());
				for(ColumnMapping tcolMap:tcolMaps){
					map.put( tcolMap.getAliasName(), id); //set
				}
				domainMapping.setValue(t, id); //set the value of object
			}
		}
	}
	
	@SuppressWarnings({ "unchecked", "rawtypes" })
	protected void updateDependants(T t) throws Exception {
		
		List<Object> dependants = domainMapping.retrieveDependants(t);
		
		for(Object obj : dependants){
			
			Class<T> cla2= (Class<T>)obj.getClass();
		    if (Collection.class.isAssignableFrom(cla2)){
				Collection col = (Collection)obj;
		    	for(Object obj1:col){
					EntityPersistenceService persistenceService = 
							containerService.getPersistService(obj1.getClass());
					
					DomainMapping depedantDomainMapping = persistenceService.domainMapping;
					domainMapping.updateValue(t,obj1,depedantDomainMapping);
		    		persistenceService.persist(obj1);
		    	}
		    }
		    else {
				EntityPersistenceService persistenceService = 
						containerService.getPersistService(obj.getClass());

				DomainMapping depedantDomainMapping = persistenceService.domainMapping;
				domainMapping.updateValue(t,obj,depedantDomainMapping);
				persistenceService.persist(obj);
		    	
		    }

		}
		
	}
	
	
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void retrieveDependants(T t) throws Exception{
		
		List<Reference> dependants  = domainMapping.getDownReferences();
		for(Reference ref:dependants){
			
			EntityPersistenceService persistenceService = 
					containerService.getPersistService( ref.getTargetClass() );
			
			//child domain mapping
			DomainMapping cDomainMapping = persistenceService.domainMapping;
			Reference parentRef  = cDomainMapping.getParentReference( ref.getMappedBy() );
			if (parentRef == null){
				continue;
			}
			
			//TODO Join table Map is to be considered yet.
			//JoinTableMapping joinTableMap = parentRef.getJoinTable();
			
			
			JoinColumnMapping[] joinColumnMaps = parentRef.getJoinColumns();
			
			SQLQuery<?> sqlQuery = new SQLQuery( ref.getClass() );
			for(JoinColumnMapping joinColumnMap:joinColumnMaps){
				sqlQuery.equal(joinColumnMap.getReferenceField(), domainMapping.getValue(t,joinColumnMap.getReferenceField()));
			}

			List<?> list =  persistenceService.queryBy(sqlQuery);
			if (list.size()==0){
				return;
			}
			
			Field field = domainMapping.getFieldDownReferences( ref.getFieldName());
			Class<?> type = field.getType();
			 if (Collection.class.isAssignableFrom( type )){
				 //if it is null
				 Object obj1 = field.get(t);
				 if (obj1!= null){
					 for(Object obj:list){
						 ((Collection)obj1).add( obj );
						 persistenceService.retrieveDependants(obj);
					 }
				 }
				 else {
					 Collection containerObj = new ArrayList();//set Arraylist as object
					 for(Object obj:list){
						 containerObj.add( obj );
						 persistenceService.retrieveDependants(obj);
					 }
					 field.set(t, containerObj);
				 }
			 }
			 else {
				 field.set(t, list.get(0));
				 persistenceService.retrieveDependants(list.get(0));
			 }
		}
		
		
	}
	

	
}
package com.cnk.travelerp.common.persistence.service;


import java.util.List;
import java.util.Map;

//import org.springframework.jdbc.support.GeneratedKeyHolder;

import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.springmapper.BeanMapperLocator;
import com.cnk.travelerp.common.persistence.springmapper.HashMapRowMapper;
import com.cnk.travelerp.common.persistence.sql.CompositeStatement;
import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.sql.Statement.StatementType;
import com.cnk.travelerp.common.persistence.util.Utils;

/**
 * 
 * @author vishwanath.dubey
 *
 * @param 
 */
public class MasterEntityCompositePersistenceService extends MasterEntityPersistenceService{

	MasterEntityCompositePersistenceService(MasterPersistenceContainerService containerService){
		super(containerService);
	}
	
	/**
	 * 
	 */
	public boolean persist(Map<String,?> map,DomainMapping domainMapping)  throws Exception{

		Statement selStatement = domainMapping.getStatement(Statement.StatementType.Select);
		HashMapRowMapper hashMapRowMapper = BeanMapperLocator.getRowMapper(domainMapping);
		
		List<Map<String,?>> list =  dao.select(  selStatement.sqlStatement  , 
									Utils.toObjects(map, selStatement.placeHolderAttributes ),
									hashMapRowMapper);
		
		boolean retVal = true;
		
		
		if (list.size()==0){
			//insert
			retVal = insertOrUpdate(Statement.StatementType.Insert,map,domainMapping);

		}
		else {
			//update
			retVal = insertOrUpdate(Statement.StatementType.Update,map,domainMapping);

		}
		
		return retVal;
		
	}

	
	
	@SuppressWarnings("unchecked")
	protected boolean insertOrUpdate(Statement.StatementType stType,Map<String,?> map, DomainMapping domainMapping){
		CompositeStatement statement =(CompositeStatement)domainMapping.getStatement(stType);
		
		for(Map.Entry<String,String> e:statement.getDefaultValues().entrySet() ){
//			if (Arrays.binarySearch(statement.placeHolderAttributes,e.getKey()) >= 0){}
			((Map<String,Object>)map).put(e.getKey(),e.getValue());
		}
		
		if (stType == StatementType.Insert && statement.isAutoKey){
			
//			Statement keySeqStatement = domainMapping.getStatement(Statement.StatementType.Key_Seq);
//			long id = dao.queryForObject(keySeqStatement.sqlStatement, Long.class);
			updateAutoKeyValues(map,domainMapping); //this line is when in specific to Oracle.

			
//			GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
//
//			dao.create( statement.sqlStatement ,
//					Utils.toObjects(map, statement.placeHolderAttributes), keyHolder);
//			
//			
//			updateKeyValues(map, domainMapping,keyHolder);

		}
//		else {
			String[] placeholders1 = Utils.getMappedKeys(statement.placeHolderAttributes,
										domainMapping.getAttributeMapping());
			dao.create( statement.sqlStatement ,
					Utils.toObjects(map, placeholders1) );
//		}

		//perform for sub statements
		for(Statement suStatement:statement.subStatements){
			String[] placeholders = Utils.getMappedKeys(suStatement.placeHolderAttributes,
					domainMapping.getAttributeMapping());
			dao.create( suStatement.sqlStatement ,
					Utils.toObjects(map, placeholders) );
		}
		
		return true;
	}

	

	
}
package com.cnk.travelerp.common.persistence.service;

import java.util.List;
import java.util.Map;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.processor.AbstractSQLGenerator;
import com.cnk.travelerp.common.persistence.annotation.processor.ColumnMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.SQLStatementGenerator;
import com.cnk.travelerp.common.persistence.filter.SQLFilter;
import com.cnk.travelerp.common.persistence.springmapper.BeanMapperLocator;
import com.cnk.travelerp.common.persistence.springmapper.HashMapResultSetExtractor;
import com.cnk.travelerp.common.persistence.springmapper.HashMapRowMapper;
import com.cnk.travelerp.common.persistence.sql.Statement;
import com.cnk.travelerp.common.persistence.util.Utils;

/**
 * 
 * @author vishwanath.dubey
 * 
 * @param
 */
public class MasterEntityPersistenceService extends AbstractPersistService {

    MasterEntityPersistenceService(
            MasterPersistenceContainerService containerService) {
        this.dao = containerService.dao;
    }

    @SuppressWarnings("unchecked")
    public boolean persist(Map<String, ?> map, DomainMapping domainMapping)
            throws Exception {

        Statement selStatement = domainMapping
                .getStatement(Statement.StatementType.Select);
        HashMapRowMapper hashMapRowMapper = BeanMapperLocator
                .getRowMapper(domainMapping);

        List<Map<String, ?>> list = dao.select(selStatement.sqlStatement,
                Utils.toObjects(map, selStatement.placeHolderAttributes),
                hashMapRowMapper);

        boolean retVal = true;
        boolean isInsAutoKey = false;
        Statement statement = null;

        if (list.size() == 0) {
            // insert
            statement = domainMapping
                    .getStatement(Statement.StatementType.Insert);
            isInsAutoKey = statement.isAutoKey;
        }
        else {
            // update
            statement = domainMapping
                    .getStatement(Statement.StatementType.Update);
        }

        for (Map.Entry<String, String> e : statement.getDefaultValues()
                .entrySet()) {
            // if
            // (Arrays.binarySearch(statement.placeHolderAttributes,e.getKey())
            // >= 0){}
            ((Map<String, Object>) map).put(e.getKey(), e.getValue());
        }

        if (isInsAutoKey) {
            // putting default column values
            // Statement keySeqStatement =
            // domainMapping.getStatement(Statement.StatementType.Key_Seq);
            // long id = dao.queryForObject(keySeqStatement.sqlStatement,
            // Long.class);
            updateAutoKeyValues(map, domainMapping); // this line is when in
                                                     // specific to Oracle.

            // GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
            // dao.create( statement.sqlStatement ,
            // Utils.toObjects(map, statement.placeHolderAttributes),
            // keyHolder);
            //
            //
            // updateKeyValues(map, domainMapping,keyHolder);

        }
        // else {
        // dao.create( statement.sqlStatement ,
        // Utils.toObjects(map, statement.placeHolderAttributes) );
        // }
        dao.create(statement.sqlStatement,
                Utils.toObjects(map, statement.placeHolderAttributes));

        // updateDependants(t);

        return retVal;
    }

    public List<Map<String, ?>> select(Map<String, ?> map,
            DomainMapping domainMapping) throws Exception {

        Statement selStatement = domainMapping
                .getStatement(Statement.StatementType.Join_Select_By_Key);
        HashMapRowMapper hashMapRowMapper = BeanMapperLocator
                .getRowMapper(domainMapping);

        String[] placeholders1 = Utils.getMappedKeys(
                selStatement.placeHolderAttributes,
                domainMapping.getAttributeMapping());

        List<Map<String, ?>> f = dao.select(selStatement.sqlStatement,
                Utils.toObjects(map, placeholders1), hashMapRowMapper);
        return f;
    }

    // based on parentid
    public List<Map<String, ?>> selectByParentId(Map<String, ?> map,
            DomainMapping domainMapping) throws Exception {

        Statement selStatement = domainMapping
                .getStatement(Statement.StatementType.Join_Select_By_Parent_Key);
        HashMapRowMapper hashMapRowMapper = BeanMapperLocator
                .getRowMapper(domainMapping);

        String[] placeholders1 = Utils.getMappedKeys(
                selStatement.placeHolderAttributes,
                domainMapping.getAttributeMapping());

        List<Map<String, ?>> f = dao.select(selStatement.sqlStatement,
                Utils.toObjects(map, placeholders1), hashMapRowMapper);
        return f;
    }

    public List<Map<String, ?>> selectAll(DomainMapping domainMapping) {
        Statement selStatement = domainMapping
                .getStatement(Statement.StatementType.Join_Select);
        HashMapRowMapper hashMapRowMapper = BeanMapperLocator
                .getRowMapper(domainMapping);

        return dao.selectAll(selStatement.sqlStatement, hashMapRowMapper);
    }

    public List<Map<String, ?>> queryBy(SQLQuery<Map<String, ?>> query,
            DomainMapping domainMapping) {

        SQLFilter sqlFilter = query.retrieveQueryFilter(domainMapping);

        Statement selStatement = domainMapping
                .getStatement(Statement.StatementType.Join_Select);
        HashMapRowMapper hashMapRowMapper = new HashMapRowMapper(
                new HashMapResultSetExtractor(
                        domainMapping.getAttributeMapping()));

        String statement = null;
        if (selStatement.sqlStatement
                .indexOf(AbstractSQLGenerator.WHERE_LITTERAL) > 1) {
            statement = selStatement.sqlStatement + " "
                    + sqlFilter.sqlCriteria();
        }
        else {
            statement = selStatement.sqlStatement
                    + AbstractSQLGenerator.WHERE_LITTERAL
                    + sqlFilter.sqlCriteria();
        }
        return dao.select(statement, sqlFilter.getValues(), hashMapRowMapper);
    }

    /**
     * for generated key, it will be updated to original hash map.
     * 
     * @param map
     * @param domainMap
     * @param keyHolder
     */
    @SuppressWarnings("unchecked")
    protected void updateKeyValues(Map<String, ?> map, DomainMapping domainMap,
            GeneratedKeyHolder keyHolder) {
        List<ColumnMapping> autoKeys = domainMap.getAutoKeys();
        if (autoKeys.size() > 1) {
            // currently there is no key having column more than one auto key
        }

        ColumnMapping autoKeyColumn = autoKeys.get(0);
        ((Map<String, Object>) map).put(autoKeyColumn.getFieldName(),
                keyHolder.getKey());

    }

    // /**
    // * for generated key, it will be updated to original hash map.
    // * @param map
    // * @param domainMap
    // * @param keyHolder
    // */
    // @SuppressWarnings("unchecked")
    // protected void updateKeyValues(Map<String,?> map, DomainMapping
    // domainMap,long id ){
    // List<ColumnMapping> autoKeys = domainMap.getAutoKeys();
    // if (autoKeys.size()>1){
    // //currently there is no key having column more than one auto key
    // }
    //
    // ColumnMapping autoKeyColumn = autoKeys.get(0);
    // ((Map<String,Object>)map).put(autoKeyColumn.getFieldName(), id);
    //
    // }

    @SuppressWarnings("unchecked")
    protected void updateAutoKeyValues(Map<String, ?> map,
            DomainMapping domainMapping) {
        // below code assumes there will be single key.
        for (ColumnMapping colMap : domainMapping.getAutoKeys()) {
            if (colMap.getGeneratedType() == GeneratedType.Sequence) {
                String seq = colMap.getSeq();
                String nextIdStmt = SQLStatementGenerator.seqGenerator(seq);
                long id = dao.queryForObject(nextIdStmt, Long.class);
                ((Map<String, Object>) map).put(colMap.getFieldName(), id);
            }
        }
    }
}
package com.cnk.travelerp.common.persistence.service;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.WeakHashMap;
import org.codehaus.jackson.map.ObjectMapper;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMappingProcessor;
import com.cnk.travelerp.common.persistence.annotation.processor.SQLStatementGenerator;
import com.cnk.travelerp.common.persistence.dao.IDao;
import com.cnk.travelerp.common.persistence.model.EntityDBMappingModel;

/**
 * This class will act as service for
 * 
 * @author vishwanath.dubey
 * 
 */

public class MasterPersistenceContainerService {

    ObjectMapper objectMapper = new ObjectMapper();

    MasterEntityPersistenceService masterPersistenceService;
    MasterEntityCompositePersistenceService masterCompositePersistenceService;

    private static Map<String, DomainMapping> domainMappings = new WeakHashMap<>();
    protected IDao dao;

    /**
     * 
     * @param t
     * @return
     * @throws Exception
     */
    public boolean persist(String masterKey, Map<String, ?> data)
            throws Exception {

        DomainMapping domainMapping = getPersistService(masterKey);
        MasterEntityPersistenceService persistService = getPersistService(domainMapping);
        return persistService.persist(data, domainMapping);
    }

    public List<Map<String, ?>> select(String masterKey, Map<String, ?> data)
            throws Exception {
        DomainMapping domainMapping = getPersistService(masterKey);
        MasterEntityPersistenceService persistService = getPersistService(domainMapping);

        return persistService.select(data, domainMapping);

    }

    // based on parent id
    public List<Map<String, ?>> selectByParentId(String masterKey,
            Map<String, ?> data) throws Exception {
        DomainMapping domainMapping = getPersistService(masterKey);
        MasterEntityPersistenceService persistService = getPersistService(domainMapping);

        return persistService.selectByParentId(data, domainMapping);

    }

    public List<Map<String, ?>> selectAll(String masterKey) throws Exception {
        DomainMapping domainMapping = getPersistService(masterKey);
        MasterEntityPersistenceService persistService = getPersistService(domainMapping);

        return persistService.selectAll(domainMapping);

    }

    public List<Map<String, ?>> queryBy(String masterKey,
            SQLQuery<Map<String, ?>> query) throws Exception {
        DomainMapping domainMapping = getPersistService(masterKey);
        MasterEntityPersistenceService persistService = getPersistService(domainMapping);

        return persistService.queryBy(query, domainMapping);
    }

    DomainMapping getPersistService(String masterKey) throws Exception {
        if (masterPersistenceService == null) {
            masterPersistenceService = new MasterEntityPersistenceService(this);
            masterCompositePersistenceService = new MasterEntityCompositePersistenceService(
                    this);
        }

        DomainMapping domainMapping = domainMappings.get(masterKey);
        if (domainMapping == null) {
            // String jsonModelData =
            // "{\"name\":\"VCITY_MASTER\",\"targetObect\":\"VCITY_MASTER\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"VCITY_MASTER\",\"mainTable\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"VCITY_MASTER\",\"lColumnName\":\"ID\",\"rTableName\":\"VCITY_MASTER_LOCALE\",\"rColumnName\":\"CITY_ID\"}],\"identifiers\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ENTITY_ID\",\"value\":\"10\"}],\"attributes\":[{\"name\":\"CityId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"CityLocaleId\",\"dataType\":\"INT\",\"headerName\":\"CityLocal Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"ID\",\"aliasName\":\"CITYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"CONTINENT_MASTER\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"CountryId\",\"targetObject\":\"COUNTRY_MASTER\",\"targetAttribute\":\"COUNTRY_ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"COUNTRY_ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"StateId\",\"targetObject\":\"STATE_MASTER\",\"targetAttribute\":\"STATE_ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"STATE_ID\",\"refColumnName\":\"STATE_ID\",\"refTableName\":\"VCITY_MASTER\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";

            // String jsonModelData =
            // "{\"name\":\"TERP_CONTINENT\",\"targetObect\":\"TERP_CONTINENT\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_CONTINENT\",\"mainTable\":true,\"keyColumns\":[\"CONTINENT_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"keyColumns\":[\"CONTINENT_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_CONTINENT\",\"lColumnName\":\"CONTINENT_ID\",\"rTableName\":\"TERP_CONTINENT_LOCALE\",\"rColumnName\":\"CONTINENT_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"ContinentId\",\"dataType\":\"INT\",\"headerName\":\"ContinentId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT\",\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_ID\"}]},{\"name\":\"ContinentLocaleId\",\"dataType\":\"INT\",\"headerName\":\"ContinentLocalId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_LOCALE_ID\",\"aliasName\":\"CONTINENTLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"ContinentName\",\"targetName\":\"CONTINENT_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_NAME\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"aliasName\":\"CONTINENTNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"CONTINENT_ID\",\"index\":\"CONTINENT_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}";

            // String jsonModelData =
            // "{\"name\":\"TERP_COUNTRY\",\"targetObect\":\"TERP_COUNTRY\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_COUNTRY\",\"mainTable\":true,\"keyColumns\":[\"COUNTRY_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"keyColumns\":[\"COUNTRY_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_COUNTRY\",\"lColumnName\":\"COUNTRY_ID\",\"rTableName\":\"TERP_COUNTRY_LOCALE\",\"rColumnName\":\"COUNTRY_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"CountryId\",\"dataType\":\"INT\",\"headerName\":\"CountryId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY\",\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_ID\"}]},{\"name\":\"CountryLocaleId\",\"dataType\":\"INT\",\"headerName\":\"CountryLocalId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_LOCALE_ID\",\"aliasName\":\"COUNTRYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"localeID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CountryName\",\"targetName\":\"COUNTRY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_NAME\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"aliasName\":\"COUNTRYNAME\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"TERP_CONTINENT_LOCALE\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_COUNTRY\"}]}],\"jqGridModelProperties\":[{\"name\":\"COUNTRY_ID\",\"index\":\"COUNTRY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false}]}";

            // String jsonModelData =
            // "{\"name\":\"TERP_ENTITY\",\"targetObect\":\"TERP_ENTITY\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_ENTITY\",\"mainTable\":true,\"keyColumns\":[\"ENTITY_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_ENTITY_LOCALE\",\"keyColumns\":[\"ENTITY_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_ENTITY\",\"lColumnName\":\"ENTITY_ID\",\"rTableName\":\"TERP_ENTITY_LOCALE\",\"rColumnName\":\"ENTITY_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"EntityId\",\"dataType\":\"INT\",\"headerName\":\"EntityId\",\"columns\":[{\"tableName\":\"TERP_ENTITY\",\"columnName\":\"ENTITY_ID\",\"aliasName\":\"ENTITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_ENTITY_LOCALE\",\"columnName\":\"ENTITY_ID\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_ENTITY_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"EntityName\",\"targetName\":\"ENTITIY_LOCALE_VALUE\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Entity\",\"columns\":[{\"columnName\":\"ENTITIY_LOCALE_VALUE\",\"tableName\":\"TERP_ENTITY_LOCALE\",\"aliasName\":\"ENTITYNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"ENTITY_ID\",\"index\":\"ENTITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"ENTITIY_LOCALE_VALUE\",\"index\":\"ENTITIY_LOCALE_VALUE\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}";

            String jsonModelData = getJsonModelData(masterKey);

            EntityDBMappingModel model = objectMapper.readValue(jsonModelData,
                    EntityDBMappingModel.class);
            domainMapping = DomainMappingProcessor.processEM(model);
            SQLStatementGenerator.generateStatment(domainMapping);
            domainMappings.put(masterKey, domainMapping);
        }
        return domainMapping;

    }

    MasterEntityPersistenceService
            getPersistService(DomainMapping domainMapping) {
        if (domainMapping.isComposite()) {
            return masterCompositePersistenceService;
        }
        else {
            return masterPersistenceService;
        }
    }

    public void setDao(IDao dao) {
        this.dao = dao;
    }

    private String getJsonModelData(String tablename) {

        String jsonModeldata = null;

        try {
            com.cnk.travelerp.common.persistence.io.Resource resource = new com.cnk.travelerp.common.persistence.io.ClassPathResource(
                    "meta.properties");
            Properties properties = new Properties();
            properties.load(resource.getInputStream());
            jsonModeldata = properties.getProperty(tablename);
        }
        catch (Exception e) {
        }
        return jsonModeldata;
    }

}
package com.cnk.travelerp.common.persistence.service;

import java.util.ArrayList;
import java.util.List;

import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.filter.AndSQLFilter;
import com.cnk.travelerp.common.persistence.filter.EqualSqlFilter;
import com.cnk.travelerp.common.persistence.filter.SQLFilter;


public class SQLQuery<T> {
	
	enum TYPES{equal,like,greaterthan,lessthan,greaterthanOrEqual,lessthanOrEqual,  rangeBetween};
	
	Class<T> domainClass;
	
	String sqlStatement;

	
	List<Criteria> criterion = new ArrayList<>();
	
	/**
	 * @param domainClass
	 */
	public SQLQuery(Class<T> domainClass) {
		super();
		this.domainClass = domainClass;
	}
	
	/**
	 * @param domainClass
	 */
	public SQLQuery(Class<T> domainClass,String sqlStatement) {
		this(domainClass);
		this.sqlStatement = sqlStatement;
	}

	
	Class<T> getDomainClass(){
		return domainClass;
	}
	
	
	
	public SQLQuery<T> equal(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.equal,fieldName,val) );
		return this;
	}

	public SQLQuery<T> like(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.like,fieldName,val) );
		return this;
	}


	public SQLQuery<T> greaterThan(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.greaterthan,fieldName,val) );
		return this;
	}

	public SQLQuery<T> lessThan(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.greaterthan,fieldName,val) );
		return this;
	}

	
	public SQLQuery<T> greaterOrEqualThan(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.greaterthan,fieldName,val) );
		return this;
	}

	public SQLQuery<T> lessOrEqualThan(String fieldName, Object val){
		criterion.add( new Criteria(TYPES.greaterthan,fieldName,val) );
		return this;
	}

	
	public SQLQuery<T> rangeBetween(String fieldName, Object fromVal,Object toVal){
		criterion.add( new Criteria(TYPES.greaterthanOrEqual,fieldName,fromVal) );
		criterion.add( new Criteria(TYPES.lessthanOrEqual,fieldName,toVal) );
		return this;
	}

	
	SQLFilter retrieveQueryFilter(DomainMapping domainMapping){
		
		List<SQLFilter> filters=new ArrayList<>();
		List<SQLFilter> filterTemps = new ArrayList<>(); 
		for(Criteria criteria:criterion){
			List<String>  dbFields = domainMapping.getDBFields( criteria.fieldName);
			if (dbFields.size() == 0){
				continue;
			}
			
			filterTemps.clear();
			switch (criteria.type){
			case equal:
				for(String s:dbFields){
					filterTemps.add( new EqualSqlFilter(s,criteria.val) );
				}
				break;
			case like:
				break;
			case greaterthan:
				break;
			case lessthan:
				break;
			case greaterthanOrEqual:
				break;
			case lessthanOrEqual:
				break;
			default:
			}
			filters.addAll(filterTemps);
		}

		if (filters.size()>1){
			AndSQLFilter andFilter = new AndSQLFilter(filters.get(0),filters.get(1));
			for(int i=2;i<filters.size();i++){
				andFilter = new AndSQLFilter(andFilter,filters.get(i));
			}
			return andFilter;
		}
		else if (filters.size() == 1){
			return filters.get( 0 );
		}
		else {
			return SQLFilter.BLANK_FILTER;
		}
		
	}
	
	static class Criteria{
		TYPES type;
		String fieldName;
		Object val;
		/**
		 * @param type
		 * @param filedName
		 * @param val
		 */
		public Criteria(TYPES type, String fieldName, Object val) {
			super();
			this.type = type;
			this.fieldName = fieldName;
			this.val = val;
		}
		
//		/**
//		 * @param type
//		 * @param filedName
//		 * @param val
//		 */
//		public Criteria(TYPES type, String fieldName, Object fromVal,Object toVal) {
//			this(type,fieldName,fromVal);
//			this.toVal = toVal;
//		}
		
	}
	
}
package com.cnk.travelerp.common.persistence.springframework;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;

public class GenericPreparedStatementCreator implements PreparedStatementCreator {
	
	final PreparedStatementSetter pss;
	final String sqlStatement;;
	public GenericPreparedStatementCreator(PreparedStatementSetter pss, String sqlStatement){
		this.pss = pss;
		this.sqlStatement = sqlStatement;
	}

	/* (non-Javadoc)
	 * @see org.springframework.jdbc.core.PreparedStatementCreator#createPreparedStatement(java.sql.Connection)
	 */
	@Override
	public PreparedStatement createPreparedStatement(Connection con)   throws SQLException {
		    PreparedStatement ps = con.prepareStatement( sqlStatement, Statement.RETURN_GENERATED_KEYS);

		    pss.setValues(ps);
		    return ps;

	}

	
	

}
package com.cnk.travelerp.common.persistence.springmapper;

import java.util.Map;
import java.util.WeakHashMap;

import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;


public class BeanMapperLocator {

	
	private static Map<String,HashMapRowMapper > rowMapper = new WeakHashMap<>();
	
	private static Object lockobj = new Object();
	
	/**
	 * 
	 * @param domainMapping
	 * @return
	 */
	public static HashMapRowMapper getRowMapper(DomainMapping domainMapping){
		String domainName = domainMapping.getDomainName();
		if (rowMapper.get(domainName) == null){
			synchronized ( lockobj ) {
				if (rowMapper.get(domainName) == null){
					HashMapRowMapper hashMapRowMapper = new HashMapRowMapper(
							new HashMapKeyResultSetExtractor( domainMapping.getAttributeMapping())
							);

					rowMapper.put(domainName, hashMapRowMapper);
				}
			}
		}
		
		return rowMapper.get(domainName);
	}

}
package com.cnk.travelerp.common.persistence.springmapper;

import java.sql.ResultSet;
import java.sql.SQLException;
//import java.util.HashMap;

import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;


public class DomainRowMapper<T> implements RowMapper<T> {
	
	HashMapBeanMapper<T> mapper ;
	
	ResultSetExtractor<T> extractor;
	
	public DomainRowMapper(ResultSetExtractor<T> extractor){
		this.extractor = extractor;
	}
	

	@Override
	public T mapRow(ResultSet rs, int line) throws SQLException {
		
		return extractor.extractData(rs);
	}
	
} 
package com.cnk.travelerp.common.persistence.springmapper;

import java.util.HashMap;

import ma.glasnost.orika.MapperFactory;
import ma.glasnost.orika.impl.ConfigurableMapper;
import ma.glasnost.orika.metadata.ClassMapBuilder;


public class HashMapBeanMapper<T> {
	   private final String mappingAttributes;

	   private final Class<T> sourceClass;
	   
	   
	   LocalMapper mapper;
	   
	   
	   public HashMapBeanMapper(String mappingAttributes2, Class<T> sourceClass){
		   this.mappingAttributes = mappingAttributes2;
		   this.sourceClass = sourceClass;
		   mapper = new LocalMapper();
	   }
	   
	    /**
	     * Delegate methods for MapperFacade;
	     */
	    
	    public <S, D> D map(S sourceObject, Class<D> destinationClass) {
	        return mapper.map(sourceObject, destinationClass);
	    }
	    
		   

	    class LocalMapper extends ConfigurableMapper{
	    	@Override
	    	public void configure(MapperFactory mapperFactory) {
	    		String[] mapAttributes = mappingAttributes.split(",");
	    		ClassMapBuilder<T, ?> builder =  mapperFactory.classMap(sourceClass, HashMap.class);
	    		for(int i=0;i<mapAttributes.length;i++){
	    			String[] attribs = mapAttributes[i].split("=");
	    			builder = builder.field(attribs[0], attribs[1]);
	    		}
	    		builder.toClassMap();


	    		mapperFactory.registerClassMap(
	    				builder
	    				);

	    	}
	    }
	   
	   

	   
}
package com.cnk.travelerp.common.persistence.springmapper;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.HashMap;

import org.apache.commons.lang.ArrayUtils;

import com.cnk.travelerp.common.persistence.util.StringUtils;



public class HashMapKeyResultSetExtractor extends HashMapResultSetExtractor {
	
	public HashMapKeyResultSetExtractor(String rowMapping){
		super(rowMapping);
	
	}
	
	public HashMapKeyResultSetExtractor(String[] lKey,String[] rKey){
		super(lKey,rKey);
	}
	
	@Override
	public HashMap<String,?> extractData(ResultSet rs) throws SQLException {
		HashMap<String,Object> map = new HashMap<>();
		ResultSetMetaData  metaData = rs.getMetaData();
		for(int i=1;i<=metaData.getColumnCount();i++){
			String columnLabel = metaData.getColumnLabel(i);
			int index = StringUtils.indexOfIgnoreCase(rKey, columnLabel);
			if (index < 0){
				map.put( columnLabel, getValue( metaData.getColumnType(i),rs,i));
				
			}
			else {
				map.put( lKey[index], getValue( metaData.getColumnType(i),rs,i));
			}
//			map.put( columnLabel, getValue( metaData.getColumnType(i),rs,i));
		}

		return map;
	}
	
	private Object getValue(int type,ResultSet rs,int columnIndex) throws SQLException{
		switch(type){
		case Types.TINYINT :
			return rs.getByte(columnIndex);
		case Types.SMALLINT :
			return rs.getShort(columnIndex);
		case Types.INTEGER :
			return rs.getInt(columnIndex);
		case Types.BIGINT :
			return rs.getLong(columnIndex);
		case Types.REAL :
			return rs.getFloat(columnIndex);
		case Types.FLOAT :
			return rs.getDouble(columnIndex);
		case Types.DOUBLE :
			return rs.getDouble(columnIndex);
		case Types.DECIMAL :
			return rs.getBigDecimal(columnIndex);
		case Types.NUMERIC :
			return rs.getBigDecimal(columnIndex);
		case Types.BIT :	
			return rs.getObject(columnIndex);
		case Types.CHAR :
			return rs.getString(columnIndex);
		case Types.VARCHAR :
			return rs.getString(columnIndex);
		case Types.LONGVARCHAR :
			return rs.getCharacterStream(columnIndex);
		case Types.BINARY :
			return rs.getBytes(columnIndex);
		case Types.VARBINARY :
			return rs.getBytes(columnIndex);
		case Types.LONGVARBINARY :
			return rs.getBinaryStream(columnIndex);
		case Types.DATE :
			return rs.getDate(columnIndex);
		case Types.TIME :
			return rs.getTime(columnIndex);
		case Types.TIMESTAMP :
			return rs.getTimestamp(columnIndex);
		default :
			return rs.getObject( columnIndex );		
		}
	}
	
	

} 

package com.cnk.travelerp.common.persistence.springmapper;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.HashMap;

import org.springframework.jdbc.core.ResultSetExtractor;



public class HashMapResultSetExtractor implements ResultSetExtractor<HashMap<String, ?>> {
	String[] lKey;
	String[] rKey;
	
	
	public HashMapResultSetExtractor(String rowMapping){
		String[] keyColumn = rowMapping.split(",");
		lKey = new String[keyColumn.length];
		rKey = new String[keyColumn.length];
		for(int i=0;i<keyColumn.length;i++){
			String[] keyVal = keyColumn[i].split("=");
			lKey[i]=keyVal[0];
			rKey[i]=keyVal[1];
		}
	
	}
	
	public HashMapResultSetExtractor(String[] lKey,String[] rKey){
		this.lKey = lKey;
		this.rKey = rKey;
	}
	
	@Override
	public HashMap<String,?> extractData(ResultSet rs) throws SQLException {
		HashMap<String,Object> map = new HashMap<>();
		ResultSetMetaData  metaData = rs.getMetaData();
		for(int i=1;i<=metaData.getColumnCount();i++){
			String columnLabel = metaData.getColumnLabel(i);
//			int index = ArrayUtils.indexOf(rKey, columnLabel);
//			map.put( lKey[index], getValue( metaData.getColumnType(i),rs,i));
			map.put( columnLabel, getValue( metaData.getColumnType(i),rs,i));
		}

		return map;
	}
	
	private Object getValue(int type,ResultSet rs,int columnIndex) throws SQLException{
		switch(type){
		case Types.TINYINT :
			return rs.getByte(columnIndex);
		case Types.SMALLINT :
			return rs.getShort(columnIndex);
		case Types.INTEGER :
			return rs.getInt(columnIndex);
		case Types.BIGINT :
			return rs.getLong(columnIndex);
		case Types.REAL :
			return rs.getFloat(columnIndex);
		case Types.FLOAT :
			return rs.getDouble(columnIndex);
		case Types.DOUBLE :
			return rs.getDouble(columnIndex);
		case Types.DECIMAL :
			return rs.getBigDecimal(columnIndex);
		case Types.NUMERIC :
			return rs.getBigDecimal(columnIndex);
		case Types.BIT :	
			return rs.getObject(columnIndex);
		case Types.CHAR :
			return rs.getString(columnIndex);
		case Types.VARCHAR :
			return rs.getString(columnIndex);
		case Types.LONGVARCHAR :
			return rs.getCharacterStream(columnIndex);
		case Types.BINARY :
			return rs.getBytes(columnIndex);
		case Types.VARBINARY :
			return rs.getBytes(columnIndex);
		case Types.LONGVARBINARY :
			return rs.getBinaryStream(columnIndex);
		case Types.DATE :
			return rs.getDate(columnIndex);
		case Types.TIME :
			return rs.getTime(columnIndex);
		case Types.TIMESTAMP :
			return rs.getTimestamp(columnIndex);
		default :
			return rs.getObject( columnIndex );		
		}
	}
	
	

} 

package com.cnk.travelerp.common.persistence.springmapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Map;
import org.springframework.jdbc.core.RowMapper;


public class HashMapRowMapper implements RowMapper<Map<String, ?>> {

	HashMapResultSetExtractor extractor;
	
	public HashMapRowMapper(HashMapResultSetExtractor extractor){
		this.extractor = extractor;
	}
	

	@Override
	public Map<String, ?> mapRow(ResultSet rs, int line) throws SQLException {
		
		return extractor.extractData(rs);
	}
	
} 
package com.cnk.travelerp.common.persistence.springmapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;


public class MapperResultSetExtractor<T> implements ResultSetExtractor<T>{

	HashMapResultSetExtractor extractor;
	HashMapBeanMapper<T> mapper;
	Class<T> clazz;
	public MapperResultSetExtractor(HashMapResultSetExtractor extractor,HashMapBeanMapper<T> mapper, Class<T> clazz){
		this.extractor = extractor;
		this.mapper = mapper;
		this.clazz = clazz;
	}

	@Override
	public T extractData(ResultSet rs) throws SQLException,
			DataAccessException {
		HashMap<String,?> rowVal = extractor.extractData(rs);
		return mapper.map(rowVal, clazz);
	}
	
	
}
package com.cnk.travelerp.common.persistence.sql;

import java.util.ArrayList;
import java.util.List;


/**
 * This class shall be used when multiple statement needs to be executed 
 * at the same time.
 * @author vishwanath.dubey
 *
 */
public class CompositeStatement extends Statement{


	public Statement statement ;
	public final List<Statement> subStatements = new ArrayList<>(3);
	
	
	public CompositeStatement(StatementType stmtType){
		super(stmtType);
	}
}
package com.cnk.travelerp.common.persistence.sql;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * This class is for holding sql statements detail like sql statement
 * placeholders attributes to be used in sql by prepared statement and type of
 * statement
 * 
 * @author vishwanath.dubey
 * 
 */
public class Statement {

    /**
     * Insert : type of insert statement.It may be composite when more than one
     * table is involved,main table as composite Update : Type of update
     * statement.It may be composite when more than one table is involved,main
     * table as composite Delete : Type of delete statement.It may be composite
     * when more than one table is involved,main table as composite Select: type
     * of Select statement.It may be composite when more than one table is
     * involved,main table as composite Join_Select : Join Select statement.
     * Join Select By Key : Join select statement with keys in the where clause.
     */

    public enum StatementType {
        Insert, Update, Delete, Select, Join_Select, Join_Select_By_Key, Key_Seq, Join_Select_By_Parent_Key
    }

    /**
     * Sql statement
     */
    public String sqlStatement;

    /**
     * place holders attributes.
     */
    public String[] placeHolderAttributes;
    /**
     * type of statement
     */
    private final StatementType statementType;

    /**
     * In case of insert, this statement, main insert statement is auto key
     * generated. The generated key shall be used in sub insert statements.
     */
    public boolean isAutoKey;

    /**
     * this field will identify the row extractory mapping i.e. from column to
     * alias mapping
     */
    public String rowExtractorMapping;

    /**
     * SQL statement for a specific table.
     */
    public String targetName;

    /**
     * contians default values for specified attribute name.
     */
    private final Map<String, String> defaultValues = new LinkedHashMap<>();

    /**
     * 
     * @param stmtType
     */

    public Statement(StatementType stmtType) {
        this.statementType = stmtType;
    }

    public StatementType getStatementType() {
        return this.statementType;
    }

    /**
     * @return the defaultValues
     */
    public Map<String, String> getDefaultValues() {
        return defaultValues;
    }

    /**
     * @param defaultValues
     *            the defaultValues to set
     */
    public void addDefaultValues(String columnName, String defaultValue) {
        defaultValues.put(columnName, defaultValue);

    }

    /**
     * @param defaultValues
     *            the defaultValues to set
     */
    public void addAllDefaultValues(Map<String, String> pdefaultValues) {
        this.defaultValues.putAll(pdefaultValues);

    }

}

package com.cnk.travelerp.common.persistence.util;


import java.io.IOException;
import java.io.Reader;
import java.io.StringWriter;
import java.io.Writer;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * Ripped form commons StringUtil, unless specified:
 * 
 * <p>Operations on {@link java.lang.String} that are
 * <code>null</code> safe.</p>
 *
 * <ul>
 *  <li><b>IsEmpty/IsBlank</b>
 *      - checks if a String contains text</li>
 *  <li><b>Trim/Strip</b>
 *      - removes leading and trailing whitespace</li>
 *  <li><b>Equals</b>
 *      - compares two strings null-safe</li>
 *  <li><b>IndexOf/LastIndexOf/Contains</b>
 *      - null-safe index-of checks
 *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>
 *      - index-of any of a set of Strings</li>
 *  <li><b>ContainsOnly/ContainsNone</b>
 *      - does String contains only/none of these characters</li>
 *  <li><b>Substring/Left/Right/Mid</b>
 *      - null-safe substring extractions</li>
 *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>
 *      - substring extraction relative to other strings</li>
 *  <li><b>Split/Join</b>
 *      - splits a String into an array of substrings and vice versa</li>
 *  <li><b>Remove/Delete</b>
 *      - removes part of a String</li>
 *  <li><b>Replace/Overlay</b>
 *      - Searches a String and replaces one String with another</li>
 *  <li><b>Chomp/Chop</b>
 *      - removes the last part of a String</li>
 *  <li><b>LeftPad/RightPad/Center/Repeat</b>
 *      - pads a String</li>
 *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>
 *      - changes the case of a String</li>
 *  <li><b>CountMatches</b>
 *      - counts the number of occurrences of one String in another</li>
 *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>
 *      - checks the characters in a String</li>
 *  <li><b>DefaultString</b>
 *      - protects against a null input String</li>
 *  <li><b>Reverse/ReverseDelimited</b>
 *      - reverses a String</li>
 *  <li><b>Abbreviate</b>
 *      - abbreviates a string using ellipsis</li>
 *  <li><b>Difference</b>
 *      - compares two Strings and reports on their differences</li>
 *  <li><b>LevensteinDistance</b>
 *      - the number of changes needed to change one String into another</li>
 * </ul>
 *
 * <p>The <code>StringUtils</code> class defines certain words related to
 * String handling.</p>
 *
 * <ul>
 *  <li>null - <code>null</code></li>
 *  <li>empty - a zero-length string (<code>""</code>)</li>
 *  <li>space - the space character (<code>' '</code>, char 32)</li>
 *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>
 *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>
 * </ul>
 *
 * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.
 * That is to say that a <code>null</code> input will return <code>null</code>.
 * Where a <code>boolean</code> or <code>int</code> is being returned
 * details vary by method.</p>
 *
 * <p>A side effect of the <code>null</code> handling is that a
 * <code>NullPointerException</code> should be considered a bug in
 * <code>StringUtils</code> (except for deprecated methods).</p>
 *
 * <p>Methods in this class give sample code to explain their operation.
 * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>
 *
 * @see java.lang.String
 * @author Vishwanath Dubey
 * @since 1.0
 */
public class StringUtils {

    /**
     * An empty immutable <code>String</code> array.
     */
    public static final String[] EMPTY_STRING_ARRAY = new String[0];

    // Performance testing notes (JDK 1.4, Jul03, scolebourne)
    // Whitespace:
    // Character.isWhitespace() is faster than WHITESPACE.indexOf()
    // where WHITESPACE is a string of all whitespace characters
    //
    // Character access:
    // String.charAt(n) versus toCharArray(), then array[n]
    // String.charAt(n) is about 15% worse for a 10K string
    // They are about equal for a length 50 string
    // String.charAt(n) is about 4 times better for a length 3 string
    // String.charAt(n) is best bet overall
    //
    // Append:
    // String.concat about twice as fast as StringBuilder.append
    // (not sure who tested this)

    /**
     * The empty String <code>""</code>.
     * @since 2.0
     */
    public static final String   EMPTY              = "";

    /**
     * Represents a failed index search.
     * @since 2.1
     */
    public static final int      INDEX_NOT_FOUND    = -1;

    /**
     * <p>The maximum size to which the padding constant(s) can expand.</p>
     */
    private static final int     PAD_LIMIT          = 8192;

    /**
     * <p><code>StringUtils</code> instances should NOT be constructed in
     * standard programming. Instead, the class should be used as
     * <code>StringUtils.trim(" foo ");</code>.</p>
     *
     * <p>This constructor is public to permit tools that require a JavaBean
     * instance to operate.</p>
     */
    public StringUtils() {
        super();
    }

    public static String ucFirst(final String name) {
        return name.toUpperCase().charAt( 0 ) + name.substring( 1 );
    }

    // Empty checks
    //-----------------------------------------------------------------------
    /**
     * <p>Checks if a String is empty ("") or null.</p>
     *
     * <pre>
     * StringUtils.isEmpty(null)      = true
     * StringUtils.isEmpty("")        = true
     * StringUtils.isEmpty(" ")       = false
     * StringUtils.isEmpty("bob")     = false
     * StringUtils.isEmpty("  bob  ") = false
     * </pre>
     *
     * <p>NOTE: This method changed in Lang version 2.0.
     * It no longer trims the String.
     * That functionality is available in isBlank().</p>
     *
     * @param str  the String to check, may be null
     * @return <code>true</code> if the String is empty or null
     */
    public static boolean isEmpty(final CharSequence str) {
        if ( str == null || str.length() == 0 ) {
            return true;
        }
        
        for ( int i = 0, length = str.length(); i < length; i++ ){
            if ( str.charAt( i ) != ' ' )  {
                return false;
            }
        }
        
        return true;
    }

    // Padding
    //-----------------------------------------------------------------------
    /**
     * <p>Repeat a String <code>repeat</code> times to form a
     * new String.</p>
     *
     * <pre>
     * StringUtils.repeat(null, 2) = null
     * StringUtils.repeat("", 0)   = ""
     * StringUtils.repeat("", 2)   = ""
     * StringUtils.repeat("a", 3)  = "aaa"
     * StringUtils.repeat("ab", 2) = "abab"
     * StringUtils.repeat("a", -2) = ""
     * </pre>
     *
     * @param str  the String to repeat, may be null
     * @param repeat  number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  <code>null</code> if null String input
     */
    public static String repeat(final String str,
                                final int repeat) {
        // Performance tuned for 2.0 (JDK1.4)

        if ( str == null ) {
            return null;
        }
        if ( repeat <= 0 ) {
            return EMPTY;
        }
        final int inputLength = str.length();
        if ( repeat == 1 || inputLength == 0 ) {
            return str;
        }
        if ( inputLength == 1 && repeat <= PAD_LIMIT ) {
            return padding( repeat,
                            str.charAt( 0 ) );
        }

        final int outputLength = inputLength * repeat;
        switch ( inputLength ) {
            case 1 :
                final char ch = str.charAt( 0 );
                final char[] output1 = new char[outputLength];
                for ( int i = repeat - 1; i >= 0; i-- ) {
                    output1[i] = ch;
                }
                return new String( output1 );
            case 2 :
                final char ch0 = str.charAt( 0 );
                final char ch1 = str.charAt( 1 );
                final char[] output2 = new char[outputLength];
                for ( int i = repeat * 2 - 2; i >= 0; i--, i-- ) {
                    output2[i] = ch0;
                    output2[i + 1] = ch1;
                }
                return new String( output2 );
            default :
                final StringBuilder buf = new StringBuilder( outputLength );
                for ( int i = 0; i < repeat; i++ ) {
                    buf.append( str );
                }
                return buf.toString();
        }
    }

    // Splitting
    //-----------------------------------------------------------------------
    /**
     * <p>Splits the provided text into an array, using whitespace as the
     * separator.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.</p>
     *
     * <pre>
     * StringUtils.split(null)       = null
     * StringUtils.split("")         = []
     * StringUtils.split("abc def")  = ["abc", "def"]
     * StringUtils.split("abc  def") = ["abc", "def"]
     * StringUtils.split(" abc ")    = ["abc"]
     * </pre>
     *
     * @param str  the String to parse, may be null
     * @return an array of parsed Strings, <code>null</code> if null String input
     */
    public static String[] split(String str) {
        return split( str,
                      null,
                      -1 );
    }

    /**
     * <p>Splits the provided text into an array, separator specified.
     * This is an alternative to using StringTokenizer.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.</p>
     *
     * <pre>
     * StringUtils.split(null, *)         = null
     * StringUtils.split("", *)           = []
     * StringUtils.split("a.b.c", '.')    = ["a", "b", "c"]
     * StringUtils.split("a..b.c", '.')   = ["a", "b", "c"]
     * StringUtils.split("a:b:c", '.')    = ["a:b:c"]
     * StringUtils.split("a\tb\nc", null) = ["a", "b", "c"]
     * StringUtils.split("a b c", ' ')    = ["a", "b", "c"]
     * </pre>
     *
     * @param str  the String to parse, may be null
     * @param separatorChar  the character used as the delimiter,
     *  <code>null</code> splits on whitespace
     * @return an array of parsed Strings, <code>null</code> if null String input
     * @since 2.0
     */
    public static String[] split(String str,
                                 char separatorChar) {
        return splitWorker( str,
                            separatorChar,
                            false );
    }

    /**
     * <p>Splits the provided text into an array, separators specified.
     * This is an alternative to using StringTokenizer.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.
     * A <code>null</code> separatorChars splits on whitespace.</p>
     *
     * <pre>
     * StringUtils.split(null, *)         = null
     * StringUtils.split("", *)           = []
     * StringUtils.split("abc def", null) = ["abc", "def"]
     * StringUtils.split("abc def", " ")  = ["abc", "def"]
     * StringUtils.split("abc  def", " ") = ["abc", "def"]
     * StringUtils.split("ab:cd:ef", ":") = ["ab", "cd", "ef"]
     * </pre>
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  <code>null</code> splits on whitespace
     * @return an array of parsed Strings, <code>null</code> if null String input
     */
    public static String[] split(String str,
                                 String separatorChars) {
        return splitWorker( str,
                            separatorChars,
                            -1,
                            false );
    }

    /**
     * <p>Splits the provided text into an array with a maximum length,
     * separators specified.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.
     * A <code>null</code> separatorChars splits on whitespace.</p>
     *
     * <p>If more than <code>min</code> delimited substrings are found, the last
     * returned string includes all characters after the first <code>min - 1</code>
     * returned strings (including separator characters).</p>
     *
     * <pre>
     * StringUtils.split(null, *, *)            = null
     * StringUtils.split("", *, *)              = []
     * StringUtils.split("ab de fg", null, 0)   = ["ab", "cd", "ef"]
     * StringUtils.split("ab   de fg", null, 0) = ["ab", "cd", "ef"]
     * StringUtils.split("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]
     * StringUtils.split("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]
     * </pre>
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  <code>null</code> splits on whitespace
     * @param min  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, <code>null</code> if null String input
     */
    public static String[] split(String str,
                                 String separatorChars,
                                 int max) {
        return splitWorker( str,
                            separatorChars,
                            max,
                            false );
    }

    //-----------------------------------------------------------------------
    /**
     * <p>Splits the provided text into an array, using whitespace as the
     * separator, preserving all tokens, including empty tokens created by 
     * adjacent separators. This is an alternative to using StringTokenizer.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.</p>
     *
     * <pre>
     * StringUtils.splitPreserveAllTokens(null)       = null
     * StringUtils.splitPreserveAllTokens("")         = []
     * StringUtils.splitPreserveAllTokens("abc def")  = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc  def") = ["abc", "", "def"]
     * StringUtils.splitPreserveAllTokens(" abc ")    = ["", "abc", ""]
     * </pre>
     *
     * @param str  the String to parse, may be <code>null</code>
     * @return an array of parsed Strings, <code>null</code> if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(final String str) {
        return splitWorker( str,
                            null,
                            -1,
                            true );
    }

    /**
     * <p>Splits the provided text into an array, separator specified,
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.</p>
     *
     * <pre>
     * StringUtils.splitPreserveAllTokens(null, *)         = null
     * StringUtils.splitPreserveAllTokens("", *)           = []
     * StringUtils.splitPreserveAllTokens("a.b.c", '.')    = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a..b.c", '.')   = ["a", "", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a:b:c", '.')    = ["a:b:c"]
     * StringUtils.splitPreserveAllTokens("a\tb\nc", null) = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a b c", ' ')    = ["a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("a b c ", ' ')   = ["a", "b", "c", ""]
     * StringUtils.splitPreserveAllTokens("a b c  ", ' ')   = ["a", "b", "c", "", ""]
     * StringUtils.splitPreserveAllTokens(" a b c", ' ')   = ["", a", "b", "c"]
     * StringUtils.splitPreserveAllTokens("  a b c", ' ')  = ["", "", a", "b", "c"]
     * StringUtils.splitPreserveAllTokens(" a b c ", ' ')  = ["", a", "b", "c", ""]
     * </pre>
     *
     * @param str  the String to parse, may be <code>null</code>
     * @param separatorChar  the character used as the delimiter,
     *  <code>null</code> splits on whitespace
     * @return an array of parsed Strings, <code>null</code> if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(final String str,
                                                  final char separatorChar) {
        return splitWorker( str,
                            separatorChar,
                            true );
    }

    /**
     * Performs the logic for the <code>split</code> and 
     * <code>splitPreserveAllTokens</code> methods that do not return a
     * maximum array length.
     *
     * @param str  the String to parse, may be <code>null</code>
     * @param separatorChar the separate character
     * @param preserveAllTokens if <code>true</code>, adjacent separators are
     * treated as empty token separators; if <code>false</code>, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, <code>null</code> if null String input
     */
    private static String[] splitWorker(final String str,
                                        final char separatorChar,
                                        final boolean preserveAllTokens) {
        // Performance tuned for 2.0 (JDK1.4)

        if ( str == null ) {
            return null;
        }
        final int len = str.length();
        if ( len == 0 ) {
            return EMPTY_STRING_ARRAY;
        }
        final List<String> list = new ArrayList<String>();
        int i = 0, start = 0;
        boolean match = false;
        boolean lastMatch = false;
        while ( i < len ) {
            if ( str.charAt( i ) == separatorChar ) {
                if ( match || preserveAllTokens ) {
                    list.add( str.substring( start,
                                             i ) );
                    match = false;
                    lastMatch = true;
                }
                start = ++i;
                continue;
            } else {
                lastMatch = false;
            }
            match = true;
            i++;
        }
        if ( match || (preserveAllTokens && lastMatch) ) {
            list.add( str.substring( start,
                                     i ) );
        }
        return (String[]) list.toArray( new String[list.size()] );
    }

    /**
     * <p>Splits the provided text into an array, separators specified, 
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.
     * A <code>null</code> separatorChars splits on whitespace.</p>
     *
     * <pre>
     * StringUtils.splitPreserveAllTokens(null, *)           = null
     * StringUtils.splitPreserveAllTokens("", *)             = []
     * StringUtils.splitPreserveAllTokens("abc def", null)   = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc def", " ")    = ["abc", "def"]
     * StringUtils.splitPreserveAllTokens("abc  def", " ")   = ["abc", "", def"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":")   = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef:", ":")  = ["ab", "cd", "ef", ""]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef::", ":") = ["ab", "cd", "ef", "", ""]
     * StringUtils.splitPreserveAllTokens("ab::cd:ef", ":")  = ["ab", "", cd", "ef"]
     * StringUtils.splitPreserveAllTokens(":cd:ef", ":")     = ["", cd", "ef"]
     * StringUtils.splitPreserveAllTokens("::cd:ef", ":")    = ["", "", cd", "ef"]
     * StringUtils.splitPreserveAllTokens(":cd:ef:", ":")    = ["", cd", "ef", ""]
     * </pre>
     *
     * @param str  the String to parse, may be <code>null</code>
     * @param separatorChars  the characters used as the delimiters,
     *  <code>null</code> splits on whitespace
     * @return an array of parsed Strings, <code>null</code> if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(final String str,
                                                  final String separatorChars) {
        return splitWorker( str,
                            separatorChars,
                            -1,
                            true );
    }

    /**
     * <p>Splits the provided text into an array with a maximum length,
     * separators specified, preserving all tokens, including empty tokens 
     * created by adjacent separators.</p>
     *
     * <p>The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * Adjacent separators are treated as one separator.</p>
     *
     * <p>A <code>null</code> input String returns <code>null</code>.
     * A <code>null</code> separatorChars splits on whitespace.</p>
     *
     * <p>If more than <code>min</code> delimited substrings are found, the last
     * returned string includes all characters after the first <code>min - 1</code>
     * returned strings (including separator characters).</p>
     *
     * <pre>
     * StringUtils.splitPreserveAllTokens(null, *, *)            = null
     * StringUtils.splitPreserveAllTokens("", *, *)              = []
     * StringUtils.splitPreserveAllTokens("ab de fg", null, 0)   = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 0) = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 0)    = ["ab", "cd", "ef"]
     * StringUtils.splitPreserveAllTokens("ab:cd:ef", ":", 2)    = ["ab", "cd:ef"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 2) = ["ab", "  de fg"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 3) = ["ab", "", " de fg"]
     * StringUtils.splitPreserveAllTokens("ab   de fg", null, 4) = ["ab", "", "", "de fg"]
     * </pre>
     *
     * @param str  the String to parse, may be <code>null</code>
     * @param separatorChars  the characters used as the delimiters,
     *  <code>null</code> splits on whitespace
     * @param min  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, <code>null</code> if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(final String str,
                                                  final String separatorChars,
                                                  final int max) {
        return splitWorker( str,
                            separatorChars,
                            max,
                            true );
    }

    /**
     * Performs the logic for the <code>split</code> and 
     * <code>splitPreserveAllTokens</code> methods that return a maximum array 
     * length.
     *
     * @param str  the String to parse, may be <code>null</code>
     * @param separatorChars the separate character
     * @param min  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit.
     * @param preserveAllTokens if <code>true</code>, adjacent separators are
     * treated as empty token separators; if <code>false</code>, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, <code>null</code> if null String input
     */
    private static String[] splitWorker(final String str,
                                        final String separatorChars,
                                        final int max,
                                        final boolean preserveAllTokens) {
        // Performance tuned for 2.0 (JDK1.4)
        // Direct code is quicker than StringTokenizer.
        // Also, StringTokenizer uses isSpace() not isWhitespace()

        if ( str == null ) {
            return null;
        }
        final int len = str.length();
        if ( len == 0 ) {
            return EMPTY_STRING_ARRAY;
        }
        final List<String> list = new ArrayList<String>();
        int sizePlus1 = 1;
        int i = 0, start = 0;
        boolean match = false;
        boolean lastMatch = false;
        if ( separatorChars == null ) {
            // Null separator means use whitespace
            while ( i < len ) {
                if ( Character.isWhitespace( str.charAt( i ) ) ) {
                    if ( match || preserveAllTokens ) {
                        lastMatch = true;
                        if ( sizePlus1++ == max ) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add( str.substring( start,
                                                 i ) );
                        match = false;
                    }
                    start = ++i;
                    continue;
                } else {
                    lastMatch = false;
                }
                match = true;
                i++;
            }
        } else if ( separatorChars.length() == 1 ) {
            // Optimise 1 character case
            final char sep = separatorChars.charAt( 0 );
            while ( i < len ) {
                if ( str.charAt( i ) == sep ) {
                    if ( match || preserveAllTokens ) {
                        lastMatch = true;
                        if ( sizePlus1++ == max ) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add( str.substring( start,
                                                 i ) );
                        match = false;
                    }
                    start = ++i;
                    continue;
                } else {
                    lastMatch = false;
                }
                match = true;
                i++;
            }
        } else {
            // standard case
            while ( i < len ) {
                if ( separatorChars.indexOf( str.charAt( i ) ) >= 0 ) {
                    if ( match || preserveAllTokens ) {
                        lastMatch = true;
                        if ( sizePlus1++ == max ) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add( str.substring( start,
                                                 i ) );
                        match = false;
                    }
                    start = ++i;
                    continue;
                } else {
                    lastMatch = false;
                }
                match = true;
                i++;
            }
        }
        if ( match || (preserveAllTokens && lastMatch) ) {
            list.add( str.substring( start,
                                     i ) );
        }
        return (String[]) list.toArray( new String[list.size()] );
    }

    /**
     * <p>Returns padding using the specified delimiter repeated
     * to a given length.</p>
     *
     * <pre>
     * StringUtils.padding(0, 'e')  = ""
     * StringUtils.padding(3, 'e')  = "eee"
     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException
     * </pre>
     *
     * <p>Note: this method doesn't not support padding with
     * <a href="http://www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a>
     * as they require a pair of <code>char</code>s to be represented.
     * If you are needing to support full I18N of your applications
     * consider using {@link #repeat(String, int)} instead. 
     * </p>
     *
     * @param repeat  number of times to repeat delim
     * @param padChar  character to repeat
     * @return String with repeated character
     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>
     * @see #repeat(String, int)
     */
    public static String padding(final int repeat,
                                 final char padChar) throws IndexOutOfBoundsException {
        if ( repeat < 0 ) {
            throw new IndexOutOfBoundsException( "Cannot pad a negative amount: " + repeat );
        }
        final char[] buf = new char[repeat];
        for ( int i = 0; i < buf.length; i++ ) {
            buf[i] = padChar;
        }
        return new String( buf );
    }

    /** @param filePath the name of the file to open. Not sure if it can accept URLs or just filenames. Path handling could be better, and buffer sizes are hardcoded
     */
    public static String readFileAsString(Reader reader) {
        try {
            StringBuilder fileData = new StringBuilder( 1000 );
            char[] buf = new char[1024];
            int numRead = 0;
            while ( (numRead = reader.read( buf )) != -1 ) {
                String readData = String.valueOf( buf,
                                                  0,
                                                  numRead );
                fileData.append( readData );
                buf = new char[1024];
            }
            reader.close();
            return fileData.toString();
        } catch ( IOException e ) {
            throw new RuntimeException( e );
        }
    }
    
    /**
     * <p>Unescapes any Java literals found in the <code>String</code>.
     * For example, it will turn a sequence of <code>'\'</code> and
     * <code>'n'</code> into a newline character, unless the <code>'\'</code>
     * is preceded by another <code>'\'</code>.</p>
     * 
     * @param str  the <code>String</code> to unescape, may be null
     * @return a new unescaped <code>String</code>, <code>null</code> if null string input
     */
    public static String unescapeJava(String str) {
        if (str == null) {
            return null;
        }
        try {
            StringWriter writer = new StringWriter(str.length());
            unescapeJava(writer, str);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

    /**
     * <p>Unescapes any Java literals found in the <code>String</code> to a
     * <code>Writer</code>.</p>
     *
     * <p>For example, it will turn a sequence of <code>'\'</code> and
     * <code>'n'</code> into a newline character, unless the <code>'\'</code>
     * is preceded by another <code>'\'</code>.</p>
     * 
     * <p>A <code>null</code> string input has no effect.</p>
     * 
     * @param out  the <code>Writer</code> used to output unescaped characters
     * @param str  the <code>String</code> to unescape, may be null
     * @throws IllegalArgumentException if the Writer is <code>null</code>
     * @throws IOException if error occurs on underlying Writer
     */
    public static void unescapeJava(Writer out, String str) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
        if (str == null) {
            return;
        }
        int sz = str.length();
        StringBuilder unicode = new StringBuilder(4);
        boolean hadSlash = false;
        boolean inUnicode = false;
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);
            if (inUnicode) {
                // if in unicode, then we're reading unicode
                // values in somehow
                unicode.append(ch);
                if (unicode.length() == 4) {
                    // unicode now contains the four hex digits
                    // which represents our unicode character
                    try {
                        int value = Integer.parseInt(unicode.toString(), 16);
                        out.write((char) value);
                        unicode.setLength(0);
                        inUnicode = false;
                        hadSlash = false;
                    } catch (NumberFormatException nfe) {
                        throw new RuntimeException("Unable to parse unicode value: " + unicode, nfe);
                    }
                }
                continue;
            }
            if (hadSlash) {
                // handle an escaped value
                hadSlash = false;
                switch (ch) {
                    case '\\':
                        out.write('\\');
                        break;
                    case '\'':
                        out.write('\'');
                        break;
                    case '\"':
                        out.write('"');
                        break;
                    case 'r':
                        out.write('\r');
                        break;
                    case 'f':
                        out.write('\f');
                        break;
                    case 't':
                        out.write('\t');
                        break;
                    case 'n':
                        out.write('\n');
                        break;
                    case 'b':
                        out.write('\b');
                        break;
                    case 'u':
                        {
                            // uh-oh, we're in unicode country....
                            inUnicode = true;
                            break;
                        }
                    default :
                        out.write(ch);
                        break;
                }
                continue;
            } else if (ch == '\\') {
                hadSlash = true;
                continue;
            }
            out.write(ch);
        }
        if (hadSlash) {
            // then we're in the weird case of a \ at the end of the
            // string, let's output it anyway.
            out.write('\\');
        }
    }
    
    /**
     * Apply the given relative path to the given path,
     * assuming standard Java folder separation (i.e. "/" separators);
     * @param path the path to start from (usually a full file path)
     * @param relativePath the relative path to apply
     * (relative to the full file path above)
     * @return the full file path that results from applying the relative path
     */
    public static String applyRelativePath(String path, String relativePath) {
        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
        if (separatorIndex != -1) {
            String newPath = path.substring(0, separatorIndex);
            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
                newPath += FOLDER_SEPARATOR;
            }
            return newPath + relativePath;
        }
        else {
            return relativePath;
        }
    }

    
    private static final String FOLDER_SEPARATOR = "/";

    private static final String WINDOWS_FOLDER_SEPARATOR = "\\";

    private static final String TOP_PATH = "..";

    private static final String CURRENT_PATH = ".";


    
    /**
     * Normalize the path by suppressing sequences like "path/.." and
     * inner simple dots.
     * <p>The result is convenient for path comparison. For other uses,
     * notice that Windows separators ("\") are replaced by simple slashes.
     * @param path the original path
     * @return the normalized path
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String cleanPath(String path) {
        if (path == null) {
            return null;
        }
        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);

        // Strip prefix from path to analyze, to not treat it as part of the
        // first path element. This is necessary to correctly parse paths like
        // "file:core/../core/io/Resource.class", where the ".." should just
        // strip the first "core" directory while keeping the "file:" prefix.
        int prefixIndex = pathToUse.indexOf(":");
        String prefix = "";
        if (prefixIndex != -1) {
            prefix = pathToUse.substring(0, prefixIndex + 1);
            pathToUse = pathToUse.substring(prefixIndex + 1);
        }
        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
            prefix = prefix + FOLDER_SEPARATOR;
            pathToUse = pathToUse.substring(1);
        }

        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
        List<String> pathElements = new LinkedList<String>();
        int tops = 0;

        for (int i = pathArray.length - 1; i >= 0; i--) {
            String element = pathArray[i];
            if (CURRENT_PATH.equals(element)) {
                // Points to current directory - drop it.
            }
            else if (TOP_PATH.equals(element)) {
                // Registering top path found.
                tops++;
            }
            else {
                if (tops > 0) {
                    // Merging path element with element corresponding to top path.
                    tops--;
                }
                else {
                    // Normal path element found.
                    pathElements.add(0, element);
                }
            }
        }

        // Remaining top paths need to be retained.
        for (int i = 0; i < tops; i++) {
            pathElements.add(0, TOP_PATH);
        }

        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
    }

    /**
     * Convenience method to return a Collection as a delimited (e.g. CSV)
     * String. E.g. useful for <code>toString()</code> implementations.
     * @param coll the Collection to display
     * @param delim the delimiter to use (probably a ",")
     * @param prefix the String to start each element with
     * @param suffix the String to end each element with
     * @return the delimited String
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String collectionToDelimitedString(Collection<String> coll, String delim, String prefix, String suffix) {
        if (coll == null || coll.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        Iterator<String> it = coll.iterator();
        while (it.hasNext()) {
            sb.append(prefix).append(it.next()).append(suffix);
            if (it.hasNext()) {
                sb.append(delim);
            }
        }
        return sb.toString();
    }
    
    /**
     * Convenience method to return a Collection as a delimited (e.g. CSV)
     * String. E.g. useful for <code>toString()</code> implementations.
     * @param coll the Collection to display
     * @param delim the delimiter to use (probably a ",")
     * @return the delimited String
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String collectionToDelimitedString(Collection<String> coll, String delim) {
        return collectionToDelimitedString(coll, delim, "", "");
    }
    
    
    /**
     * Replace all occurences of a substring within a string with
     * another string.
     * @param inString String to examine
     * @param oldPattern String to replace
     * @param newPattern String to insert
     * @return a String with the replacements
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String replace(String inString, String oldPattern, String newPattern) {
        if (isEmpty(inString) || isEmpty(oldPattern) || newPattern == null) {
            return inString;
        }
        StringBuilder sbuf = new StringBuilder();
        // output StringBuilder we'll build up
        int pos = 0; // our position in the old string
        int index = inString.indexOf(oldPattern);
        // the index of an occurrence we've found, or -1
        int patLen = oldPattern.length();
        while (index >= 0) {
            sbuf.append(inString.substring(pos, index));
            sbuf.append(newPattern);
            pos = index + patLen;
            index = inString.indexOf(oldPattern, pos);
        }
        sbuf.append(inString.substring(pos));
        // remember to append any characters to the right of a match
        return sbuf.toString();
    }
    
    public static URI toURI(String location) throws URISyntaxException {
        return new URI( StringUtils.replace( location,
                                             " ",
                                             "%20" ) );
    }    
    
    /**
     * Take a String which is a delimited list and convert it to a String array.
     * <p>A single delimiter can consists of more than one character: It will still
     * be considered as single delimiter string, rather than as bunch of potential
     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.
     * @param str the input String
     * @param delimiter the delimiter between elements (this is a single delimiter,
     * rather than a bunch individual delimiter characters)
     * @return an array of the tokens in the list
     * @see #tokenizeToStringArray
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String[] delimitedListToStringArray(String str, String delimiter) {
        return delimitedListToStringArray(str, delimiter, null);
    }

    /**
     * Take a String which is a delimited list and convert it to a String array.
     * <p>A single delimiter can consists of more than one character: It will still
     * be considered as single delimiter string, rather than as bunch of potential
     * delimiter characters - in contrast to <code>tokenizeToStringArray</code>.
     * @param str the input String
     * @param delimiter the delimiter between elements (this is a single delimiter,
     * rather than a bunch individual delimiter characters)
     * @param charsToDelete a set of characters to delete. Useful for deleting unwanted
     * line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String.
     * @return an array of the tokens in the list
     * @see #tokenizeToStringArray
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
        if (str == null) {
            return new String[0];
        }
        if (delimiter == null) {
            return new String[] {str};
        }
        List<String> result = new ArrayList<String>();
        if ("".equals(delimiter)) {
            for (int i = 0; i < str.length(); i++) {
                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
            }
        }
        else {
            int pos = 0;
            int delPos = 0;
            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
                pos = delPos + delimiter.length();
            }
            if (str.length() > 0 && pos <= str.length()) {
                // Add rest of String, but not in case of empty input.
                result.add(deleteAny(str.substring(pos), charsToDelete));
            }
        }
        return toStringArray(result);
    }
    
    /**
     * Copy the given Collection into a String array.
     * The Collection must contain String elements only.
     * @param collection the Collection to copy
     * @return the String array (<code>null</code> if the passed-in
     * Collection was <code>null</code>)
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String[] toStringArray(Collection<String> collection) {
        if (collection == null) {
            return null;
        }
        return (String[]) collection.toArray(new String[collection.size()]);
    }    
    
    /**
     * Delete any character in a given String.
     * @param inString the original String
     * @param charsToDelete a set of characters to delete.
     * E.g. "az\n" will delete 'a's, 'z's and new lines.
     * @return the resulting String
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static String deleteAny(String inString, String charsToDelete) {
        if (isEmpty(inString) || isEmpty(charsToDelete)) {
            return inString;
        }
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < inString.length(); i++) {
            char c = inString.charAt(i);
            if (charsToDelete.indexOf(c) == -1) {
                out.append(c);
            }
        }
        return out.toString();
    } 
    
    
    /**
     * Delete any character in a given String.
     * @param inString the original String
     * @param charsToDelete a set of characters to delete.
     * E.g. "az\n" will delete 'a's, 'z's and new lines.
     * @return the resulting String
     * 
     * Borrowed from Spring, under the ASL2.0 license.
     */
    public static int indexOfIgnoreCase(String[] array, String s) {
    	int index = -1;
    	for(int i=0;i<array.length;i++){
    		if (array[i].equalsIgnoreCase(s)){
    			index = i;
    			break;
    		}
    	}
        return index;
    } 
}

package com.cnk.travelerp.common.persistence.util;

import java.util.Map;

public class Utils {
	/**
	 * this function will return hasmap values into object arrays.
	 * @param keyValues
	 * @param keys
	 * @return
	 */
	public static Object[] toObjects(Map<String,?> keyValues, String[] keys){
		Object[] values = new Object[keys.length];
		
		for(int i=0;i<keys.length;i++){
			Object o = keyValues.get(keys[i]);
			values[i] = o;
		}
		return values;
	}
	
	public static String[] getMappedKeys(String[] keys,String keyMapping){
		String[] mappedKeys = new String[keys.length];
		
		String[] keyS = keyMapping.split(",");
		String[] lkey = new String[keyS.length];
		String[] rkey = new String[keyS.length];
		
		for(int i=0;i<keyS.length;i++){
			String[] k1 = keyS[i].split("=");
			lkey[i] = k1[0].trim();
			rkey[i] = k1[1].trim();
		}
		
		for(int i=0;i<keys.length;i++){
			boolean found = false;
			for(int j=0;j<rkey.length;j++){
				if (keys[i].equals(rkey[j])){
					mappedKeys[i] = lkey[j];
					found = true;
					break;
				}
			}
			if (!found){
				mappedKeys[i] = keys[i];
			}
		}
		return mappedKeys;
	}


}
package org.springframework.jdbc.core;

public class NewArgPreparedStatementSetter extends ArgPreparedStatementSetter{
	public NewArgPreparedStatementSetter(Object[] args){
		super(args);
	}
}
package org.springframework.jdbc.core;

public class NewArgTypePreparedStatementSetter extends ArgTypePreparedStatementSetter{
	public NewArgTypePreparedStatementSetter(Object[] args, int[] argTypes){
		super(args,argTypes);
	}
}

TERP_CONTINENT={\"name\":\"TERP_CONTINENT\",\"targetObect\":\"TERP_CONTINENT\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_CONTINENT\",\"mainTable\":true,\"keyColumns\":[\"CONTINENT_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"keyColumns\":[\"CONTINENT_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_CONTINENT\",\"lColumnName\":\"CONTINENT_ID\",\"rTableName\":\"TERP_CONTINENT_LOCALE\",\"rColumnName\":\"CONTINENT_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"ContinentId\",\"dataType\":\"INT\",\"headerName\":\"ContinentId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT\",\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_ID\"}]},{\"name\":\"ContinentLocaleId\",\"dataType\":\"INT\",\"headerName\":\"ContinentLocalId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_LOCALE_ID\",\"aliasName\":\"CONTINENTLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"ContinentName\",\"targetName\":\"CONTINENT_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_NAME\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"aliasName\":\"CONTINENTNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"CONTINENT_ID\",\"index\":\"CONTINENT_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}

TERP_COUNTRY={\"name\":\"TERP_COUNTRY\",\"targetObect\":\"TERP_COUNTRY\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_COUNTRY\",\"mainTable\":true,\"keyColumns\":[\"COUNTRY_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"keyColumns\":[\"COUNTRY_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_COUNTRY\",\"lColumnName\":\"COUNTRY_ID\",\"rTableName\":\"TERP_COUNTRY_LOCALE\",\"rColumnName\":\"COUNTRY_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"CountryId\",\"dataType\":\"INT\",\"headerName\":\"CountryId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY\",\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_ID\"}]},{\"name\":\"CountryLocaleId\",\"dataType\":\"INT\",\"headerName\":\"CountryLocalId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_LOCALE_ID\",\"aliasName\":\"COUNTRYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CountryName\",\"targetName\":\"COUNTRY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_NAME\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"aliasName\":\"COUNTRYNAME\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"TERP_CONTINENT_LOCALE\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_COUNTRY\"}]}],\"jqGridModelProperties\":[{\"name\":\"COUNTRY_ID\",\"index\":\"COUNTRY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false}]}

TERP_STATE1={\"name\":\"TERP_STATE\",\"targetObect\":\"TERP_STATE\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_STATE\",\"mainTable\":true,\"keyColumns\":[\"STATE_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"keyColumns\":[\"STATE_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_STATE\",\"lColumnName\":\"STATE_ID\",\"rTableName\":\"TERP_STATE_LOCALE\",\"rColumnName\":\"STATE_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"StateId\",\"dataType\":\"INT\",\"headerName\":\"StateId\",\"columns\":[{\"tableName\":\"TERP_STATE\",\"columnName\":\"STATE_ID\",\"aliasName\":\"STATEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_ID\"}]},{\"name\":\"StateLocaleId\",\"dataType\":\"INT\",\"headerName\":\"StateLocaleId\",\"columns\":[{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_LOCALE_ID\",\"aliasName\":\"STATELOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_STATE_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"StateName\",\"targetName\":\"STATE_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_NAME\",\"tableName\":\"TERP_STATE_LOCALE\",\"aliasName\":\"STATENAME\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"terp_continent_locale\",\"targetAttribute\":\"ContinentId\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R2\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_STATE\"}]},{\"name\":\"CountryId\",\"targetObject\":\"terp_country_locale\",\"targetAttribute\":\"CountryId\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"COUNTRYNAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"COUNTRY_ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"TERP_STATE\"}]}],\"jqGridModelProperties\":[{\"name\":\"StateId\",\"index\":\"StateId\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"StateLocaleId\",\"index\":\"StateLocaleId\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"LocaleID\",\"index\":\"LocaleID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"StateName\",\"index\":\"StateName\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"CountryName\",\"index\":\"CountryName\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"ContinentName\",\"index"\:\"Continent\",\"hidden\":false,\"align\":\"center\",\"edittype\":\"select\",\"editrules\":\"{required:true}\",\"editable\":true}]}

TERP_ENTITY={\"name\":\"TERP_ENTITY\",\"targetObect\":\"TERP_ENTITY\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_ENTITY\",\"mainTable\":true,\"keyColumns\":[\"ENTITY_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_ENTITY_LOCALE\",\"keyColumns\":[\"ENTITY_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_ENTITY\",\"lColumnName\":\"ENTITY_ID\",\"rTableName\":\"TERP_ENTITY_LOCALE\",\"rColumnName\":\"ENTITY_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"EntityId\",\"dataType\":\"INT\",\"key\":false,\"headerName\":\"EntityId\",\"columns\":[{\"tableName\":\"TERP_ENTITY\",\"columnName\":\"ENTITY_ID\",\"aliasName\":\"ENTITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_ENTITY_LOCALE\",\"columnName\":\"ENTITY_ID\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"key\":true,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_ENTITY_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"EntityName\",\"targetName\":\"ENTITIY_LOCALE_VALUE\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Entity\",\"columns\":[{\"columnName\":\"ENTITIY_LOCALE_VALUE\",\"tableName\":\"TERP_ENTITY_LOCALE\",\"aliasName\":\"ENTITYNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"ENTITY_ID\",\"index\":\"ENTITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"ENTITIY_LOCALE_VALUE\",\"index\":\"ENTITIY_LOCALE_VALUE\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}

TERP_STATE={\"name\":\"TERP_STATE\",\"targetObect\":\"TERP_STATE\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_STATE\",\"mainTable\":true,\"keyColumns\":[\"STATE_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"keyColumns\":[\"STATE_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_STATE\",\"lColumnName\":\"STATE_ID\",\"rTableName\":\"TERP_STATE_LOCALE\",\"rColumnName\":\"STATE_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"StateId\",\"dataType\":\"INT\",\"headerName\":\"StateId\",\"columns\":[{\"tableName\":\"TERP_STATE\",\"columnName\":\"STATE_ID\",\"aliasName\":\"STATEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_ID\"}]},{\"name\":\"StateLocaleId\",\"dataType\":\"INT\",\"headerName\":\"StateLocaleId\",\"columns\":[{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_LOCALE_ID\",\"aliasName\":\"STATELOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_STATE_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"StateName\",\"targetName\":\"STATE_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_NAME\",\"tableName\":\"TERP_STATE_LOCALE\",\"aliasName\":\"STATENAME\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"terp_continent\",\"targetAttribute\":\"ContinentId\",\"targetDispAttribute\":\"ContinentName\",\"targetAliasName\":\"R2\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_STATE\"}]},{\"name\":\"CountryId\",\"targetObject\":\"terp_country\",\"targetAttribute\":\"CountryId\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"COUNTRYNAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"COUNTRY_ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"TERP_STATE\"}]}],\"jqGridModelProperties\":[{\"name\":\"StateId\",\"index\":\"StateId\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"StateLocaleId\",\"index\":\"StateLocaleId\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"LocaleID\",\"index\":\"LocaleID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"StateName\",\"index\":\"StateName\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"Country\",\"index\":\"CountryName\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"Continent\",\"index"\:\"Continent\",\"hidden\":false,\"align\":\"center\",\"edittype\":\"select\",\"editrules\":\"{required:true}\",\"editable\":true}]}

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>com.cnk.travelerpibe.common</groupId>
    <artifactId>common</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <relativePath>../pom.xml</relativePath>
  </parent>
  <artifactId>cnk-common-persist</artifactId>
  
    <dependencies>
    <!-- 
  		<dependency>
			<groupId>com.cnk.travelerpibe.common</groupId>
			<artifactId>empersist</artifactId>
			<version>${project.version}</version>
		</dependency>
		-->
		<dependency>
			<groupId>ma.glasnost.orika</groupId>
			<artifactId>orika-core</artifactId>
			<version>1.4.1</version>
		</dependency>
            
  </dependencies>

entity-persistence-service.xml:

</project>

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd ">

   <!-- Initialization for data source -->
   <bean id="dataSource" 
      class="org.springframework.jdbc.datasource.DriverManagerDataSource">
      <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
      <property name="url" value="jdbc:oracle:thin:@10.21.32.97:1521:ora11g"/>
      <property name="username" value="terp_dev"/>
      <property name="password" value="terp_dev"/>
   </bean>
   
  <!--  <bean id="dataSource" 
      class="org.springframework.jdbc.datasource.DriverManagerDataSource">
      <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
      <property name="url" value="jdbc:oracle:thin:@10.21.12.129:1521:xe"/>
      <property name="username" value="siva_master"/>
      <property name="password" value="siva_master"/>
   </bean> -->
   

   <!-- Definition for Generic DAO bean -->
   <bean id="dao" 
      class="com.cnk.travelerp.common.persistence.dao.GenericDao">
      <property name="dataSource"  ref="dataSource" />    
   </bean>
      
   
    <bean id="entityPersistentservice" 
      class="com.cnk.travelerp.common.persistence.service.EntityPersistenceContainerService">
      		 <property name="dao"  ref="dao" />   
	</bean>
   
    <bean id="masterPersistenceContainerService" 
      class="com.cnk.travelerp.common.persistence.service.MasterPersistenceContainerService">
      		 <property name="dao"  ref="dao" />   
	</bean>
   
   
</beans>


person-persistence-service.xml:


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd ">

   <!-- Initialization for data source -->
   <bean id="dataSource" 
      class="org.springframework.jdbc.datasource.DriverManagerDataSource">
      <property name="driverClassName" value="com.mckoi.JDBCDriver"/>
      <property name="url" value="jdbc:mckoi:local://D:/travelerpbranches/travelerpibe1.0/etc/mckoi.conf?create_or_boot=true"/>
      <!-- property name="url" value="jdbc:mysql://localhost:3306/TEST"/ -->
      
      
      <property name="username" value="admin_user"/>
      <property name="password" value="aupass00"/>
   </bean>

   <!-- Definition for Generic DAO bean -->
   <bean id="dao" 
      class="com.cnk.test.persist.dao.GenericDao">
      <property name="dataSource"  ref="dataSource" />    
   </bean>
      
   <bean id="BasePersistenceService" abstract="true">
		 <property name="dao"  ref="dao" />   
	</bean>
   
    <bean id="personPersistenceService" parent="BasePersistenceService"
      class="com.cnk.test.persist.service.PersonPersistenceService"/>
   
    <bean id="addressPersistenceService" parent="BasePersistenceService"
      class="com.cnk.test.persist.service.AddressPersistenceService"/>
     
   
    <bean id="MCKIOTableCreator" 
      class="com.cnk.test.persist.sql.MCKIOTableCreator">
      <constructor-arg ref="dataSource" />
   </bean>

   
</beans>

package com.cnk.travelerp.common.persistence;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;


public class DomainModelGenerator {

	private static final String spaceChar = " ";
	private static final String PRIVATE_LITTERAL = "private";
	

	private static String driverClassName  = "oracle.jdbc.driver.OracleDriver";
//	private static String url  = "jdbc:oracle:thin:@192.168.39.51:1521:DB195UAT";
	private static String url  = "jdbc:oracle:thin:@10.21.12.129:1521:xe";
	
	private static Connection con;
	
	static{
	     try {
	         Class.forName(driverClassName);
	    
	       } catch(java.lang.ClassNotFoundException e) {
	         System.err.print("ClassNotFoundException: "); 
	         System.err.println(e.getMessage());
	       }

	}
	
	private static Connection getConnection() throws Exception {
	
			if (con == null || con.isClosed()){
				con = DriverManager.getConnection(url, 
			    //            "policy_ib", "policy_ib");
//			    	      "dev_env", "dev_env");
	    	      "siva_master", "siva_master");
			}
	       return con;
	}
	

	 private static final String TABLE_NAME = "TABLE_NAME";
	 private static final String COLUMN_NAME = "COLUMN_NAME";
	 private static final String DB_DATA_TYPE = "DB_DATA_TYPE";
	 private static final String COLUMN_SIZE = "COLUMN_SIZE";
	 private static final String JAVA_ATTRIBUTE = "JAVA_ATTRIBUTE";
	 private static final String JAVA_DATA_TYPE = "JAVA_DATA_TYPE";
	 private static final String KEY_COLUMN = "KEY_COLUMN";
	 private static final String KEY_SEQ = "KEY_SEQ";
// 	 private static final String AUTO_KEY = "AUTO_KEY" ;

	
	private static Map<String,Map<String,Map<String,String>>> 
				getEntityDetail(String schmaName, String[] tables,String [] join) throws Exception{

		Connection con = getConnection();
		
		DatabaseMetaData dbMetaData = con.getMetaData();
		List<String> asList = Arrays.asList(tables);
		Map<String,Map<String,Map<String,String>>> tabDetail = new LinkedHashMap<>();

		
		
		ResultSet resultSet = dbMetaData.getTables(null, schmaName, null, new String[]{"TABLE"});
		List<String> tabList = new ArrayList<>();
		while (resultSet.next()) {
	        String tableName = resultSet.getString("TABLE_NAME");
	        tabList.add(tableName);
		}
		resultSet.close();
		
		if (!tabList.containsAll( asList ) ){
			return tabDetail;
		}

		
//		while (resultSet.next()) {
//		        String tableName = resultSet.getString("TABLE_NAME");
//		        if (!asList.contains(tableName)){
//		        	continue;
//		        }
				
	  for(String tableName:tables){
				ResultSet resultSetCols = dbMetaData.getColumns(null, schmaName, tableName, null);
				Map<String,Map<String,String>> map = new LinkedHashMap<>();
				tabDetail.put(tableName, map);
				while (resultSetCols.next()) {
					 String columnName = resultSetCols.getString("COLUMN_NAME");
					 String dataType =  SQLType.lookup( resultSetCols.getInt("DATA_TYPE")).literal();
					 String javaType =  SQLType.lookup( resultSetCols.getInt("DATA_TYPE")).javaType();
					 
					 
					 Map<String,String> detail = new HashMap<String,String>();
					 map.put( columnName, detail);
					 detail.put(TABLE_NAME , tableName);
					 detail.put(COLUMN_NAME , columnName);
					 detail.put(DB_DATA_TYPE, dataType);
					 detail.put(DB_DATA_TYPE, dataType);
					 detail.put(COLUMN_SIZE, dataType);
					 detail.put(JAVA_ATTRIBUTE, toAttribute(columnName));
					 detail.put(JAVA_DATA_TYPE, javaType);

				 }
				 resultSetCols.close();

				 resultSetCols = dbMetaData.getPrimaryKeys(null, schmaName, tableName);
				 while (resultSetCols.next()) {
					 String columnName = resultSetCols.getString("COLUMN_NAME");
					 Map<String,String> detail = map.get(columnName);
					 detail.put(KEY_COLUMN, "Yes");
					 detail.put(KEY_SEQ, resultSetCols.getString("KEY_SEQ"));
				 }
				 resultSetCols.close();
		  }
	  

	  if (tables.length>1){
		  String foreignTable = tables[0];
		  StringBuilder sb = new StringBuilder();
		  int k=0;
		  for(int i=1;i<tables.length;i++){
			  String ptable = tables[i];
			  
//			  ResultSet rs = dbMetaData.getCrossReference(null,  schmaName,  ptable, null, schmaName, foreignTable);
			  ResultSet rs = dbMetaData.getCrossReference(null,  schmaName, foreignTable, null, schmaName,ptable );
			  while(rs.next()){
				  String pcolName = rs.getString("PKCOLUMN_NAME");
				  String fcolName = rs.getString("FKCOLUMN_NAME");
				  if (k>0){
					  sb.append(", ");
				  }
				  sb.append("@Join( ");
				  sb.append("lTableName=\"").append(foreignTable).append("\",")
				  	.append("lColumnName=\"").append(pcolName).append("\",rTableName=\"").append(ptable).append("\",rColumnName=\"")
				  	.append(fcolName).append("\"");
				  sb.append(")");
//				  System.out.println("ptable:"+ptable+" PKCOLUMN_NAME"+pcolName+" foreignTable:"+foreignTable+" FKCOLUMN_NAME:"+fcolName);
				  k++;
			  }
			  rs.close();
		  }
		  if (k>1){
			  sb.insert(0, "@Joins({");
			  sb.append("})");
		  }
		  join[0] = sb.toString();
		  
	  }
		 return tabDetail;
	}
	


	
	private static String toAttribute(String columnName){
		String[] parts = columnName.split("_");
		StringBuilder sb = new StringBuilder();
		for(int i=0;i<parts.length;i++){
			String s=parts[i];
			if (i>0){
			sb.append(s.substring(0, 1).toUpperCase()).append(s.substring(1).toLowerCase());
			}
			else {
				sb.append(s.toLowerCase());
			}
		}
		return sb.toString();
	}


	private static String getTableDetail(Map<String,Map<String,Map<String,String>>> tabDetail){
		StringBuilder sb = new StringBuilder();
		String s1 = "";
		if (tabDetail.size()>1){
			sb.append("@Tables({");
			s1 = "})";
		}
		int i=0;
		List<String> ss = new ArrayList<>();
		for(String tabName:tabDetail.keySet()){
			if (i>0){
				sb.append(",");
			}
			sb.append("@Table(tableName=\"").append(tabName).append("\"");
			if (i==0){
				sb.append(",mainTable=true");
			}
			Map<String,Map<String,String>> columns = tabDetail.get(tabName);
			ss.clear();
			for(String column:columns.keySet()){
				Map<String,String> columnDetail = columns.get(column);
				if (columnDetail.get(KEY_SEQ) != null ){
					ss.add(column);
				}
			}
			if (ss.size()>0){
				sb.append(",keyColumns={");
				for(String s:ss){
					sb.append("\"").append(s).append("\"");
				}
				sb.append("}");
			}
			sb.append(")");
			i++;
		}
		
		sb.append(s1);
		
		return sb.toString();
		
	}
	
	
	private static void getColumnDetail(StringBuilder sb,List<Map<String,String>> columnDetail){
		String s1 = "";
		if (columnDetail.size()>1){
			sb.append("@Columns({");
			s1 = "})";
		}
		int i=0;
		for(Map<String,String> dbcolumn:columnDetail){
			if (i>0){
				sb.append(",");
			}
			sb.append("@Column(tableName=\"").append(dbcolumn.get(TABLE_NAME))
					.append("\",columnName=\"").append( dbcolumn.get(COLUMN_NAME)).append("\"");
			
			if (dbcolumn.get(KEY_COLUMN) != null && dbcolumn.get(KEY_COLUMN).equalsIgnoreCase("Yes")){
				sb.append(",primaryKey=true");
			}
			sb.append(")");
			i++;
		}
		
		sb.append(s1);
		sb.append("\n");
	}
	
	private static String getAttributes(Map<String,Map<String,Map<String,String>>> tabDetail){
		StringBuilder sb = new StringBuilder();
		int index=0;
		
		Map<String,List<Map<String,String>>> fields = new LinkedHashMap<>();
		Map<String,String> dataTypes = new LinkedHashMap<>();

		getFieldNames(tabDetail,fields,dataTypes);
		
		for(String fieldName:dataTypes.keySet()){
			List<Map<String,String>> columnDetail=fields.get(fieldName);
			
			getColumnDetail(sb,columnDetail);
			
			sb.append(PRIVATE_LITTERAL).append(spaceChar)
					.append( dataTypes.get(fieldName)).append(spaceChar)
						.append( fieldName).append(";\n\n");
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-1, sb.length(),"");
		}
		
		return sb.toString();
	}

	private static void getFieldNames( 
				Map<String,Map<String,Map<String,String>>> tabDetail,Map<String,
					List<Map<String,String>>> fields, 
						Map<String,String> dataTypes){
		
		
		for(Map.Entry<String, Map<String,Map<String,String>>> entry: tabDetail.entrySet()){
			Map<String,Map<String,String>> value = entry.getValue();
			for(Map.Entry<String,Map<String,String>> entry1: value.entrySet()){
				Map<String,String> value1 = entry1.getValue();
				
				String fieldName = value1.get(JAVA_ATTRIBUTE);
				String jfieldType = value1.get(JAVA_DATA_TYPE);
				
				List<Map<String,String>> dbColumns = fields.get(fieldName);
				if (dbColumns == null){
					dbColumns = new ArrayList<>();
					fields.put(fieldName, dbColumns);
				}
				dbColumns.add(value1);
				dataTypes.put(fieldName, jfieldType);
			}
		}
		
	}
	
	public static final void main(String[] args) throws Exception{
		
		String schemaName = "SIVA_MASTER";
//		String[][] tablenames = new String[][]{{"PRODUCTS"},{"CUSTOMER"},{"ORDERS","CUSTOMER"},{"ORDER_INVOICE"}};
//		String[] classNames = new String[]{"Product","Customer","Order","OrderInvoice"};

//		String[][] tablenames = new String[][]{{"CUSTOMER"},{"ADDRESS"}};
//		String[] classNames = new String[]{"Customer","Address"};

		String[][] tablenames = new String[][]{{"VCUSTOMER","VCUSTOMER_LOCALE"},{"VADDRESS","VADDRESS_LOCALE"}};
		String[] classNames = new String[]{"VCustomer","VAddress"};
		
		
		
		
		String preClass = "public class "; 

		for(int i=0;i<tablenames.length;i++){
			String[] join = new String[]{""};
			Map<String,Map<String,Map<String,String>>> tabDetail 
						= getEntityDetail(schemaName, tablenames[i],join );
			
			String tabStr = getTableDetail(tabDetail);
			System.out.println(tabStr);
			System.out.println(join[0]);
			System.out.println(preClass+classNames[i]+"{");
			String attribStr =  getAttributes(tabDetail);
			System.out.println(attribStr);
			System.out.println("}\n");
		}
		
		if (!con.isClosed()){
			con.close();
		}
	}
	

	/**
	 * 
	 * @author vishwanath.dubey
	 *
	 */
	public enum SQLType {
		TINYINT (Types.TINYINT, "TINYINT","byte[]"),
		BIGINT (Types.BIGINT, "BIGINT","long"),
		BINARY (Types.BINARY, "BINARY","byte[]"),
		BIT (Types.BIT, "BIT","Object"),
		BLOB (Types.BLOB, "BLOB","byte[]"),
		BOOLEAN (Types.BOOLEAN, "BOOLEAN","boolean"),
		CLOB (Types.CLOB, "CLOB","String"),
		DATE (Types.DATE, "DATE","Date"),
		DECIMAL (Types.DECIMAL, "DECIMAL","BigDecimal"),
		DOUBLE (Types.DOUBLE, "DOUBLE","double"),
		FLOAT (Types.FLOAT, "FLOAT","float"),
		INTEGER (Types.INTEGER, "INTEGER","int"),
		LONGVARBINARY (Types.LONGVARBINARY, "LONGVARBINARY","byte[]"),
		NULL (Types.NULL, "NULL","null"),
		NUMERIC (Types.NUMERIC, "NUMERIC","long"),
//		OTHER (Types.OTHER, "OTHER"),
		REAL (Types.REAL, "REAL","float"),
//		REF (Types.REF, "REF"),
		SMALLINT (Types.SMALLINT, "SMALLINT","int"),
//		STRUCT (Types.STRUCT, "STRUCT"),
		TIME (Types.TIME, "TIME","Date"),
		TIMESTAMP (Types.TIMESTAMP, "TIMESTAMP","Date"),
		VARBINARY (Types.VARBINARY, "VARBINARY","byte[]"),
		
		CHAR (Types.CHAR, "CHAR", "char"),
		VARCHAR (Types.VARCHAR,"VARCHAR","String"),
		VARCHAR2 (Types.VARCHAR, "VARCHAR","String"),
		LONGVARCHAR (Types.LONGVARCHAR, "LONGVARCHAR","String");
		


	    private final int type;   
	    private final String literal; 
	    private final String javaType;
	    SQLType(int type, String typeliteral,String javaType) {
	        this.type = type;
	        this.literal = typeliteral;
	        this.javaType = javaType;
	    }
	    public int type()   { return type; }
	    public String literal() { return literal; }
	    public String javaType() { return javaType; }

	    public static SQLType lookup(int type){
	    	for(SQLType sqlType:SQLType.values()){
	    		if (sqlType.type == type){
	    			return sqlType;
	    		}
	    	}
	    	return NULL;
	    		
	    }
	}
}
package com.cnk.travelerp.common.persistence;

import static junit.framework.Assert.assertTrue;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import com.cnk.travelerp.common.persistence.domain.Address;
import com.cnk.travelerp.common.persistence.domain.Customer;
import com.cnk.travelerp.common.persistence.domain.Product;
import com.cnk.travelerp.common.persistence.domain.VAddress;
import com.cnk.travelerp.common.persistence.domain.VCustomer;
import com.cnk.travelerp.common.persistence.service.EntityPersistenceContainerService;
import com.cnk.travelerp.common.persistence.service.MasterPersistenceContainerService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "entity-persistence-service.xml" })
public class EntityPersistenceServiceTest {

    @Autowired
    EntityPersistenceContainerService entityPersistentservice;

    @Autowired
    MasterPersistenceContainerService masterPersistenceContainerService;

    // @Test
    public void persist() throws Exception {

        Product product = new Product();
        product.setProdName("AIR ASIA");
        product.setProdDesc("This is AIR ASIA");
        product.setRegularPrice(100.3);
        product.setLastUpdateTime(new Date());

        assertTrue(entityPersistentservice.persist(product)); // persisting the
                                                              // person
        List<Product> listOfProduct = entityPersistentservice
                .selectAll(Product.class);
        assertTrue(listOfProduct.size() > 0); // retrieving All records
        listOfProduct = entityPersistentservice.select(product);
        assertTrue(listOfProduct.size() > 0); // retrieving specific person
    }

    // @Test
    public void persistCustomer() throws Exception {

        Customer cust = new Customer();
        cust.setFirstName("Cox And Kings");
        cust.setLastName("Mumbai");
        cust.setLastUpdateTime(new Date());
        // cust.setCustId();

        cust.setAddress(new ArrayList<Address>());

        Address addr1 = new Address();
        addr1.setAddressLine1("12344, Makawana Road");
        addr1.setAddressLine2("Off Military Road");
        addr1.setCity("Mumbai");
        addr1.setStreet("345 St");
        addr1.setLastUpdateTime(new Date());
        cust.getAddress().add(addr1);

        assertTrue(entityPersistentservice.persist(cust)); // persisting the
                                                           // person
        List<Customer> listOfCustomer = entityPersistentservice
                .selectAll(Customer.class);
        assertTrue(listOfCustomer.size() > 0); // retrieving All records
        listOfCustomer = entityPersistentservice.select(cust);
        assertTrue(listOfCustomer.size() == 1); // retrieving specific person
        Customer custNew = listOfCustomer.get(0);
        assertTrue(custNew.getCustId() == cust.getCustId());
        assertTrue(cust.getAddress().size() == custNew.getAddress().size());

        /*
         * below code is check Domain Model is not geeting loaded again and
         * again
         */
        Customer cust1 = new Customer();
        cust1.setFirstName("EzeeGo1");
        cust1.setLastName("Mumbai");
        cust1.setLastUpdateTime(new Date());

        cust1.setAddress(new ArrayList<Address>());

        Address addr2 = new Address();
        addr2.setAddressLine1("122, Makawana Road Marol");
        addr2.setAddressLine2("Off Military Road");
        addr2.setCity("Mumbai");
        addr2.setStreet("345 St");
        addr2.setLastUpdateTime(new Date());
        cust1.getAddress().add(addr2);

        assertTrue(entityPersistentservice.persist(cust1)); // persisting the
                                                            // person

    }

    // @Test
    // public void persistVCustomer() throws Exception{
    //
    // VCustomer cust = new VCustomer();
    // cust.setFirstName("Cox And Kings");
    // cust.setLastName("Mumbai");
    // cust.setLastUpdateTime(new Date());
    //
    //
    // assertTrue(entityPersistentservice.persist(cust)); //persisting the
    // person
    // List<VCustomer> list =
    // entityPersistentservice.selectAll(VCustomer.class);
    // assertTrue(list.size()>0); //retrieving All records
    // list = entityPersistentservice.select( cust );
    // assertTrue(list.size()>0); // retrieving specific person
    //
    // }

    // @Test
    public void persistVCustomer() throws Exception {
        VCustomer cust = new VCustomer();
        cust.setFirstName("Cox And Kings");
        cust.setLastName("Mumbai");
        cust.setLastUpdateTime(new Date());
        cust.setAddresses(new ArrayList<VAddress>());

        VAddress addr = new VAddress();
        addr.setAddressLine1("122, Makawana Road Marol");
        addr.setAddressLine2("Off Military Road");
        addr.setCity("Mumbai");
        addr.setStreet("345 St");
        addr.setLastUpdateTime(new Date());
        addr.setCustId(16);
        cust.getAddresses().add(addr);

        assertTrue(entityPersistentservice.persist(cust)); // persisting the
                                                           // person
        List<VCustomer> list = entityPersistentservice
                .selectAll(VCustomer.class);
        assertTrue(list.size() > 0); // retrieving All records
        list = entityPersistentservice.select(cust);
        assertTrue(list.size() > 0); // retrieving specific person
    }

    // @Test
    public void persistCityMaster() throws Exception {
        Map<String, Object> data = new HashMap<>();
        data.put("languageID", 1);
        data.put("CityName", "Mumbai");
        data.put("StateId", 41);
        data.put("StateId", 41);
        data.put("CountryId", 35);
        data.put("ContinentId", 32);

        assertTrue(masterPersistenceContainerService.persist("City", data));

        List<Map<String, ?>> records = masterPersistenceContainerService
                .select("City", data);
        assertTrue(records.size() == 1);

    }

    // @Test
    public void persistContinentMaster() throws Exception {

        Map<String, Object> data = new HashMap<>();
        // data.put("ContinentId", "19");
        data.put("ContinentName", "Australia");
        data.put("LocaleID", 62);

        masterPersistenceContainerService.persist("TERP_CONTINENT", data);

    }

    // @Test
    public void updateContinentMaster() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", "55");
        data.put("ContinentName", "North America");
        data.put("ContinentLocaleId", 56);
        data.put("LocaleID", 8);

        masterPersistenceContainerService.persist("TERP_CONTINENT", data);

    }

    // @Test
    public void selectContinent() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", "67");
        // data.put("ContinentName", "Africa");
        data.put("LocaleID", 62);

        List<Map<String, ?>> li = masterPersistenceContainerService.select(
                "TERP_CONTINENT", data);

        System.out.println(li);
    }

    // @Test
    public void selectContinentMaster() throws Exception {

        // Map<String, Object> data = new HashMap<>();
        // data.put("ContinentId", "31");
        // data.put("ContinentName", "Africa");
        // data.put("LocaleID", 8);

        List<Map<String, ?>> li = masterPersistenceContainerService
                .selectAll("TERP_CONTINENT");

        System.out.println(li);
    }

    // @Test
    public void persistCountryMaster() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", 89); // updated
        // data.put("CountryId", 41);
        data.put("CountryLocaleId", 90);
        data.put("CountryName", "Newzland"); // updated
        data.put("LocaleID", 62); // updated

        masterPersistenceContainerService.persist("TERP_COUNTRY", data);

    }

    // @Test
    public void updateCountryMaster() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", 31); // updated
        data.put("CountryId", 41);
        data.put("CountryLocaleId", 42);
        data.put("CountryName", "Australia"); // updated
        data.put("LocaleID", 5); // updated

        masterPersistenceContainerService.persist("TERP_COUNTRY", data);

    }

    // @Test
    public void selectCountryMaster() throws Exception {

        // masterPersistenceContainerService.persist("TERP_COUNTRY", data);

        List<Map<String, ?>> li = masterPersistenceContainerService
                .selectAll("TERP_COUNTRY");
        System.out.println(li);

    }

    // @Test
    public void selectCountryWithCondition() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", "65");
        data.put("LocaleID", 62);
        List<Map<String, ?>> li = masterPersistenceContainerService.select(
                "TERP_COUNTRY", data);

        System.out.println(li);
    }

    // @Test
    public void listOfEntitys() throws Exception {

        Map<String, Object> data = new HashMap<>();
        // data.put("ContinentId", 31); // updated

        data.put("LocaleID", 62); // updated

        List<Map<String, ?>> li = masterPersistenceContainerService
                .selectAll("TERP_ENTITY");
        System.out.println(li);

    }

    @Test
    public void stateMaster() throws Exception {

        Map<String, Object> data = new HashMap<>();
        data.put("ContinentId", 65); // updated
        data.put("CountryId", 87); // updated
        // data.put("CountryLocaleId", 90);
        // data.put("StateName", "Andhra Pradesh"); // updated
        // data.put("LocaleID", 62); // updated

        List<Map<String, ?>> li = masterPersistenceContainerService
                .selectByParentId("TERP_STATE1", data);

        for (Map<String, ?> map : li) {
            System.out.println(map);
        }
    }

    // @SuppressWarnings({ "rawtypes", "unchecked" })
    // @Test
    // public void queryByStateMaster() throws Exception {
    //
    // Map<String, Object> data = new HashMap<>();
    // data.put("ContinentId", 65); // updated
    // data.put("CountryId", 123); // updated
    // // data.put("CountryLocaleId", 90);
    // data.put("StateName", "TamilNadu"); // updated
    // data.put("LocaleID", 62); // updated
    //
    // masterPersistenceContainerService.queryBy("TERP_STATE", new SQLQuery(
    // data.getClass()));
    //
    // }

}
package com.cnk.travelerp.common.persistence;

public class MainTest {

	public static final void main(String[] args){
		String[] strs = new String[]{"AAAA","BBBBB"};
		Object[] objects = strs;
		
		for(int i=0;i<objects.length;i++){
			System.out.println(objects[i]);
		}
	}
}
package com.cnk.travelerp.common.persistence;

import static junit.framework.Assert.assertTrue;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import com.cnk.travelerp.common.persistence.domain.AddressTemp;
import com.cnk.travelerp.common.persistence.domain.Person2;
import com.cnk.travelerp.common.persistence.service.AddressPersistenceService;
import com.cnk.travelerp.common.persistence.service.PersonPersistenceService;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "person-persistence-service.xml" })
public class PersistenceServiceTest {

    @Autowired
    PersonPersistenceService service;

    @Autowired
    AddressPersistenceService addressService;

    @Test
    public void persist() {
        Person2 person = new Person2();
        person.setID(1233434);
        person.setFirstName("John");
        person.setLastName("Adam");
        person.setAge(23);

        assertTrue(service.persist(person)); // persisting the person
        assertTrue(service.selectAll().size() > 0); // retrieving All records
        assertTrue(service.select(person).size() > 0); // retrieving specific
                                                       // person

        AddressTemp address = new AddressTemp();
        address.setID(1233434);
        address.setAddressOne("ST 344, VILLAGE");
        address.setAddressTwo("BROOK VILL");
        address.setCity("MUMBAI");
        address.setState("MAHA");
        address.setCountry("INDIA");

        assertTrue(addressService.persist(address, person)); // persisting the
                                                             // person
        assertTrue(addressService.selectAll().size() > 0); // retrieving All
                                                           // records
        assertTrue(addressService.select(address).size() > 0); // retrieving
                                                               // specific
                                                               // person

    }

}
package com.cnk.travelerp.common.persistence;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.mckoi.database.interpret.Select;

public class TestJDBC {

	private static String driverClassName  = "oracle.jdbc.driver.OracleDriver";
//	private static String url  = "jdbc:oracle:thin:@192.168.39.51:1521:DB195UAT";
	private static String url  = "jdbc:oracle:thin:@10.21.12.129:1521:xe";
	
	private static Connection con;
	
	static{
	     try {
	         Class.forName(driverClassName);
	    
	       } catch(java.lang.ClassNotFoundException e) {
	         System.err.print("ClassNotFoundException: "); 
	         System.err.println(e.getMessage());
	       }

	}
	
	private static Connection getConnection() throws Exception {
	
			if (con == null || con.isClosed()){
				con = DriverManager.getConnection(url, 
			    //            "policy_ib", "policy_ib");
//			    	      "dev_env", "dev_env");
	    	      "siva_master", "siva_master");
			}
	       return con;
	}
	

	/*
	 * 		        
//		        TABLE_CAT String => table catalog (may be null)
//		        TABLE_SCHEM String => table schema (may be null)
//		        TABLE_NAME String => table name
//		        TABLE_TYPE String => table type. Typical types are "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM".
//		        REMARKS String => explanatory comment on the table
//		        TYPE_CAT String => the types catalog (may be null)
//		        TYPE_SCHEM String => the types schema (may be null)
//		        TYPE_NAME String => type name (may be null)
//		        SELF_REFERENCING_COL_NAME String => name of the designated "identifier" column of a typed table (may be null)
//		        REF_GENERATION
 * 
 * Columns meta info
 * # TABLE_CAT String => table catalog (may be null)
# TABLE_SCHEM String => table schema (may be null)
# TABLE_NAME String => table name
# COLUMN_NAME String => column name
# DATA_TYPE int => SQL type from java.sql.Types
# TYPE_NAME String => Data source dependent type name, for a UDT the type name is fully qualified
# COLUMN_SIZE int => column size. For char or date types this is the maximum number of characters, for numeric or decimal types this is precision.
# BUFFER_LENGTH is not used.
# DECIMAL_DIGITS int => the number of fractional digits
# NUM_PREC_RADIX int => Radix (typically either 10 or 2)
# NULLABLE int => is NULL allowed.

    * columnNoNulls - might not allow NULL values
    * columnNullable - definitely allows NULL values
    * columnNullableUnknown - nullability unknown 

# REMARKS String => comment describing column (may be null)
# COLUMN_DEF String => default value (may be null)
# SQL_DATA_TYPE int => unused
# SQL_DATETIME_SUB int => unused
# CHAR_OCTET_LENGTH int => for char types the maximum number of bytes in the column
# ORDINAL_POSITION int => index of column in table (starting at 1)
# IS_NULLABLE String => "NO" means column definitely does not allow NULL values; "YES" means the column might allow NULL values. An empty string means nobody knows.
# SCOPE_CATLOG String => catalog of table that is the scope of a reference attribute (null if DATA_TYPE isn't REF)
# SCOPE_SCHEMA String => schema of table that is the scope of a reference attribute (null if the DATA_TYPE isn't REF)
# SCOPE_TABLE String => table name that this the scope of a reference attribure (null if the DATA_TYPE isn't REF)
# SOURCE_DATA_TYPE sho

	 */
	
	
	private static final String entityStartTag = "<Entity";
	private static final String entityStartEngChar = " >";
	private static final String entityEndTag = "</Entity>";

	private static final String id = "UUID";
	private static final String name = "name";
	private static final String description = "description";
	private static final String equalSign = "=";
	private static final String spaceChar = " ";
	private static final String propertiess = "properties";
	private static final String parentid = "parentUUID";
	private static final String propertiesDef = "propertiesDef";
	private static final String propertiesValue = "propertiesVal";
	private static final String area = "area";
//	private static final String createdOn = "createdOn";
	private static final String quote = "&quot;";
	private static final String colon = ":";
	private static final String ltBrk = "{";
	private static final String rtBrk = "}";

	
	private static final String propertiesDefText = "[{&quot;colname&quot;:&quot;COLUMN_NAMECODE&quot;,&quot;headername&quot;:&quot;Column Name&quot;,&quot;datatype&quot;:&quot;String&quot;,&quot;length&quot;:&quot;200&quot;,&quot;referenciable&quot;:&quot;false&quot;,&quot;referenceUUID&quot;:null,&quot;referenceColName&quot;:null},{&quot;colname&quot;:&quot;DATA_TYPE&quot;,&quot;headername&quot;:&quot;Data Type &quot;,&quot;datatype&quot;:&quot;String&quot;,&quot;length&quot;:&quot;100&quot;,&quot;referenciable&quot;:&quot;false&quot;,&quot;referenceUUID&quot;:null,&quot;referenceColName&quot;:null},{&quot;colname&quot;:&quot;LENGTH&quot;,&quot;headername&quot;:&quot;Length &quot;,&quot;datatype&quot;:&quot;String&quot;,&quot;length&quot;:&quot;100&quot;,&quot;referenciable&quot;:&quot;false&quot;,&quot;referenceUUID&quot;:null,&quot;referenceColName&quot;:null}]";
	
	private static final String ColumnNameDef = "COLUMN_NAME";
	private static final String DataTypeDef = "DATA_TYPE";
	private static final String LengthDef = "LENGTH";

	
//	STG_CORE
//	STG_POLICY_CORE
//	STG_REINSURANCE
//	STG_GENERAL_LAIBILITY
//	STG_POLICY_HOME
//	STG_BILLING
//	STG_CLAIM

	private static void showSchemas() throws Exception{
		Connection con = getConnection();
		
		DatabaseMetaData dbMetaData = con.getMetaData();
		
		ResultSet schemasSet = dbMetaData.getSchemas();
		StringBuilder sb = new StringBuilder();
		 while (schemasSet.next()) {
		        String schemaName = schemasSet.getString("TABLE_SCHEM");
		        System.out.println(schemaName);

				sb.append(entityStartTag);
				sb.append(spaceChar);
				sb.append(id).append(equalSign).append("\"").append(schemaName.hashCode()).append("\"");
				sb.append(spaceChar);
				sb.append(name).append(equalSign).append("\"").append(schemaName).append("\"");
				sb.append(spaceChar);
				sb.append(description).append(equalSign).append("\"").append("").append("\"");
				sb.append(spaceChar);
				sb.append(parentid).append(equalSign).append("\"").append(";;parent_id;;").append("\"");
				sb.append(spaceChar);
				sb.append(area).append(equalSign).append("\"").append(";;area;;").append("\"");
				sb.append(spaceChar);
				sb.append(propertiesDef).append(equalSign).append("\"").append("").append("\"");
				sb.append(spaceChar);
				sb.append(propertiesValue).append(equalSign).append("\"").append("").append("\"");
		        
				sb.append(spaceChar);
				sb.append(propertiess).append(equalSign).append("\"").append("").append("\"");
				sb.append(entityStartEngChar);
				
				showTableMetaData(schemaName, sb);
				
				sb.append(entityEndTag);

		 }
		 schemasSet.close();
		
		 System.out.println(sb.toString());
	
	}
	
	
	private static void showSchemas1() throws Exception{
		Connection con = getConnection();
		
		DatabaseMetaData dbMetaData = con.getMetaData();
		
		ResultSet schemasSet = dbMetaData.getSchemas();
		StringBuilder sb = new StringBuilder();
		 while (schemasSet.next()) {
		        String schemaName = schemasSet.getString("TABLE_SCHEM");
		        sb.append("Schema: ").append(schemaName).append("\n");

//				sb.append(entityStartTag);
//				sb.append(spaceChar);
//				sb.append(id).append(equalSign).append("\"").append(schemaName.hashCode()).append("\"");
//				sb.append(spaceChar);
//				sb.append(name).append(equalSign).append("\"").append(schemaName).append("\"");
//				sb.append(spaceChar);
//				sb.append(description).append(equalSign).append("\"").append("").append("\"");
//				sb.append(spaceChar);
//				sb.append(parentid).append(equalSign).append("\"").append(";;parent_id;;").append("\"");
//				sb.append(spaceChar);
//				sb.append(area).append(equalSign).append("\"").append(";;area;;").append("\"");
//				sb.append(spaceChar);
//				sb.append(propertiesDef).append(equalSign).append("\"").append("").append("\"");
//				sb.append(spaceChar);
//				sb.append(propertiesValue).append(equalSign).append("\"").append("").append("\"");
//		        
//				sb.append(spaceChar);
//				sb.append(propertiess).append(equalSign).append("\"").append("").append("\"");
//				sb.append(entityStartEngChar);
//				
//				showTableMetaData1(schemaName, sb);
//				
//				sb.append(entityEndTag);

		 }
		 schemasSet.close();
		
		 System.out.println(sb.toString());
	
	}

	
	@SuppressWarnings("unused")
	private static void showMetaData() throws Exception{
		
		StringBuilder sb = new StringBuilder();
		showTableMetaData("POLICY_IB", sb);
	}
	
	private static void showTableMetaData(String schmaName,StringBuilder sb) throws Exception{
		Connection con = getConnection();
		
		DatabaseMetaData dbMetaData = con.getMetaData();
		
		ResultSet resultSet = dbMetaData.getTables(null, schmaName, null, new String[]{"TABLE"});
		//StringBuilder sb = new StringBuilder();
		
		int tabCount = 0;
		
		while (resultSet.next()) {
		        String tableName = resultSet.getString("TABLE_NAME");
//		        String tableType = resultSet.getString("TABLE_TYPE");
		        //System.out.println(tableName+ "  "+tableType);

		        
				sb.append(entityStartTag);
				sb.append(spaceChar);
				sb.append(id).append(equalSign).append("\"").append(tableName.hashCode()).append("\"");
				sb.append(spaceChar);
				sb.append(name).append(equalSign).append("\"").append(tableName).append("\"");
				sb.append(spaceChar);
				sb.append(description).append(equalSign).append("\"").append("").append("\"");
				sb.append(spaceChar);
				sb.append(parentid).append(equalSign).append("\"").append(schmaName.hashCode()).append("\"");
			//	sb.append(parentid).append(equalSign).append("\"").append(";;parent_id;;").append("\"");
				
				sb.append(spaceChar);
				sb.append(area).append(equalSign).append("\"").append(";;area;;").append("\"");
				sb.append(spaceChar);
				sb.append(propertiesDef).append(equalSign).append("\"").append(propertiesDefText).append("\"");
		        
		        StringBuilder sb1 = new StringBuilder();
		        int index =0;
		        sb1.append("[");
				ResultSet resultSetCols = dbMetaData.getColumns(null, schmaName, tableName, null);
				 while (resultSetCols.next()) {
					 
					 String columnName = resultSetCols.getString("COLUMN_NAME");
					 String dataType =  SQLType.lookup( resultSetCols.getInt("DATA_TYPE")).literal();
					 int columnLength = resultSetCols.getInt("COLUMN_SIZE");

					 sb1.append(ltBrk);
					 sb1.append(quote).append(ColumnNameDef).append(quote).append(colon);
					 sb1.append(quote).append(columnName).append(quote).append(",");
					 sb1.append(quote).append(DataTypeDef).append(quote).append(colon);
					 sb1.append(quote).append(dataType).append(quote).append(",");
					 sb1.append(quote).append(LengthDef).append(quote).append(colon);
					 sb1.append(quote).append(columnLength).append(quote);
					 
//				     System.out.println("                     "+columnName+ "  "+dataType+" "+columnLength);
				     
				     sb1.append(rtBrk).append(",");
				     index++;
				 }
				 if (index>0){
					 sb1.replace(sb1.length()-1, sb1.length(), "");
				 }
			     sb1.append("]");
				 resultSetCols.close();
				
				 sb.append(spaceChar);
				 sb.append(propertiesValue).append(equalSign).append("\"").
							append(sb1.toString()).append("\"");
		        
				sb.append(spaceChar);
				sb.append(propertiess).append(equalSign).append("\"").append("").append("\"");
				sb.append(entityStartEngChar);
				sb.append(entityEndTag);
				tabCount++;
				if (tabCount>20){
					break;
				}
		  }

		 resultSet.close();
		// con.close();
		 
		// System.out.println(sb.toString());

		
	}

	

	 private static final String COLUMN_NAME = "COLUMN_NAME";
	 private static final String DB_DATA_TYPE = "DB_DATA_TYPE";
	 private static final String COLUMN_SIZE = "COLUMN_SIZE";
	 private static final String JAVA_ATTRIBUTE = "JAVA_ATTRIBUTE";
	 private static final String JAVA_DATA_TYPE = "JAVA_DATA_TYPE";
	 private static final String KEY_COLUMN = "KEY_COLUMN";
	 private static final String KEY_SEQ = "KEY_SEQ";
 	 private static final String AUTO_KEY = "AUTO_KEY" ;

	
	private static void showTableMetaData1(String schmaName,StringBuilder sb, String[] tables) throws Exception{
		Connection con = getConnection();
		
		DatabaseMetaData dbMetaData = con.getMetaData();
		
		ResultSet resultSet = dbMetaData.getTables(null, schmaName, null, new String[]{"TABLE"});
		

		Map<String,Map<String,Map<String,String>>> tabDetail = new LinkedHashMap<>();

		
		while (resultSet.next()) {
		        String tableName = resultSet.getString("TABLE_NAME");
		        if (Arrays.binarySearch(tables,tableName) <= -1){
		        	continue;
		        }
		        
		        sb.append("\n").append(tableName).append(": \n");
				ResultSet resultSetCols = dbMetaData.getColumns(null, schmaName, tableName, null);
				Map<String,Map<String,String>> map = new LinkedHashMap<>();
		        tabDetail.put(tableName, map);
				while (resultSetCols.next()) {
					 String columnName = resultSetCols.getString("COLUMN_NAME");
					 String dataType =  SQLType.lookup( resultSetCols.getInt("DATA_TYPE")).literal();
					 String javaType =  SQLType.lookup( resultSetCols.getInt("DATA_TYPE")).javaType();
					 
					 
					 Map<String,String> detail = new HashMap<String,String>();
					 map.put( columnName, detail);
					 detail.put(COLUMN_NAME , columnName);
					 detail.put(DB_DATA_TYPE, dataType);
					 detail.put(DB_DATA_TYPE, dataType);
					 detail.put(COLUMN_SIZE, dataType);
					 detail.put(JAVA_ATTRIBUTE, toAttribute(columnName));
					 detail.put(JAVA_DATA_TYPE, javaType);

				 }
				 resultSetCols.close();

				 resultSetCols = dbMetaData.getPrimaryKeys(null, schmaName, tableName);
				 while (resultSetCols.next()) {
					 String columnName = resultSetCols.getString("COLUMN_NAME");
					 Map<String,String> detail = map.get(columnName);
					 detail.put(KEY_COLUMN, "Yes");
					 detail.put(KEY_SEQ, resultSetCols.getString("KEY_SEQ"));
					 
					 
				 }
				 resultSetCols.close();
				 String mappings = getMapping(tableName, map);
//				 String insertStatement = getInsertStatement(tableName, map);
//				 String updateStatement = getUpdateStatement(tableName, map);
//				 String selectStatement = getSelectStatement(tableName, map);
//				 String deleteStatement = getDeleteStatement(tableName, map);
//				 sb.append(insertStatement).append("\n");
//				 sb.append(updateStatement).append("\n");
//				 sb.append(selectStatement).append("\n");
//				 sb.append(deleteStatement).append("\n");
				 sb.append("\n").append(mappings).append("\n");
				 String attributes = getAttributes(tableName,map);
				 sb.append(attributes);
				 sb.append("\n");
		  }

		 resultSet.close();
	}
	
	
	private static String toAttribute(String columnName){
		String[] parts = columnName.split("_");
		StringBuilder sb = new StringBuilder();
		for(int i=0;i<parts.length;i++){
			String s=parts[i];
			if (i>0){
			sb.append(s.substring(0, 1).toUpperCase()).append(s.substring(1).toLowerCase());
			}
			else {
				sb.append(s.toLowerCase());
			}
		}
		return sb.toString();
	}
	
	private static final String INSERT_LITTERAL = "Insert ";
	private static final String UPDATE_LITTERAL = "Update ";
	private static final String SELECT_LITTERAL = "Select ";
	private static final String DELETE_LITTERAL = "Delete ";
	private static final String FROM_LITTERAL = " From ";
	private static final String WHERE_LITTERAL = " Where ";
	private static final String VALUES_LITTERAL = " Values ";
	private static final String EQUAL_LITTERAL = " = ";
	private static final String PLACE_HOLDER_LITTERAL = "? ";
	private static final String COMMA_CHAR = ", ";
	private static final String LEFT_BRACKET_LITERAL = "(";
	private static final String RIGHT_BRACKET_LITTERAL = ")";

	private static final String MAPPING_LITTERAL = "mapping";
	private static final String PRIVATE_LITTERAL = "private";
	
//	private static final String ATTRIBUTE_LITTERAL = "attribute";
//	private static final String DATABASE_LITTERAL = "db";
//	private static final String ISKEY_LITTERAL = "isKey";
//	private static final String ISAUTOSEQ_LITTERAL = "isAutoSeq";
//	private static final String COLON_LITTERAL = ":";
//	private static final String QUOTE_LITERAL = "\"";

	private static String getMapping(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		int index=0;
		sb.append(MAPPING_LITTERAL).append("=");
		for(String key:columnDetail.keySet()){
			String javaAttribute = columnDetail.get(key).get(JAVA_ATTRIBUTE);
			sb.append( javaAttribute ).append("=");
			sb.append(key);
			if (columnDetail.get(key).get(KEY_COLUMN) != null){
				sb.append("=").append("KEY");
			}
			if (columnDetail.get(key).get(AUTO_KEY) != null){
				sb.append("=").append("AUTO_KEY");
			}
			sb.append(",");
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-1, sb.length(),"");
		}

		
		return sb.toString();
	}


	private static String getAttributes(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		int index=0;
		for(String key:columnDetail.keySet()){
			sb.append(PRIVATE_LITTERAL).append(spaceChar).append( columnDetail.get(key).get(JAVA_DATA_TYPE)).append(spaceChar);
			sb.append( columnDetail.get(key).get(JAVA_ATTRIBUTE)).append(";\n");
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-1, sb.length(),"");
		}

		
		return sb.toString();
	}

	
	private static String getInsertStatement(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		sb.append(INSERT_LITTERAL).append(tableName).append(spaceChar);
		int index=0;
		sb.append( LEFT_BRACKET_LITERAL);
		for(String key:columnDetail.keySet()){
			sb.append(key).append(COMMA_CHAR);
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
		}
		sb.append( RIGHT_BRACKET_LITTERAL).append(VALUES_LITTERAL).append(LEFT_BRACKET_LITERAL);
		for(int i=0;i<index;i++){
			if (i>0){
				sb.append(COMMA_CHAR);
			}
			sb.append("?");
		}
		sb.append( RIGHT_BRACKET_LITTERAL);
		
		return sb.toString();
	}

	
	private static String getUpdateStatement(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		sb.append(UPDATE_LITTERAL).append(tableName).append(spaceChar);
		int index=0;
		List<String> keys = new ArrayList<>(5);
		for(String key:columnDetail.keySet()){
			String iskey = columnDetail.get(key).get(KEY_COLUMN);
			if (iskey != null){
				keys.add(key);
			}
			else {
				sb.append(key).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL).append(COMMA_CHAR);
			}
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
			index =0;
		}
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}
		
		return sb.toString();
	}

	
	private static String getSelectStatement(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		sb.append(SELECT_LITTERAL);
		int index=0;
		List<String> keys = new ArrayList<>(5);
		for(String key:columnDetail.keySet()){
			sb.append(key).append(COMMA_CHAR);
			String iskey = columnDetail.get(key).get(KEY_COLUMN);
			if (iskey != null){
				keys.add(key);
			}
			index++;
		}
		if (index>0){
			sb.replace(sb.length()-COMMA_CHAR.length(), sb.length(),"");
			index =0;
		}
		sb.append(FROM_LITTERAL).append(tableName).append(spaceChar);
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}
		
		return sb.toString();
	}
	
	private static String getDeleteStatement(String tableName,Map<String,Map<String,String>> columnDetail){
		StringBuilder sb = new StringBuilder();
		sb.append(DELETE_LITTERAL).append(tableName).append(spaceChar);;
//		int index=0;
		List<String> keys = new ArrayList<>(5);
		for(String key:columnDetail.keySet()){
//			sb.append(key).append(COMMA_CHAR);
			String iskey = columnDetail.get(key).get(KEY_COLUMN);
			if (iskey != null){
				keys.add(key);
			}
//			index++;
		}
//		sb.append(FROM_LITTERAL).append(tableName).append(spaceChar);
		if (keys.size() >0 ){
			sb.append(WHERE_LITTERAL);
		}
		for(String column:keys){
			sb.append(column).append(EQUAL_LITTERAL).append(PLACE_HOLDER_LITTERAL);
		}
		
		return sb.toString();
	}
//
//	STG_CORE
//	STG_POLICY_CORE
//	STG_REINSURANCE
//	STG_GENERAL_LAIBILITY
//	STG_POLICY_HOME
//	STG_BILLING
//	STG_CLAIM
//	
//	private static void showSchemas() throws Exception{
//		Connection con = getConnection();
//		
//		DatabaseMetaData dbMetaData = con.getMetaData();
//		
//		ResultSet schemasSet = dbMetaData.getSchemas();
//		 while (schemasSet.next()) {
//		        String schemaName = schemasSet.getString("TABLE_SCHEM");
//		        System.out.println(schemaName);
//		  }
//		 schemasSet.close();
//	
//	}
	
	private static void showTable(String[] tables) throws Exception{
		Connection con = getConnection();
		
		String schmaName = "SIVA_MASTER";
		DatabaseMetaData dbMetaData = con.getMetaData();
		
		
		ResultSet resultSet = dbMetaData.getTables(null, schmaName, null, new String[]{"TABLE"});
		StringBuilder sb = new StringBuilder();
		
		 while (resultSet.next()) {
		        String tableName = resultSet.getString("TABLE_NAME");
		        String tableType = resultSet.getString("TABLE_TYPE");
		        if (Arrays.binarySearch(tables,tableName) > -1){
		        	System.out.println(tableName+ " "+tableType);
		        }
		  }

		 resultSet.close();
		 //con.close();
		 
		 showTableMetaData1(schmaName, sb,tables) ;
		 
		 System.out.println(sb.toString());

		
	}
	
	
	public static final void main(String[] args) throws Exception{
		//showMetaData();
		//showSchemas1();
		
		String[] tablenames = new String[]{"PRODUCTS","CUSTOMER","ORDERS","ORDER_INVOICE"};
		showTable(tablenames);
		if (!con.isClosed()){
			con.close();
		}
	}
	
	
	public enum SQLType {
		
		
		

		TINYINT (Types.TINYINT, "TINYINT","byte[]"),
		BIGINT (Types.BIGINT, "BIGINT","long"),
		BINARY (Types.BINARY, "BINARY","byte[]"),
		BIT (Types.BIT, "BIT","Object"),
		BLOB (Types.BLOB, "BLOB","byte[]"),
		BOOLEAN (Types.BOOLEAN, "BOOLEAN","boolean"),
		CLOB (Types.CLOB, "CLOB","String"),
		DATE (Types.DATE, "DATE","Date"),
		DECIMAL (Types.DECIMAL, "DECIMAL","BigDecimal"),
		DOUBLE (Types.DOUBLE, "DOUBLE","double"),
		FLOAT (Types.FLOAT, "FLOAT","float"),
		INTEGER (Types.INTEGER, "INTEGER","int"),
		LONGVARBINARY (Types.LONGVARBINARY, "LONGVARBINARY","byte[]"),
		NULL (Types.NULL, "NULL","null"),
		NUMERIC (Types.NUMERIC, "NUMERIC","long"),
//		OTHER (Types.OTHER, "OTHER"),
		REAL (Types.REAL, "REAL","float"),
//		REF (Types.REF, "REF"),
		SMALLINT (Types.SMALLINT, "SMALLINT","int"),
//		STRUCT (Types.STRUCT, "STRUCT"),
		TIME (Types.TIME, "TIME","Date"),
		TIMESTAMP (Types.TIMESTAMP, "TIMESTAMP","Date"),
		VARBINARY (Types.VARBINARY, "VARBINARY","byte[]"),
		
		CHAR (Types.CHAR, "CHAR", "char"),
		VARCHAR (Types.VARCHAR,"VARCHAR","String"),
		VARCHAR2 (Types.VARCHAR, "VARCHAR","String"),
		LONGVARCHAR (Types.LONGVARCHAR, "LONGVARCHAR","String");
		


	    private final int type;   
	    private final String literal; 
	    private final String javaType;
	    SQLType(int type, String typeliteral,String javaType) {
	        this.type = type;
	        this.literal = typeliteral;
	        this.javaType = javaType;
	    }
	    public int type()   { return type; }
	    public String literal() { return literal; }
	    public String javaType() { return javaType; }

	    public static SQLType lookup(int type){
	    	for(SQLType sqlType:SQLType.values()){
	    		if (sqlType.type == type){
	    			return sqlType;
	    		}
	    	}
	    	return NULL;
	    		
	    }
	}


}
package com.cnk.travelerp.common.persistence.annotation.declaration;

import java.util.Map;

import org.junit.Test;
import static org.junit.Assert.*;

import com.cnk.travelerp.common.persistence.annotation.processor.DomainMappingProcessor;
import com.cnk.travelerp.common.persistence.annotation.processor.SQLGeneratorC;
import com.cnk.travelerp.common.persistence.domain.Person2;
import com.cnk.travelerp.common.persistence.domain.Person1;

public class SQLGenerationTest {

	@Test
	public void generateSQL(){
		Map<String,Map<String,String>> statements = SQLGeneratorC.generate( DomainMappingProcessor.processAnnotations(Person2.class) );
		assertTrue(statements.size() == 0);
		statements = SQLGeneratorC.generate( DomainMappingProcessor.processAnnotations(Person1.class) );
		assertTrue(statements.size() > 0);
		for(String tableName : statements.keySet()){
			assertEquals("PERSON", tableName);
		}

	}
}
package com.cnk.travelerp.common.persistence.annotation.declaration;

import static org.junit.Assert.assertTrue;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.codehaus.jackson.map.ObjectMapper;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMapping;
import com.cnk.travelerp.common.persistence.annotation.processor.DomainMappingProcessor;
import com.cnk.travelerp.common.persistence.annotation.processor.SQLStatementGenerator;
import com.cnk.travelerp.common.persistence.model.EntityDBMappingModel;
import com.cnk.travelerp.common.persistence.service.MasterPersistenceContainerService;
import com.cnk.travelerp.common.persistence.sql.CompositeStatement;
import com.cnk.travelerp.common.persistence.sql.Statement;

public class SQLStatementGenerationTest {

    static ObjectMapper objectMapper;

    @BeforeClass
    public static void init() {
        objectMapper = new ObjectMapper();
    }

    // @Test
    // public void generateSQL(){
    // DomainMapping domainMapping =
    // DomainMappingProcessor.processAnnotations(Person2.class);
    // SQLStatementGenerator.generate( domainMapping );
    // assertTrue(domainMapping.getStatements().size() == 0);
    // domainMapping = DomainMappingProcessor.processAnnotations(Person1.class);
    // SQLStatementGenerator.generate( domainMapping );
    // assertTrue(domainMapping.getStatements().size() > 0);
    //
    // domainMapping = DomainMappingProcessor.processAnnotations(Person1.class);
    // SQLStatementGenerator.generateStatment( domainMapping );
    // assertTrue(domainMapping.getStatements().size() > 0);
    //
    // DomainMapping persondomainMapping =
    // DomainMappingProcessor.processAnnotations(Person.class);
    // SQLStatementGenerator.generateStatment( persondomainMapping );
    // assertTrue(persondomainMapping.getStatements().size() > 0);
    //
    // // for(Statement statement : statements){
    // // assertEquals("PERSON", statement.sqlStatement);
    // //
    // // assertEquals(expected, actual);
    // // }
    //
    // }

    // @Test
    public void fromJsonForCity() throws Exception {

        // String jsonModelData =
        // "{\"name\":\"city_master\",\"targetObect\":\"city_master\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"city_master\",\"mainTable\":true,\"autoKey\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"city_master_locale\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"city_master\",\"lColumnName\":\"ID\",\"rTableName\":\"city_master_locale\",\"rColumnName\":\"ID\"}],\"identifiers\":[{\"tableName\":\"city_master\",\"columnName\":\"entityName\",\"value\":\"City\"}],\"attributes\":[{\"name\":\"CityId\",\"targetName\":\"CITY_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":true,\"required\":true,\"keyColSeq\":0,\"keySeq\":true,\"updateable\":false,\"headerName\":\"CityId\",\"columns\":[{\"tableName\":\"city_master\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true},{\"tableName\":\"city_master_locale\",\"columnName\":\"ID\",\"primaryKey\":true}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"city_master_locale\",\"primaryKey\":true}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"city_master_locale\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"continent_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"langauageID\",\"refColumnName\":\"langauageID\",\"refTableName\":\"city_master_locale\"}]},{\"name\":\"CountryId\",\"targetObject\":\"country_master_local\",\"targetAttribute\":\"ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"languageId\",\"refColumnName\":\"languageID\",\"refTableName\":\"city_master_locale\"}]},{\"name\":\"StateId\",\"targetObject\":\"state_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"languageId\",\"refColumnName\":\"languageID\",\"refTableName\":\"city_master_locale\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";

        String jsonModelData = "{\"name\":\"VCITY_MASTER\",\"targetObect\":\"VCITY_MASTER\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"VCITY_MASTER\",\"mainTable\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"VCITY_MASTER\",\"lColumnName\":\"ID\",\"rTableName\":\"VCITY_MASTER_LOCALE\",\"rColumnName\":\"CITY_ID\"}],\"identifiers\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ENTITY_ID\",\"value\":\"10\"}],\"attributes\":[{\"name\":\"CityId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"CityLocaleId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"ID\",\"aliasName\":\"CITYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"CONTINENT_MASTER\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"CountryId\",\"targetObject\":\"country_master_local\",\"targetAttribute\":\"ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"StateId\",\"targetObject\":\"state_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"STATE_ID\",\"refTableName\":\"VCITY_MASTER_LOCALE\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";

        EntityDBMappingModel model = objectMapper.readValue(jsonModelData,
                EntityDBMappingModel.class);
        Assert.assertNotNull(model);
        Assert.assertEquals(3, model.getReferences().size());

        List<EntityDBMappingModel.DBColumn> dbColumns = model.allColumns();

        Assert.assertTrue(dbColumns.size() > 0);

        DomainMapping persondomainMapping = DomainMappingProcessor
                .processEM(model);
        SQLStatementGenerator.generateStatment(persondomainMapping);

        assertTrue(persondomainMapping.getStatements().size() > 0);

    }

    @Test
    public void fromJsonForSampleCity() throws Exception {

        // String jsonModelData =
        // "{\"name\":\"city_master\",\"targetObect\":\"city_master\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"city_master\",\"mainTable\":true,\"autoKey\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"city_master_locale\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"city_master\",\"lColumnName\":\"ID\",\"rTableName\":\"city_master_locale\",\"rColumnName\":\"ID\"}],\"identifiers\":[{\"tableName\":\"city_master\",\"columnName\":\"entityName\",\"value\":\"City\"}],\"attributes\":[{\"name\":\"CityId\",\"targetName\":\"CITY_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":true,\"required\":true,\"keyColSeq\":0,\"keySeq\":true,\"updateable\":false,\"headerName\":\"CityId\",\"columns\":[{\"tableName\":\"city_master\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true},{\"tableName\":\"city_master_locale\",\"columnName\":\"ID\",\"primaryKey\":true}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"city_master_locale\",\"primaryKey\":true}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"city_master_locale\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"continent_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"langauageID\",\"refColumnName\":\"langauageID\",\"refTableName\":\"city_master_locale\"}]},{\"name\":\"CountryId\",\"targetObject\":\"country_master_local\",\"targetAttribute\":\"ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"languageId\",\"refColumnName\":\"languageID\",\"refTableName\":\"city_master_locale\"}]},{\"name\":\"StateId\",\"targetObject\":\"state_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"ID\",\"refTableName\":\"city_master_locale\"},{\"columnName\":\"languageId\",\"refColumnName\":\"languageID\",\"refTableName\":\"city_master_locale\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";

        // String jsonModelData =
        // "{\"name\":\"VCITY_MASTER\",\"targetObect\":\"VCITY_MASTER\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"VCITY_MASTER\",\"mainTable\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"VCITY_MASTER\",\"lColumnName\":\"ID\",\"rTableName\":\"VCITY_MASTER_LOCALE\",\"rColumnName\":\"CITY_ID\"}],\"identifiers\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ENTITY_ID\",\"value\":\"10\"}],\"attributes\":[{\"name\":\"CityId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"CityLocaleId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"ID\",\"aliasName\":\"CITYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"CONTINENT_MASTER\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"CountryId\",\"targetObject\":\"country_master_local\",\"targetAttribute\":\"ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"StateId\",\"targetObject\":\"state_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"STATE_ID\",\"refTableName\":\"VCITY_MASTER_LOCALE\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";
        // String jsonModelData =
        // "{\"name\":\"VCITY_MASTER\",\"targetObect\":\"VCITY_MASTER\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"VCITY_MASTER\",\"mainTable\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"VCITY_MASTER\",\"lColumnName\":\"ID\",\"rTableName\":\"VCITY_MASTER_LOCALE\",\"rColumnName\":\"CITY_ID\"}],\"identifiers\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ENTITY_ID\",\"value\":\"10\"}],\"attributes\":[{\"name\":\"CityId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"CityLocaleId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"ID\",\"aliasName\":\"CITYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]}],\"references\":[{\"name\":\"StateId\",\"targetObject\":\"state_master_locale\",\"targetAttribute\":\"ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"ID\",\"refColumnName\":\"STATE_ID\",\"refTableName\":\"VCITY_MASTER_LOCALE\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false}]}";

        // String jsonModelData =
        // "{\"name\":\"VCITY_MASTER\",\"targetObect\":\"VCITY_MASTER\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"VCITY_MASTER\",\"mainTable\":true,\"keyColumns\":[\"ID\"],\"aliasName\":\"A\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"keyColumns\":[\"ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"VCITY_MASTER\",\"lColumnName\":\"ID\",\"rTableName\":\"VCITY_MASTER_LOCALE\",\"rColumnName\":\"CITY_ID\"}],\"identifiers\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ENTITY_ID\",\"value\":\"10\"}],\"attributes\":[{\"name\":\"CityId\",\"dataType\":\"INT\",\"headerName\":\"City Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER\",\"columnName\":\"ID\",\"aliasName\":\"CITYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"CITY_ID\"}]},{\"name\":\"CityLocaleId\",\"dataType\":\"INT\",\"headerName\":\"CityLocal Id\",\"columns\":[{\"tableName\":\"VCITY_MASTER_LOCALE\",\"columnName\":\"ID\",\"aliasName\":\"CITYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"}]},{\"name\":\"languageID\",\"targetName\":\"LANGUAGE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LANGUAGE_ID\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CityName\",\"targetName\":\"CITY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CITY_NAME\",\"tableName\":\"VCITY_MASTER_LOCALE\",\"aliasName\":\"NAME\"}]},{\"name\":\"StateId\",\"targetName\":\"STATE_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_ID\",\"aliasName\":\"STATE_ID\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRY_ID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENT_ID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"CONTINENT_MASTER\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENT_NAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"CountryId\",\"targetObject\":\"COUNTRY_MASTER\",\"targetAttribute\":\"COUNTRY_ID\",\"targetAliasName\":\"R2\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"aliasName\":\"COUNTRY_NAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"COUNTRY_ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"VCITY_MASTER\"}]},{\"name\":\"StateId\",\"targetObject\":\"STATE_MASTER\",\"targetAttribute\":\"STATE_ID\",\"targetDispAttribute\":\"STATE_NAME\",\"targetAliasName\":\"R3\",\"aliasName\":\"STATE_NAME\",\"displayName\":\"State\",\"joincolumns\":[{\"columnName\":\"STATE_ID\",\"refColumnName\":\"STATE_ID\",\"refTableName\":\"VCITY_MASTER\"}]}],\"jqGridModelProperties\":[{\"name\":\"CITY_ID\",\"index\":\"CITY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CITY_NAME\",\"index\":\"CITY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\": true,\"align\": \"center\",\"edittype\": \"select\",\"hidden\":false}]}";

        // String jsonModelData =
        // "{\"name\":\"TERP_CONTINENT\",\"targetObect\":\"TERP_CONTINENT\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_CONTINENT\",\"mainTable\":true,\"keyColumns\":[\"CONTINENT_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"keyColumns\":[\"CONTINENT_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_CONTINENT\",\"lColumnName\":\"CONTINENT_ID\",\"rTableName\":\"TERP_CONTINENT_LOCALE\",\"rColumnName\":\"CONTINENT_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"ContinentId\",\"dataType\":\"INT\",\"headerName\":\"ContinentId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT\",\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_ID\"}]},{\"name\":\"ContinentLocaleId\",\"dataType\":\"INT\",\"headerName\":\"ContinentLocalId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_LOCALE_ID\",\"aliasName\":\"CONTINENTLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"ContinentName\",\"targetName\":\"CONTINENT_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CONTINENT_NAME\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"aliasName\":\"CONTINENTNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"CONTINENT_ID\",\"index\":\"CONTINENT_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}";

        String ss = "{\"name\":\"TERP_CONTINENT\",\"targetObect\":\"TERP_CONTINENT\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_CONTINENT\",\"mainTable\":true,\"keyColumns\":[\"CONTINENT_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"keyColumns\":[\"CONTINENT_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_CONTINENT\",\"lColumnName\":\"CONTINENT_ID\",\"rTableName\":\"TERP_CONTINENT_LOCALE\",\"rColumnName\":\"CONTINENT_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"ContinentId\",\"dataType\":\"INT\",\"headerName\":\"ContinentId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT\",\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_ID\"}]},{\"name\":\"ContinentLocaleId\",\"dataType\":\"INT\",\"headerName\":\"ContinentLocalId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_LOCALE_ID\",\"aliasName\":\"CONTINENTLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"ContinentName\",\"targetName\":\"CONTINENT_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_NAME\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"aliasName\":\"CONTINENTNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"CONTINENT_ID\",\"index\":\"CONTINENT_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}";

        // String jsonModelData =
        // "{\"name\":\"TERP_COUNTRY\",\"targetObect\":\"TERP_COUNTRY\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_COUNTRY\",\"mainTable\":true,\"keyColumns\":[\"COUNTRY_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"keyColumns\":[\"COUNTRY_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_COUNTRY\",\"lColumnName\":\"COUNTRY_ID\",\"rTableName\":\"TERP_COUNTRY_LOCALE\",\"rColumnName\":\"COUNTRY_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"CountryId\",\"dataType\":\"INT\",\"headerName\":\"CountryId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY\",\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_ID\"}]},{\"name\":\"CountryLocaleId\",\"dataType\":\"INT\",\"headerName\":\"CountryLocalId\",\"columns\":[{\"tableName\":\"TERP_COUNTRY_LOCALE\",\"columnName\":\"COUNTRY_LOCALE_ID\",\"aliasName\":\"COUNTRYLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"localeID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"CountryName\",\"targetName\":\"COUNTRY_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_NAME\",\"tableName\":\"TERP_COUNTRY_LOCALE\",\"aliasName\":\"COUNTRYNAME\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"TERP_CONTINENT_LOCALE\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_COUNTRY\"}]}],\"jqGridModelProperties\":[{\"name\":\"COUNTRY_ID\",\"index\":\"COUNTRY_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false}]}";

        // String jsonModelData =
        // "{\"name\":\"TERP_STATE\",\"targetObect\":\"TERP_STATE\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_STATE\",\"mainTable\":true,\"keyColumns\":[\"STATE_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"keyColumns\":[\"STATE_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_STATE\",\"lColumnName\":\"STATE_ID\",\"rTableName\":\"TERP_STATE_LOCALE\",\"rColumnName\":\"STATE_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"StateId\",\"dataType\":\"INT\",\"headerName\":\"StateId\",\"columns\":[{\"tableName\":\"TERP_STATE\",\"columnName\":\"STATE_ID\",\"aliasName\":\"STATEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\"},{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_ID\"}]},{\"name\":\"StateLocaleId\",\"dataType\":\"INT\",\"headerName\":\"StateLocalId\",\"columns\":[{\"tableName\":\"TERP_STATE_LOCALE\",\"columnName\":\"STATE_LOCALE_ID\",\"aliasName\":\"STATELOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"terp_seq1\",\"lookup\":\"No\"}]},{\"name\":\"localeID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_STATE_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"StateName\",\"targetName\":\"STATE_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"State\",\"columns\":[{\"columnName\":\"STATE_NAME\",\"tableName\":\"TERP_STATE_LOCALE\",\"aliasName\":\"STATENAME\"}]},{\"name\":\"CountryId\",\"targetName\":\"COUNTRY_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Country\",\"columns\":[{\"columnName\":\"COUNTRY_ID\",\"aliasName\":\"COUNTRYID\"}]},{\"name\":\"ContinentId\",\"targetName\":\"CONTINENT_ID\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"Continent\",\"columns\":[{\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\"}]}],\"references\":[{\"name\":\"ContinentId\",\"targetObject\":\"TERP_CONTINENT_LOCALE\",\"targetAttribute\":\"CONTINENT_ID\",\"targetDispAttribute\":\"CONTINENT_NAME\",\"targetAliasName\":\"R1\",\"aliasName\":\"CONTINENTNAME\",\"displayName\":\"Continent\",\"joincolumns\":[{\"columnName\":\"CONTINENT_ID\",\"refColumnName\":\"CONTINENT_ID\",\"refTableName\":\"TERP_STATE\"}]},{\"name\":\"CountryId\",\"targetObject\":\"TERP_COUNTRY_LOCALE\",\"targetAttribute\":\"COUNTRY_ID\",\"targetDispAttribute\":\"COUNTRY_NAME\",\"targetAliasName\":\"R2\",\"aliasName\":\"COUNTRYNAME\",\"displayName\":\"Country\",\"joincolumns\":[{\"columnName\":\"COUNTRY_ID\",\"refColumnName\":\"COUNTRY_ID\",\"refTableName\":\"TERP_STATE\"}]}],\"jqGridModelProperties\":[{\"name\":\"STATE_ID\",\"index\":\"STATE_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"STATE_NAME\",\"index\":\"STATE_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"COUNTRY_NAME\",\"index\":\"COUNTRY_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"select\",\"hidden\":false}]}";

        EntityDBMappingModel model = objectMapper.readValue(ss,
                EntityDBMappingModel.class);
        Assert.assertNotNull(model);
        // Assert.assertEquals(3, model.getReferences().size());

        List<EntityDBMappingModel.DBColumn> dbColumns = model.allColumns();

        Assert.assertTrue(dbColumns.size() > 0);

        DomainMapping persondomainMapping = DomainMappingProcessor
                .processEM(model);
        SQLStatementGenerator.generateStatment(persondomainMapping);

        System.out.println("statement size is"
                + persondomainMapping.getStatements().size());

        for (Statement listStaments : persondomainMapping.getStatements()) {
            System.out.println(listStaments.sqlStatement);
            if (listStaments instanceof CompositeStatement) {
                CompositeStatement compStat = (CompositeStatement) listStaments;
                for (Statement subStament : compStat.subStatements) {
                    System.out.println(subStament.sqlStatement);
                }

            }
        }

        // System.out.println("Statement is"
        // + persondomainMapping.getStatements().get(0).sqlStatement);

        assertTrue(persondomainMapping.getStatements().size() > 0);

    }

    // @Test
    public void insertMasterData() throws Exception {

        // String jsonModelData =
        // "{\"name\":\"TERP_CONTINENT\",\"targetObect\":\"TERP_CONTINENT\",\"targetType\":\"DB\",\"path\":\"\",\"tables\":[{\"tableName\":\"TERP_CONTINENT\",\"mainTable\":true,\"keyColumns\":[\"CONTINENT_ID\"],\"aliasName\":\"A\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"keyColumns\":[\"CONTINENT_LOCALE_ID\"],\"aliasName\":\"B\"}],\"joins\":[{\"lTableName\":\"TERP_CONTINENT\",\"lColumnName\":\"CONTINENT_ID\",\"rTableName\":\"TERP_CONTINENT_LOCALE\",\"rColumnName\":\"CONTINENT_ID\"}],\"identifiers\":[],\"attributes\":[{\"name\":\"ContinentId\",\"dataType\":\"INT\",\"headerName\":\"ContinentId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT\",\"columnName\":\"CONTINENT_ID\",\"aliasName\":\"CONTINENTID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcityid_seq\"},{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_ID\"}]},{\"name\":\"ContinentLocaleId\",\"dataType\":\"INT\",\"headerName\":\"ContinentLocalId\",\"columns\":[{\"tableName\":\"TERP_CONTINENT_LOCALE\",\"columnName\":\"CONTINENT_LOCALE_ID\",\"aliasName\":\"CONTINENTLOCALEID\",\"primaryKey\":true,\"autoGenerated\":true,\"generatedKey\":\"Sequence\",\"seq\":\"vcitylocaleid_seq\",\"lookup\":\"No\"}]},{\"name\":\"LocaleID\",\"targetName\":\"LOCALE_ID\",\"dataType\":\"INT\",\"orderNo\":0,\"defaultValue\":\"\",\"required\":true,\"updateable\":false,\"key\":true,\"keyColSeq\":0,\"keySeq\":true,\"headerName\":\"language\",\"columns\":[{\"columnName\":\"LOCALE_ID\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"lookup\":\"Yes\"}]},{\"name\":\"ContinentName\",\"targetName\":\"CONTINENT_NAME\",\"dataType\":\"VARCHAR\",\"orderNo\":0,\"defaultValue\":\"\",\"key\":false,\"required\":true,\"keyColSeq\":0,\"updateable\":true,\"headerName\":\"City\",\"columns\":[{\"columnName\":\"CONTINENT_NAME\",\"tableName\":\"TERP_CONTINENT_LOCALE\",\"aliasName\":\"CONTINENTNAME\"}]}],\"references\":[],\"jqGridModelProperties\":[{\"name\":\"CONTINENT_ID\",\"index\":\"CONTINENT_ID\",\"editrules\":\"\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":true},{\"name\":\"CONTINENT_NAME\",\"index\":\"CONTINENT_NAME\",\"editrules\":\"{required:true}\",\"editable\":true,\"align\":\"center\",\"edittype\":\"\",\"hidden\":false}]}";
        //
        // EntityDBMappingModel model = objectMapper.readValue(jsonModelData,
        // EntityDBMappingModel.class);
        // Assert.assertNotNull(model);
        //
        // List<EntityDBMappingModel.DBColumn> dbColumns = model.allColumns();
        //
        // Assert.assertTrue(dbColumns.size() > 0);
        //
        // DomainMappingProcessor.processEM(model);

        Map<String, String> data = new HashMap<>();
        data.put("ContinentId", "1");
        data.put("ContinentName", "india");
        data.put("LocaleID", "en");

        MasterPersistenceContainerService m = new MasterPersistenceContainerService();
        m.persist("TERP_CONTINENT", data);

    }

}
package com.cnk.travelerp.common.persistence.sql;

import java.io.File;
import java.sql.Connection;
//import java.sql.DriverManager;
import java.util.Properties;

import junit.framework.Assert;

import org.junit.Test;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import com.cnk.travelerp.common.persistence.io.ClassPathResource;
import com.cnk.travelerp.common.persistence.io.Resource;

//import com.cnk.travelerpibe.common.persistence.io.ClassPathResource;
//import com.cnk.travelerpibe.common.persistence.io.Resource;

public class JDBCConnection {
	public static  DriverManagerDataSource dataSource;
	public static boolean isLocalDB;
	private static String purl = "jdbc:mckoi:local://REPLACE_URL/target/test-classes/mckoi.conf?create_or_boot=true"; 

	
	static {
		try {
			
			
			
//		    DriverManagerDataSource dataSource = new DriverManagerDataSource();
//		    dataSource.setDriverClassName("org.apache.derby.jdbc.EmbeddedDriver");
//		    dataSource.setUrl("jdbc:derby:c:\\temp\\database\\test01;create=true");
//		    dataSource.setUsername("");
//		    dataSource.setPassword("");

		
			File file = new File("./mckoi.conf");
			String dirPath = file.getParentFile().getAbsolutePath();
			dirPath = dirPath.replaceAll("\\\\", "/");
			dirPath = dirPath.replace("/.", "");
			purl = purl.replaceAll("REPLACE_URL", dirPath);
			Resource resource = new ClassPathResource("dbConf.properties", JDBCConnection.class.getClassLoader());
			Properties properties = new Properties();
			properties.load(resource.getInputStream());

			Class.forName( properties.getProperty("driver") );
//	        String url = properties.getProperty("url");
	        String usr = properties.getProperty("user");
	        String pwd = properties.getProperty("password");
//	        connection = DriverManager.getConnection(purl, usr, pwd);
	        isLocalDB = Boolean.valueOf( properties.getProperty("isLocalDB") );
	        
	        
	        
		    dataSource = new DriverManagerDataSource();
		    dataSource.setDriverClassName( properties.getProperty("driver") );
		    dataSource.setUrl( purl );
		    dataSource.setUsername( usr );
		    dataSource.setPassword( pwd );
		    
		    
			String[] dropTables =  {"DROP TABLE IF EXISTS PERSON"	};
			
			String[] 	createString = {
					"CREATE TABLE PERSON( FIRSTNAME VARCHAR(20) NOT NULL, LASTNAME VARCHAR(20) NOT NULL)"
			};

			java.sql.Statement stmt=null ;
			try{
				Connection con = dataSource.getConnection();
				stmt = con.createStatement();
				for(String dropTable:dropTables){
					stmt.executeUpdate(dropTable);
				}
				
//				try {
//					stmt = con.createStatement();
					for(String createTable:createString){
						stmt.executeUpdate(createTable);
					}
//
//				}
					
			} catch (Exception e) {
				throw new RuntimeException("Error occured during initializing the connection",e);
			}
			finally {
				if (stmt != null ){
					stmt.close();
				}
				
			}
		} catch(Exception e){
			throw new RuntimeException("Error occured during initializing JDBCConnection",e);
		}
		
	}
	
	@Test
	public void connection(){
		Assert.assertNotNull( dataSource );
		
	}
}
package com.cnk.travelerp.common.persistence.sql;

import java.sql.Connection;
import java.sql.SQLException;

import org.springframework.jdbc.datasource.DriverManagerDataSource;

public class MCKIOTableCreator {
	private static String[] dropTables =  {"DROP TABLE IF EXISTS ADDRESS","DROP TABLE IF EXISTS PERSON"	};
	
	private static String[] 	createString = {
			"CREATE TABLE IF NOT EXISTS PERSON( ID INTEGER NOT NULL, FIRSTNAME VARCHAR(20) NOT NULL, LASTNAME VARCHAR(20) NOT NULL,AGE INTEGER NOT NULL, CONSTRAINT PERSON_PK PRIMARY KEY (ID))",
			"CREATE TABLE IF NOT EXISTS ADDRESS( ID INTEGER NOT NULL, PERSON_ID INTEGER NOT NULL, ADDRESS_ONE VARCHAR(100) NOT NULL, ADDRESS_TWO VARCHAR(100), CITY VARCHAR(50), STATE VARCHAR(50), COUNTRY VARCHAR(50), ZIP_CODE VARCHAR(10), CONSTRAINT ADDRESS_PK PRIMARY KEY (ID), FOREIGN KEY ( PERSON_ID ) REFERENCES PERSON ( ID ) )",
	};
	
	
	public MCKIOTableCreator(DriverManagerDataSource dataSource){
		java.sql.Statement stmt=null ;
		try{
			Connection con = dataSource.getConnection();
			stmt = con.createStatement();
		} catch (SQLException e) {
			throw new RuntimeException("Error occured during initializing the connection.",e);
		}

		try{
			for(String dropTable:dropTables){
				stmt.executeUpdate(dropTable);
			}
		} catch (SQLException e) {
			throw new RuntimeException("Error occured during initializing the connection.",e);
		}
			
		try {
			for(String createTable:createString){
				stmt.executeUpdate(createTable);
			}
		} catch (SQLException e) {
			throw new RuntimeException("Error occured during creating table.",e);
		}
		finally {
			if (stmt != null ){
				try{
					stmt.close();
				} catch(SQLException ee){
					throw new RuntimeException("Error occured during closing statement.",ee);
				}
			}
			
		}
	} 



}
package com.cnk.travelerp.common.persistence.service;


import java.util.HashMap;
import java.util.List;

import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

import com.cnk.travelerp.common.persistence.springmapper.DomainRowMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapBeanMapper;
import com.cnk.travelerp.common.persistence.springmapper.HashMapResultSetExtractor;
import com.cnk.travelerp.common.persistence.springmapper.MapperResultSetExtractor;
import com.cnk.travelerp.common.persistence.util.Utils;
import com.cnk.travelerp.common.persistence.domain.AddressTemp;
import com.cnk.travelerp.common.persistence.domain.Person2;



public class AddressPersistenceService extends AbstractPersistService{

	private static final String local_mapper = "mapper";
	private static final String insert_statement = "statement.insert";
	private static final String insert_params = "statement.insert.params";
	private static final String select_All_statement = "statement.selectAll";
	private static final String select_A_record = "statement.select";
	private static final String select_A_param = "statement.select.params";
	private static final String select_Row_map = "statement.rowMap";
	


	
	protected final HashMapBeanMapper<AddressTemp> mapper ; //mapper would be part of it.
	private RowMapper<AddressTemp> rowMapper;
	public AddressPersistenceService() throws Exception{
		super();
		mapper = new HashMapBeanMapper<AddressTemp>( valueOf( local_mapper ),AddressTemp.class);
		ResultSetExtractor<AddressTemp> extractor = new MapperResultSetExtractor<AddressTemp>(
				new HashMapResultSetExtractor(valueOf( select_Row_map ) ),
				mapper, AddressTemp.class	);
		rowMapper = new DomainRowMapper<AddressTemp>(extractor);
		
	}
	
	
	public boolean persist(AddressTemp address,Person2 person){
		@SuppressWarnings("unchecked")
		HashMap<String,Object> map = mapper.map(address, HashMap.class);
		map.put("personID", person.getID());

		dao.create( valueOf( insert_statement ),
				Utils.toObjects(map, valueOf( insert_params).split(",")) );
		
		return true;
	}

	public List<AddressTemp> select(AddressTemp address){
		@SuppressWarnings("unchecked")
		HashMap<String,?> map = mapper.map(address, HashMap.class);
		return  dao.select(  valueOf( select_A_record ) , 
				Utils.toObjects(map, valueOf( select_A_param ).split(",")),
				rowMapper);
	}

	
	public List<AddressTemp> selectAll(){
		return  dao.selectAll( valueOf(select_All_statement), rowMapper);
	}
	
}
package com.cnk.travelerp.common.persistence.service;


import java.util.List;

import com.cnk.travelerp.common.persistence.domain.Person2;



public class PersonPersistenceService extends AbstractPersistService{

	private DomainPersistenceService<Person2> persitenceService;

	public PersonPersistenceService() throws Exception{
		init();
		persitenceService = new DomainPersistenceService<>(properties,Person2.class); 
		
	}
	

	
	public boolean persist(Person2 person){
		return persitenceService.persist(person);
	}

	public List<Person2> select(Person2 person){
		return persitenceService.select(person);

	}

	
	public List<Person2> selectAll(){
		return persitenceService.selectAll();
	}
	
}
package com.cnk.travelerp.common.persistence.domain;

import java.util.Date;

import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;

@Table(tableName="ADDRESS",mainTable=true,keyColumns={"ADDRESS_ID"})

public class Address{
	@Column(tableName="ADDRESS",columnName="ADDRESS_ID",primaryKey=true,autoGenerated=true,generatedType=GeneratedType.Sequence,seq="addressid_seq")
	private long addressId = -1;

	@Column(tableName="ADDRESS",columnName="CUST_ID")
	private long custId;

	@Column(tableName="ADDRESS",columnName="ADDRESS_LINE1")
	private String addressLine1;

	@Column(tableName="ADDRESS",columnName="ADDRESS_LINE2")
	private String addressLine2;

	@Column(tableName="ADDRESS",columnName="STREET")
	private String street;

	@Column(tableName="ADDRESS",columnName="CITY")
	private String city;

	@Column(tableName="ADDRESS",columnName="LAST_UPDATE_TIME")
	private Date lastUpdateTime;
	
	@ManyToOne
	@JoinColumn(name="custId",referencedColumnName="custId")
	private Customer customer;
	
	public long getAddressId() {
		return addressId;
	}

	public void setAddressId(long addressId) {
		this.addressId = addressId;
	}

	public long getCustId() {
		return custId;
	}

	public void setCustId(long custId) {
		this.custId = custId;
	}

	public String getAddressLine1() {
		return addressLine1;
	}

	public void setAddressLine1(String addressLine1) {
		this.addressLine1 = addressLine1;
	}

	public String getAddressLine2() {
		return addressLine2;
	}

	public void setAddressLine2(String addressLine2) {
		this.addressLine2 = addressLine2;
	}

	public String getStreet() {
		return street;
	}

	public void setStreet(String street) {
		this.street = street;
	}

	public String getCity() {
		return city;
	}

	public void setCity(String city) {
		this.city = city;
	}

	public Date getLastUpdateTime() {
		return lastUpdateTime;
	}

	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}

	public Customer getCustomer() {
		return customer;
	}

	public void setCustomer(Customer customer) {
		this.customer = customer;
	}

	
	
	
	
}
package com.cnk.travelerp.common.persistence.domain;

import java.util.Date;
import java.util.List;

import javax.persistence.OneToMany;

import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;

@Table(tableName="CUSTOMER",mainTable=true,keyColumns={"CUST_ID"})

public class Customer{
	@Column(tableName="CUSTOMER",columnName="CUST_ID",primaryKey=true,autoGenerated=true,generatedType=GeneratedType.Sequence,seq="custid_seq")
	private long custId = -1;

	@Column(tableName="CUSTOMER",columnName="FIRST_NAME")
	private String firstName;

	@Column(tableName="CUSTOMER",columnName="LAST_NAME")
	private String lastName;

	@Column(tableName="CUSTOMER",columnName="LAST_UPDATE_TIME")
	private Date lastUpdateTime;
	
	
	@OneToMany(mappedBy="customer",targetEntity=Address.class)
	private List<Address> address;

	public long getCustId() {
		return custId;
	}

	public void setCustId(long custId) {
		this.custId = custId;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public Date getLastUpdateTime() {
		return lastUpdateTime;
	}

	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}

	public List<Address> getAddress() {
		return address;
	}

	public void setAddress(List<Address> address) {
		this.address = address;
	}
	
	

}

package com.cnk.travelerp.common.persistence.domain;


import java.util.Date;

import com.cnk.travelerp.common.persistence.annotation.declaration.Columns;
import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.Join;
import com.cnk.travelerp.common.persistence.annotation.declaration.Joins;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;
import com.cnk.travelerp.common.persistence.annotation.declaration.Tables;

@Tables({@Table(tableName="PERSON",mainTable=true,autoKey=true,keyColumns="ID"),
	     @Table(tableName="PERSON_LOCALE",keyColumns={"ID","LOCALE_ID"})})

@Joins({@Join(lTableName="PERSON",lColumnName="ID",rTableName="PERSON_LOCALE",rColumnName="ID")})
public class Person {

	@Columns({@Column(tableName="PERSON",columnName="ID",primaryKey=true,autoGenerated=true,aliasName="id"),
			  @Column(tableName="PERSON_LOCALE",columnName="ID",primaryKey=true)})
	private long ID;
	
	@Columns({@Column(tableName="PERSON_LOCALE",columnName="FIRST_NAME")})
	private String firstName; 
	
	@Columns({@Column(tableName="PERSON_LOCALE",columnName="LAST_NAME")})
	private String lastName;

	@Columns({@Column(tableName="PERSON",columnName="DATE_OF_BIRTH")})
	private Date dateOfBirth; 

	@Columns({@Column(tableName="PERSON",columnName="EMAIL")})
	private String email; 

	@Columns({@Column(tableName="PERSON",columnName="USER_ID")})
	private String userName; 

	
	@Columns({@Column(tableName="PERSON_LOCALE",columnName="LOCALE_ID",primaryKey=true)})
	private long localeID;

	public long getID() {
		return ID;
	}

	public void setID(long iD) {
		ID = iD;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	/**
	 * @return the dateOfBirth
	 */
	public Date getDateOfBirth() {
		return dateOfBirth;
	}

	/**
	 * @param dateOfBirth the dateOfBirth to set
	 */
	public void setDateOfBirth(Date dateOfBirth) {
		this.dateOfBirth = dateOfBirth;
	}

	/**
	 * @return the email
	 */
	public String getEmail() {
		return email;
	}

	/**
	 * @param email the email to set
	 */
	public void setEmail(String email) {
		this.email = email;
	}

	/**
	 * @return the userName
	 */
	public String getUserName() {
		return userName;
	}

	/**
	 * @param userName the userName to set
	 */
	public void setUserName(String userName) {
		this.userName = userName;
	}

	/**
	 * @return the localeID
	 */
	public long getLocaleID() {
		return localeID;
	}

	/**
	 * @param localeID the localeID to set
	 */
	public void setLocaleID(long localeID) {
		this.localeID = localeID;
	}
	
	
	

}

package com.cnk.travelerp.common.persistence.domain;

import java.util.Date;
import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;

@Table(tableName="PRODUCTS",mainTable=true,autoKey=true,keyColumns={"PROD_ID"})
public class Product{
	@Column(tableName="PRODUCTS",columnName="PROD_ID",primaryKey=true,autoGenerated=true,generatedType=GeneratedType.Sequence ,seq="prodid_seq")
	private long prodId;

	@Column(tableName="PRODUCTS",columnName="PROD_NAME")
	private String prodName;

	@Column(tableName="PRODUCTS",columnName="PROD_DESC")
	private String prodDesc;

	@Column(tableName="PRODUCTS",columnName="REGULAR_PRICE")
	private double regularPrice;

	@Column(tableName="PRODUCTS",columnName="LAST_UPDATE_TIME")
	private Date lastUpdateTime;

	/**
	 * @return the prodId
	 */
	public long getProdId() {
		return prodId;
	}

	/**
	 * @param prodId the prodId to set
	 */
	public void setProdId(long prodId) {
		this.prodId = prodId;
	}

	/**
	 * @return the prodName
	 */
	public String getProdName() {
		return prodName;
	}

	/**
	 * @param prodName the prodName to set
	 */
	public void setProdName(String prodName) {
		this.prodName = prodName;
	}

	/**
	 * @return the prodDesc
	 */
	public String getProdDesc() {
		return prodDesc;
	}

	/**
	 * @param prodDesc the prodDesc to set
	 */
	public void setProdDesc(String prodDesc) {
		this.prodDesc = prodDesc;
	}

	/**
	 * @return the regularPrice
	 */
	public double getRegularPrice() {
		return regularPrice;
	}

	/**
	 * @param regularPrice the regularPrice to set
	 */
	public void setRegularPrice(double regularPrice) {
		this.regularPrice = regularPrice;
	}

	/**
	 * @return the lastUpdateTime
	 */
	public Date getLastUpdateTime() {
		return lastUpdateTime;
	}

	/**
	 * @param lastUpdateTime the lastUpdateTime to set
	 */
	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}




}
package com.cnk.travelerp.common.persistence.domain;

import java.util.Date;

import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.Columns;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Join;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;
import com.cnk.travelerp.common.persistence.annotation.declaration.Tables;

@Tables({@Table(tableName="VADDRESS",mainTable=true,keyColumns={"ID"}),@Table(tableName="VADDRESS_LOCALE",keyColumns={"ID"})})
@Join( lTableName="VADDRESS",lColumnName="ID",rTableName="VADDRESS_LOCALE",rColumnName="ADDRESS_ID")
public class VAddress{
	@Columns({@Column(tableName="VADDRESS",columnName="ID",primaryKey=true,
			autoGenerated=true,generatedType=GeneratedType.Sequence,seq="vaddressid_seq"),
			@Column(tableName="VADDRESS_LOCALE",columnName="ADDRESS_ID")})
	private long id;

	@Column(tableName="VADDRESS_LOCALE",columnName="ID",primaryKey=true,
			autoGenerated=true,generatedType=GeneratedType.Sequence,seq="vaddressidlocaleid_seq",lookup="No")
	private long addrId;

	@Column(tableName="VADDRESS",columnName="CUST_ID")
	private long custId;

	@Columns({@Column(tableName="VADDRESS",columnName="LAST_UPDATE_TIME"),
			 @Column(tableName="VADDRESS_LOCALE",columnName="LAST_UPDATE_TIME")})
	private Date lastUpdateTime;

	@Column(tableName="VADDRESS_LOCALE",columnName="LANGUAGE_ID",lookup="Yes")
	private long languageId=1;

	@Column(tableName="VADDRESS_LOCALE",columnName="ADDRESS_LINE1")
	private String addressLine1;

	@Column(tableName="VADDRESS_LOCALE",columnName="ADDRESS_LINE2")
	private String addressLine2;

	@Column(tableName="VADDRESS_LOCALE",columnName="STREET")
	private String street;

	@Column(tableName="VADDRESS_LOCALE",columnName="CITY")
	private String city;
	
	
	@ManyToOne
	@JoinColumn(name="custId",referencedColumnName="id")
	private Customer customer;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public long getAddrId() {
		return addrId;
	}

	public void setAddrId(long addrId) {
		this.addrId = addrId;
	}

	public long getCustId() {
		return custId;
	}

	public void setCustId(long custId) {
		this.custId = custId;
	}

	public Date getLastUpdateTime() {
		return lastUpdateTime;
	}

	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}

	public long getLanguageId() {
		return languageId;
	}

	public void setLanguageId(long languageId) {
		this.languageId = languageId;
	}

	public String getAddressLine1() {
		return addressLine1;
	}

	public void setAddressLine1(String addressLine1) {
		this.addressLine1 = addressLine1;
	}

	public String getAddressLine2() {
		return addressLine2;
	}

	public void setAddressLine2(String addressLine2) {
		this.addressLine2 = addressLine2;
	}

	public String getStreet() {
		return street;
	}

	public void setStreet(String street) {
		this.street = street;
	}

	public String getCity() {
		return city;
	}

	public void setCity(String city) {
		this.city = city;
	}

	public Customer getCustomer() {
		return customer;
	}

	public void setCustomer(Customer customer) {
		this.customer = customer;
	}



}
package com.cnk.travelerp.common.persistence.domain;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.OneToMany;

import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.Columns;
import com.cnk.travelerp.common.persistence.annotation.declaration.GeneratedType;
import com.cnk.travelerp.common.persistence.annotation.declaration.Join;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;
import com.cnk.travelerp.common.persistence.annotation.declaration.Tables;

@Tables({@Table(tableName="VCUSTOMER",mainTable=true,keyColumns={"ID"}),
		@Table(tableName="VCUSTOMER_LOCALE",keyColumns={"ID"})})

@Join( lTableName="VCUSTOMER",lColumnName="ID",rTableName="VCUSTOMER_LOCALE",rColumnName="CUST_ID")
public class VCustomer{
	@Columns({@Column(tableName="VCUSTOMER",columnName="ID",primaryKey=true,
				autoGenerated=true,generatedType=GeneratedType.Sequence,seq="vcustid_seq"),
			 @Column(tableName="VCUSTOMER_LOCALE",columnName="CUST_ID")})
	private long id;

	@Column(tableName="VCUSTOMER_LOCALE",columnName="ID",
			primaryKey=true,autoGenerated=true,generatedType=GeneratedType.Sequence,seq="vcustlocaleid_seq",lookup="No")
	private long addrid;

	@Columns({@Column(tableName="VCUSTOMER",columnName="LAST_UPDATE_TIME"),@Column(tableName="VCUSTOMER_LOCALE",columnName="LAST_UPDATE_TIME")})
	private Date lastUpdateTime;

	@Column(tableName="VCUSTOMER_LOCALE",columnName="LANGUAGE_ID",lookup="Yes")
	private long languageId=1;

	@Column(tableName="VCUSTOMER_LOCALE",columnName="FIRST_NAME")
	private String firstName;

	@Column(tableName="VCUSTOMER_LOCALE",columnName="LAST_NAME")
	private String lastName;
	
	
	@OneToMany(mappedBy="customer", targetEntity=VAddress.class)
	List<VAddress> addresses = new ArrayList<>();

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public Date getLastUpdateTime() {
		return lastUpdateTime;
	}

	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}

//	public long getCustId() {
//		return custId;
//	}
//
//	public void setCustId(long custId) {
//		this.custId = custId;
//	}

	public long getLanguageId() {
		return languageId;
	}

	public void setLanguageId(long languageId) {
		this.languageId = languageId;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public long getAddrid() {
		return addrid;
	}

	public void setAddrid(long addrid) {
		this.addrid = addrid;
	}

	public List<VAddress> getAddresses() {
		return addresses;
	}

	public void setAddresses(List<VAddress> addresses) {
		this.addresses = addresses;
	}

	
}
package com.cnk.travelerp.common.persistence.domain;

import java.io.Serializable;

@SuppressWarnings("serial")
public class AddressTemp implements Serializable {

	  
	  private int ID;
	  private String addressOne;
	  private String addressTwo;
	  private String city;
	  private String state;
	  private String country;
	  private String zipCode;
	public int getID() {
		return ID;
	}
	public void setID(int iD) {
		ID = iD;
	}
	public String getAddressOne() {
		return addressOne;
	}
	public void setAddressOne(String addressOne) {
		this.addressOne = addressOne;
	}
	public String getAddressTwo() {
		return addressTwo;
	}
	public void setAddressTwo(String addressTwo) {
		this.addressTwo = addressTwo;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public String getState() {
		return state;
	}
	public void setState(String state) {
		this.state = state;
	}
	public String getCountry() {
		return country;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public String getZipCode() {
		return zipCode;
	}
	public void setZipCode(String zipCode) {
		this.zipCode = zipCode;
	}
	

	  
	
}
package com.cnk.travelerp.common.persistence.domain;


import com.cnk.travelerp.common.persistence.annotation.declaration.Column;
import com.cnk.travelerp.common.persistence.annotation.declaration.Columns;
import com.cnk.travelerp.common.persistence.annotation.declaration.Table;
import com.cnk.travelerp.common.persistence.annotation.declaration.Tables;


@Tables({@Table(tableName="PERSON",mainTable=true,autoKey=true,keyColumns="ID")})
//@Tables(tables={"tableName=PERSON,autoKey=true,keyColumns=ID"})
public class Person1 {

	@Columns({@Column(tableName="PERSON",columnName="ID",primaryKey=true,autoGenerated=true,aliasName="id")})
//	@Columns(columns={"tableName=PERSON,columnName=ID,primaryKey=true,autoGenerated=true,aliasName=id"})
	private long ID;
	
	@Columns({@Column(tableName="PERSON",columnName="FIRST_NAME")})
//	@Columns(columns={"tableName=PERSON,columnName=FIRST_NAME"})
	private String firstName; 
	
	@Columns({@Column(tableName="PERSON",columnName="LAST_NAME")})
//	@Columns(columns={"tableName=PERSON,columnName=LAST_NAME"})
	private String lastName;

	public long getID() {
		return ID;
	}

	public void setID(long iD) {
		ID = iD;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	
	
	

}

package com.cnk.travelerp.common.persistence.domain;

import java.io.Serializable;

@SuppressWarnings("serial")
public class Person2 implements Serializable {

	private int ID;
	private String firstName;
	private String lastName;
	private int age;

	private AddressTemp localAddress;

	public int getID() {
		return ID;
	}

	public void setID(int iD) {
		ID = iD;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getFirstName() {
	    return firstName;
	  }

	  public String getLastName() {
	    return lastName;
	  }

	  public void setFirstName(String firstName) {
	    this.firstName = firstName;
	  }

	  public void setLastName(String lastName) {
	    this.lastName = lastName;
	  }

	public AddressTemp getLocalAddress() {
		return localAddress;
	}

	public void setLocalAddress(AddressTemp localAddress) {
		this.localAddress = localAddress;
	}
	
	
}

